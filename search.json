[{"title":"1. 简介","url":"/1-introduction.html","content":"本文档提供关于 OpenCore 用户配置文件的信息，以使 macOS 操作系统正常工作。你应当视本文档为 OpenCore 预期行为的解释。如果在已经发布的 OpenCore 版本中找到与文档中的描述存在偏差的行为，应当视为 OpenCore 存在 Bug 或文档出现错误，应通过 Acidanthera Bugtracker 进行反馈。 OpenCore 记录重大勘误的文档可在 这里 查看。 本文档仅作为规范结构、并非用于提供手把手的配置教程。本文档的目标受众是程序员、工程师、对 macOS 内部和 UEFI 有足够了解的人。因此本文档只提供英文版本，任何通过其他来源分发的文档和文档翻译都是非官方的，并且可能存在错误。 译者注： 此处以及之后的「本文档」都指代 OpenCore 的官方文档（而非你现在访问的网站）。 你应当使用英语在 Acidanthera Bugtracker 进行反馈。 对于大部分用户来说，第三方提供的教程、工具可能更易于使用、受众更广。但是这类材料（译者注：即由第三方提供的，如「手把手的配置教程」）都容易受到其作者的喜好和品位、对本文档的误解、过时的理解等因素的影响。如果您正在使用这些资料来源，例如 OpenCore Install Guide（及其 父页面）或者「OpenCore 非官方简体中文翻译」，请务必在参考本文档后再作出每个决定、并判断其后果。 在通过 Acidanthera Bugtracker 反馈任何问题之前，请确保你彻底理解了 OpenCore 的每个配置选项及其对应的概念。 注：感谢 Andrey1970, Goldfish64, dakanji, PMheart 和 众多贡献者 的宝贵贡献，多亏了这些人的付出和努力，本文档才得以诞生。 1.1 通用术语 plist — 是一种用 XML 编写的、储存 ASCII 属性列表格式的集合文件，又称 XML 1.0 版。 统一类型标识符（UTI）： com.apple.property-list。 plist 由多个 plist object 组成，这些对象组合在一起形成一种具有层次的结构。 由于 plist 格式的定义不明确，因此本文中的所有定义只有在运行 plutil -lint 有效后才能被应用。外部参考： , man plutil。 plist type — 指 plist 集合（plist array, plist dictionary, plist key）和基本类型（plist string, plist data, plist date, plist boolean, plist integer, plist real）。 plist object — 是用来定义 plist type 的实现形式，可以理解为值。 plist array — 类数组集合，参数为 array。包含零个或多个 plist object。 plist dictionary — 类地图（关联数组）集合，参数为 dict 。包含零个或多个 plist key。 plist key — 包含一个以 plist key 名称命名的 plist object，参数为 key。由 7 位 ASCII 集的可打印字符组成。 plist string — 7 位 ASCII 集的可打印字符串，参数为 string。 plist data — base64 编码的对象，参数为 data。 plist date — ISO-8601 日期表示法，参数为 date，不支持。 plist boolean — 逻辑声明对象，其值为 true (1) 或 false (0)，参数为 true 和 false。 plist integer — 带符号的 10 进制，参数为 integer。适用于以二进制补码表示的 64 位无符号整数，除非在特定的 plist object 描述中明确提及一个更小的、有或无符号的整数类型。 plist real — 浮点数，参数为 real，不支持。 plist multidata — 实现将 value 强制转换为 data。 允许传递 plist string，此时的结果用空结果字节序列（即 C 字符串）表示；允许传递 plist integer，此时的结果用二进制补码形式的 32 位小尾数字节序列表示；允许传递 plist boolean， 此时的值为一个字节：01 表示 true，00 表示 false；允许传递 plist data 本身。其他类型或更大的整数会导致未定义、非预期的行为。 "},{"title":"2. 配置","url":"/2-configuration.html","content":"2.1 配置术语 OC config — OpenCore 的配置文件，格式为 plist，文件名为 config.plist。OpenCore 的配置文件具有可扩展性，并被设计为具有多个命名空间的结构。每个命名空间下允许具有 plist array 或 plist dictionary，在本文档相应部分中对其进行了描述。 valid key — OC Config 中的 plist key 对象。除了明确描述的 valid key 以外，以 # 符号开头的值（如 #Hello）也将被视为 valid key，并被表示为注释。虽然表示为注释的值会被丢弃，但是它们仍然是 valid key。其他的 plist key 都是无效、不合法的，它们的存在可能会导致未定义、非预期的行为。 valid value — 有效、合法的 plist object，并能匹配一些特定的 plist object 描述中所有附加条件（若有）。 invalid value — 指 plist object 本身是有效、合法的，但属于其他 plist type、与特定 plist object 描述中附加条件不符（例如取值范围）或者在对应集合中空缺。invalid value 会被不确定的方式读取为这个 plist object 的任何可能值（即，重启前后的值可能会不同），可能报错也可能不报错。尽管读取 invalid value 相当于读取某些已定义的 valid value，但是将不兼容的值应用于主机系统可能会产生未定义、非预期的行为。 optional value — 可空缺，或以特定 plist object 描述提供的特定方式（区别于 invalid value）读取的有效值。而其他情况下（译者注：未提供读取方式）的 invalid value 仍然会被应用。Value 除非被明确标记为 optional value，否则必须存在，如果空缺则会被读取为 invalid value。 fatal behaviour — 导致引导终止的行为。对 fatal behaviour 的实现，要求必须停止引导过程，直到下一次主机系统引导为止。允许，但不强制要求执行冷重启或显示任何警告消息。 undefined behaviour — 本文档中未定义的行为，通常是因为某一选项的特定配置、或某些值被忽略导致的。在这种情况下，其实现可能会采取包括 fatal behaviour，而这些行为一般都会对系统安全性产生负面影响。 译者注：以上术语的相关描述仅限于本文档所指的 OC Config。 2.2 配置处理如果 OpenCore 发现了 OC Config，则至少会读取并处理一次。根据 OpenCore 的引导机制，如果存在多个 OC Config 文件，OpenCore 可能会读取其中任何一个。如果硬盘中没有 OC Config并且引导没有中止，则OpenCore 将会遵循无效值和可选值的规则。 OC Config 有大小、嵌套和键值数量的限制。OC Config 的大小不得超过 32 MB，嵌套层数不得超过 32 层，每个 plist object 中最多有 32768 个节点（一个 plist dictionary 将被计为一对节点）。不符合上述规则的 OC Config 文件将可能导致未定义、非预期的行为。常见的 OC Config 错误包括： OC Config 不符合 plist DTD 1.0 存在本文档中不支持的或不合法的 plist object 违反文件大小、嵌套层级和键值数量的限制 我们建议（但非强制）遇到格式错误的 OC Config 时中止、当作 OC Config 不存在的情况来处理。为了能够向前兼容，我们建议（但非强制）对采用无效值的行为进行警告。采用无效值的建议做法是在使用的情况下遵守以下规则： Type Value plist string Empty string (&lt;string&gt;&lt;/string&gt;) plist data Empty data (&lt;data&gt;&lt;/data&gt;) plist integer 0 (&lt;integer&gt;0&lt;/integer&gt;) plist boolean False (&lt;false/&gt;) plist tristate False (&lt;false/&gt;) 2.3 配置结构OC Config 包括以下几个独立部分，将在本文档中分别进行介绍。默认情况下配置文件将尽可能不启用任何功能以及禁用某些功能。总的来说，这些配置一般由如下的操作构成： Add：为数据提供 添加 操作支持。已经存在的值不会被覆盖，必要时请使用 Delete。 Delete：为数据提供 删除 操作支持。 Patch：为数据提供 补丁 操作支持。 Quirks：提供特定的变通方法支持。 配置文件分为以下几个独立部分： ACPI Booter DeviceProperties Kernel Misc NVRAM PlatformInfo UEFI 译者注：对上述部分的介绍位于文档的第 4 至 11 章节。可以在本网站左侧边栏中的目录中找到这些章节的入口。 你可以使用 ocvalidate 工具对配置文件进行基本验证。请注意，ocvalidate 的版本必须和 OpenCore 的版本一致。ocvalidate 不一定能够检测出所有的错误。 注：为了保持系统的完整性，目前大多数属性都有默认值（译者注：后续文档中以 FailSafe 字段呈现）。如果在配置项中未指定任何值，默认值将会生效。不要依赖默认值，务必在配置中正确指定所有字段。"},{"title":"3. Setup","url":"/3-setup.html","content":"3.1 目录结构 Figure 1: 目录结构 使用目录引导时，使用的目录结构应该遵循上述目录结构。可用的条目有： BOOTx64.efi 或 BOOTIa32.efi — 初始引导程序，用来加载 OpenCore.efi。固件默认加载BOOTx64.efi，这与UEFI规范一致。对于大部分固件来说，BOOTx64.efi 是 UEFI 默认启动项，但也可以重命名后放到自定义位置，避免因 BOOTx64.efi 被其它操作系统（如 Windows）所覆盖而导致 OpenCore 无法启动。更多细节请参见 LauncherOption。 boot — Duet bootstrap loader，用于在传统 BIOS 固件上模拟 UEFI 环境、并加载 OpenCore.efi。 ACPI — 用于存储 ACPI 补充信息的目录。 Drivers — 用于存储 UEFI 补充驱动程序的目录。 Kexts — 用于存储内核驱动（kext）补充的目录。 Resources — 媒体资源使用的目录，如 屏幕朗读 的语音文件（见「UEFI Audio 属性」章节）。这一目录同时也用于存放 GUI 界面所使用的图片，见 OpenCanopy 相关章节。 Tools — 用于存储补充工具的目录。 OpenCore.efi — 主引导应用程序，负责操作系统加载。OpenCore.efi 所在的目录称为 根目录。默认 根目录 为 “EFI/OC”，但是当直接启动 OpenCore.efi 或通过自定义启动器启动 OpenCore.efi 时，其他包含 OpenCore.efi 的目录也同样支持。 config.plist — OC Config（即 OpenCore 的配置文件，见「配置术语」）。 vault.plist — OC Config 可能加载的所有文件的哈希。 vault.sig — vault.plist 的签名文件。 SysReport — 存放 SysReport 功能产生的系统错误报告。 nvram.plist — OpenCore 变量导入文件。 nvram.fbllback — OpenCore 变量导入后备文件。 nvram.used — 切换到备用文件后重命名以前的 OpenCore 变量导入文件。 opencore-YYYY-MM-DD-HHMMSS.txt — OpenCore 日志文件。 panic-YYYY-MM-DD-HHMMSS.txt — Kernal Panic 日志文件。 注: 受限于固件的实现行为，OpenCore 可能无法访问绝对路径长度大于 OC_STORAGE_SAFE_PATH_MAX（默认值为 128 个字符，包括 0-terminator）的目录。 3.2 安装和升级如果要安装 OpenCore，请在 GPT 分区的硬盘的EFI卷上、按照上一节的文件夹结构建立文件和文件夹。尽管本文档的相应部分提供了一些你所需的外部资源（如 ACPI 表、UEFI 驱动程序或 kexts）的某些信息，但是本文档不保证会提供关于这些外部资源的全部信息。关于 kext 的完整信息可以查看由 OpenCore 提供的 可选 kext 列表；而本文档也在安全属性的相关章节提供了 Vauting 的相关信息。 OpenCore 的配置文件可以使用任何文本编辑器（如 nano、vim）进行编辑，但是专用软件可以带来更好的体验。在 macOS 上我们推荐使用 Xcode。你也可以使用 ProperTree ，这是一个轻量级的跨平台的开源 plist 编辑器。 强烈建议避免使用了解内部配置结构的配置创建工具，因为这可能导致无效的配置（因为该结构会不断更新）。如果不顾这一警告使用此类工具，请确保只使用此类工具明确支持的 OpenCore 的稳定版本。在这种情况下，考虑到其他工具可能含有恶意软件，我们鼓励使用具有透明二进制生成功能的开源方案（例如 OCAT）。此外，为特定硬件创建的配置绝不应在不同的硬件上使用。 如果要通过 BIOS 进行开机，你必须使用第三方 UEFI 环境提供程序。OpenDuetPkg 是一个常用的为旧操作系统提供 Legacy 引导的 UEFI 环境提供程序。要在这样的旧操作系统上运行 OpenCore，你可以使用一个独立的工具 BootInstall 安装 OpenDuetPkg（目前已和 OpenCore 打包在一起发布）。第三方实用程序可用于在 macOS 以外的系统上执行此操作。 如果要升级 OpenCore，请参考 Differences.pdf ，它提供了 OpenCore 配置文件变更的相关信息，以及 Changelog.md 它提供了 OpenCore 的更新日志。 译者注：以下两节是为准备参与 OpenCore 开发的人员准备的。 3.3 贡献代码OpenCore 可以作为一个标准的 EDK II 软件包进行编译，并需要 EDK II Stable。目前支持的 EDK II 版本托管在 acidanthera/audk。该软件包所需的补丁在 Patches 目录下。 当更新 LaTeX 文档（例如 Configuration.tex）时，请不要重建 PDF 文件，直到合并到主文件。这样可以避免不必要的合并冲突： -使用 pull-request 方法的外部贡献者应在 pull-request 消息中要求维护者处理 PDF 重建问题。-内部贡献者应在合并时以相同或单独的提交中重建文档。当 pull-request 消息中缺少必要的工具时，可以要求其他维护人员重建文档。 XCODE5 是官方唯一支持的工具链。其他工具链虽然也有可能正常使用，但我们的态度是既不推荐、也不支持。我们欢迎贡献一些干净、简洁的补丁，代码规范务必遵循 EDK II C Codestyle。 要使用 XCODE5 编译，除了 Xcode 之外，还需要安装 NASM 和 MTOC。建议使用最新的 Xcode 版本，不必因为工具链叫 XCODE5 而纠结于 Xcode 的版本号。命令行举例如下： Listing 1: 编译指令 对于 IDE 的用法，Xcode 项目可在资源库的根目录下获得。另一种方法是使用 Language Server Protocols。例如， Sublime Text 与 LSP for Sublime Text 插件。 在你的 UDK 根目录下添加类似内容的 compile_flags.txt 文件： Listing 2: ECC 配置 注意：样本文件中的 /UefiPackages 表示一个绝对路径。 警告工具开发人员修改 config.plist 或其他任何 OpenCore 文件时，都务必检查 opencore-version NVRAM 变量（详见后面的 Debug Properties 章节），如果版本号不支持或尚未发布，则需警告用户。OpenCore 配置可能因版本不同而改变，因此工具开发应仔细遵循本文档，否则可能会当作恶意软件并阻止发布。 3.4 代码约定和其他项目一样，我们在开发过程中也有一些约定。强烈建议所有第三方贡献者在提交补丁之前仔细阅读并遵循以下约定。另外，我们也建议在发送补丁之前先在 Acidanthera Bugtracker 里讨论一下，以免与其他人的工作重复，导致你的补丁被拒绝。 组织结构。代码库包含在 OpenCorePkg 仓库中，它是主要的 EDK II 软件包。 每当需要在多个仓库中进行修改时，都应当分别向每个仓库发送拉取请求（Pull Requests）。 提交更改应该首先提交至依赖仓库，其次才是主仓库，以避免自动构建错误。 每个独立的提交都应该用 XCODE5 编译，并最好也用其他工具链编译。在大多数情况下都可以通过 CI interface 进行检查。最好确保静态分析不提示任何警告。 外部的拉取请求和标记的提交都必须经过验证。也就是说，在 master 中的提交可能会被构建，但并不一定成功。 内部分支应命名如下：作者-名字-日期，比如 vit9696-ballooning-20191026。 提交说明（Commit Messages）应该以更改的主要模块（如库或代码模块）为前缀。例如，OcGuardLib: Add OC_ALIGNED macro。对于非库的改变，则应使用 Docs 或者 Build 作为前缀。 设计。代码库是使用独立的 C11 (C17) 子集编写的，能够被 EDK II 使用的大多数较新的工具链支持。如果下面没有讨论特殊情况，建议使用常见的软件开发操作，或者另附解释说明。 永远不要依赖未定义的行为，也要尽量避免实施定义的行为，除非明确涉及到下面的情况（如果缺少相关案例，随时都可以创建一个 Issue，不必拘谨）。 使用 OcGuardLib 来确保安全的积分运算，避免溢出。依赖无符号数回绕（Unsigned Wraparound）时应当谨慎，不要增加不必要的数量。 用 OcGuardLib 检查指针是否正确对齐，虽然架构能够反引用未对齐的指针，但是不要依赖它。 必要时使用灵活的数组成员（Flexible Array Member）替代长度为 0 或为 1 的数组。 使用静态断言（STATIC_ASSERT）进行类型和值的假设，使用运行时断言（ASSERT）进行前提条件和不变指标的合理性检查。不要使用运行时断言来检查错误，因为他们绝不应该控制业务流程，并且有可能被排除。 把 UINT32/INT32 默认为 int 大小，并用 %u、%d 和 %x 来打印。 把 UINTN/INTN 默认为未定大小，转换为 UINT64/INT64，与 %Lu、%Ld 等正常打印。 不要为了数字字面量而依赖整型提升。当类型为实现依赖（implementation-dependent）的时候，使用显式转换（Explicit Cast）；当类型大小已知的时候，使用后缀。默认 U 代表 UINT32， ULL 代表 UINT64。 尤其要确保按位运算时、特别是按位移位时，作无符号的算术。 sizeof 运算符应该尽可能地采用变量，而不是类型，否则容易出错。使用 ARRAY_SIZE 获取数组的元素大小。使用 OcStringLib 中的 L_STR_LEN 和 L_STR_SIZE 宏，获取字符串文字大小，以保证编译器的优化。 不要使用 goto 关键词。宁可在未能通过错误检查时，提前使用 return、break 或 continue，也不要嵌套条件语句。 使用 EFIAPI，强制执行 UEFI 调用约定，只在模块之间的协议、外部回调和带有变量参数的函数中使用。 为每一个新增函数提供行内注释，至少要描述其输入、输出、前置条件、后置条件，并给出简要说明。 不要使用 RETURN_STATUS。把 EFI_STATUS 默认为一个当 BOOLEAN 不够用时将始终使用的、相匹配的超集。 违反安全规定的行为应停止系统运行或强制重启。 代码规范。代码库遵循 EDK II codestyle，并作了些许改动和解释。 只为函数和变量写一次行内注释：在头文件中（如果有头文件原型）和 static 变量、函数的行内书写。 行长在 120 个字符（100 个字符更好）以内。 在转换后使用空格，例如 (VOID *)(UINTN) Variable。 换行时使用两个空格来缩进。 在公共函数前加上 Oc 或其他含义清晰的前缀。 私有的 static 函数不要加上前缀，私有的 non-static 函数要使用 Internal 前缀。 使用 SPDX 许可证标头，如 acidanthera/bugtracker#483 所示。 排错。代码库中加入了 EDK II 调试和一些自定义功能，以改善体验。 调试信息应使用模块前缀，2-5 个字母，后面加一个冒号（:）。对于 OpenCorePkg 使用 OC:，对于库和驱动程序则使用自己独特的前缀。 不要在调试信息结尾使用句点（.），要将 %r 打印的 EFI_STATUS 用连字符隔开（例如 OCRAM: Allocation of %u bytes failed - **%rtextbackslash n）。 使用 DEBUG_CODE_BEGIN () 和 DEBUG_CODE_END () 结构来看守 可能会降低版本构建性能的 和 在其他方面不必要的 调试检查。 在正常工作时，使用 DEBUG 宏打印调试信息，在 EXIT_BOOT_SERVICES 后使用 RUNTIME_DEBUG 进行调试。 使用 DEBUG_VERBOSE 调试级别留下信息，这些信息虽然目前用不到，但可以方便用于以后的调试。默认情况下， DEBUG_VERBOSE 信息即使在 DEBUG 构建中也会被忽略。 使用 DEBUG_INFO 调试级别来处理所有非关键信息（包括错误），使用 DEBUG_BULK_INFO 来处理不应该出现在 NVRAM 日志中的大量信息，因为 NVRAM 日志的大小十分受限。这些信息在 RELEASE 构建中会被忽略。 使用 DEBUG_ERROR 来打印关键的、可以看见的、可能会停止启动过程的信息，使用 DEBUG_WARN 来打印所有其他可被看见的错误信息，这些都包含在 RELEASE 构建中。 当试图找到有问题的更改时，依靠 git-bisect 功能会很有帮助。另外还有一些非官方资源，提供了按照逐条 Commit 更新的 OpenCore 编译文件，如 Dortania。"},{"title":"4. ACPI","url":"/4-acpi.html","content":"4.1 简介ACPI（Advanced Configuration and Power Interface，高级配置和电源接口）是发现和配置计算机硬件的开放标准。ACPI 规格 定义了实现用的标准表（例如 DSDT、SSDT、FACS、DMAR）和各种方法（例如 _DSM 和 _PRW）。现代硬件几乎不需要更改即可保持 ACPI 兼容性，但是 OpenCore 仍然提供了修改 ACPI 的方法。 要反汇编和编译 ACPI 表，可以使用由 ACPICA 开发的 iASL compiler。你可以从 Acidanthera/MaciASL 下载 iASL 的图形界面程序。 ACPI 更改适用于全局（适用于每个操作系统），对 ACPI 的修补按照如下顺序执行： Delete Quirks Patch Add 注： RebaseRegions 和 SyncTableIds 是特殊的，在所有其他 ACPI 变化之后处理，因为它们只能应用于最终的 ACPI 配置，包括所有的补丁和添加的表。 为了解决操作系统检测的问题，所有对 ACPI 的更改会在所有操作系统上生效。但是在某些场景下（ACPI 编写不规范、操作系统链式引导启动、ACPI 调试）会出现问题。因此在修补 ACPI 时，需要使用 \\_OSI 方法。 在系统引导前加载补丁使得编写「代理」补丁成为可能 —— 「代理」补丁即通过重命名的方法修补 DSDT 中的原始行为，然后通过 SSDT 注入同名的行为进行替代。 OpenCore、WhateverGreen、VirtualSmc、VoodooPS2 的 GitHub 仓库中都包含了部分 SSDT 和其他 ACPI 修补的方法。在 AppleLife 的 Laboratory 版块、DSDT 版块提供了不少教程和样例（例如 笔记本电池修补教程）。Dortania 也编写了许多 ACPI 有关的教程。daliansky 的 ACPI 补丁集 OC-little（5T33Z0 等人对 daliansky 的 ACPI 补丁集 OC-little 的英文翻译）。请注意，来自第三方的建议解决方案可能已经过时，或者可能包含错误。 译者注：对于中国黑苹果玩家，强烈推荐 OC-little 项目，提供了众多 SSDT 范例和相关指导；笔记本用户电池修补请参考 这篇教程。 4.2 属性列表1. AddType: plist arrayFailsafe: EmptyDescription: 从 OC/ACPI 目录加载指定的 ACPI 表。 设计为用 plist dict 值填充以描述每个块级项目。请参阅下面 4.3 Add 属性 部分。 2. DeleteType: plist arrayFailsafe: EmptyDescription: 从 ACPI 栈中删除选定的表。 设计为用 plist dict 值填充以描述每个块级项目。请参阅下面 4.4 Delete 属性 部分。 3. PatchType: plist arrayFailsafe: EmptyDescription: 在添加或删除 ACPI 表之前执行的二进制修补。 设计为用 plist dictionary 值填充以描述每个块级项目。请参阅下面 4.5 Patch 属性 部分。 4. QuirksType: plist dictDescription: 应用下文 4.6 Quirks 属性 部分中描述的 Quirks。 4.3 Add 属性1. CommentType: plist stringFailsafe: Empty stringDescription: 用于为条目提供人类可读参考的任意 ASCII 字符串（译者注：即注释）。 2. EnabledType: plist booleanFailsafe: falseDescription: 除非此值为 true，否则此 ACPI 表不会被添加。 3. PathType: plist stringFailsafe: EmptyDescription: 需要加载的 ACPI 表所在的路径。示例值如 DSDT.aml、SubDir/SSDT-8.aml、SSDT-USBX.aml。 所有 ACPI 表都从 OC/ACPI 目录加载，加载顺序遵循数组中的项目顺序。 注： 除具有 DSDT 表标识符（由解析得到的数据、而非由其文件名决定）的表外，所有表都将作为新表插入 ACPI 栈。而 DSDT 表与其余的表不同，将会执行 DSDT 表的替换。 4.4 Delete 属性1. AllType: plist booleanFailsafe: falseDescription: 如果设置为 true，则所有符合条件的 ACPI 表都会被舍弃。 否则，只舍弃第一个匹配到的。 2. CommentType: plist stringFailsafe: EmptyDescription: 用于为条目提供人类可读参考的任意 ASCII 字符串（译者注：即注释）。 3. EnabledType: plist booleanFailsafe: falseDescription: 设置为 true 可以舍弃这个 ACPI 表。 4. OemTableIdType: plist data, 8 bytesFailsafe: All zero（匹配任何表的 OEM ID）Description: 将表的 OEM ID 匹配为此处所填的值。 5. TableLengthType: plist integerFailsafe: 0（匹配任何表的大小）Description: 将表的大小匹配为此处所填的值。 6. TableSignatureType: plist data, 4 bytesFailsafe: All zero（匹配任何表的签名）Description: 将表的签名匹配为此处的值。 注：当序列需要在多处替换的时候，务必注意不要指定表的签名，尤其是在进行不同类型的重命名操作的时候。 4.5 Patch 属性1. BaseType: plist stringFailsafe: Empty（Ignored）Description: 为重命名补丁指定一个 ACPI 路径，让 OC 通过取得该路径的偏移量来查找（或替换）重命名补丁。留空时忽略。 只有正确的绝对路径被支持（例如：\\_SB.PCI0.LPCB.HPET）。目前支持的 Object 类型有：Device、Field、Method。 注：应谨慎使用，并非所有 OEM 的 ACPI 表都能被正确处理。如果遇到问题，可使用 Utilities 中的 ACPIe 工具来进行调错。使用 DEBUG=1 参数来编译 ACPIe 将会使该工具输出有助于调试的 ACPI 路径查找过程。 2. BaseSkipType: plist integerFailsafe: 0 (不跳过任何事件)Description: 在应用查找和替换之前跳过找到的 Base 事件数。 3. CommentType: plist stringFailsafe: EmptyDescription: 用于为条目提供人类可读参考的任意 ASCII 字符串（译者注：即注释）。 4. CountType: plist integerFailsafe: 0 (将补丁应用于找到的所有事件)Description: 要修补的事件数。 5. EnabledType: plist booleanFailsafe: falseDescription: 设置为 true 以应用此 ACPI 补丁。 6. FindType: plist dataFailsafe: EmptyDescription: 需要寻找的 Data，如果设置，长度必须和 Replace 相等。 注意：可以留空；当指定 Base 时，在这种情况下，Base 查询后会立即发生替换。 7. LimitType: plist integerFailsafe: 0（遍历整个 ACPI 表）Description: 要搜索的最大字节数。 8. MaskType: plist dataFailsafe: Empty (Ignored)Description: 查找比较期间使用的数据按位掩码。 通过忽略未屏蔽（设置为 0）位来进行模糊搜索。如果设置，此值的长度必须和 Replace 的长度相等。 9. OemTableIdType: plist data, 8 bytesFailsafe: All zero（匹配任何表的 OEM ID）Description: 将表的 OEM ID 匹配为此处所填的值。 10. ReplaceType: plist dataFailsafe: EmptyDescription: 一个或多个字节的替换数据。 11. ReplaceMarkType: plist dataFailsafe: Empty (Ignored)Description: 替换数据期间使用的数据按位掩码。 通过忽略未屏蔽（设置为 0）位来进行模糊搜索。如果设置，此值的长度必须和 Replace 的长度相等。 12. SkipType: plist integerFailsafe: 0 (不跳过任何事件)Description: 在应用替换之前要跳过的找到的事件数。 13. TableLengthType: plist integerFailsafe: 0 （匹配任何表格的大小）Description: 将表的大小匹配为此处所填的值。 14. TableSignatureType: plist data, 4 bytesFailsafe: All zero (匹配任何表格签名)Description: 将表的签名匹配为此处的值。 大多数情况下，ACPI 补丁是有害而无益的： 避免用 ACPI 补丁重命名设备。这样做可能会使设备重命名失败，或者会对不相关的设备进行错误地重命名（如 EC 和 EC0）。为了保证 ACPI 的一致性，在 I/O 注册表级别重命名设备会更加安全，就像 WhateverGreen 做的那样。 尽量避免为了支持更高级的功能集而给 _OSI 打补丁。虽然这可以在 APTIO 固件上实现一些变通，但它通常会导致需要用打更多的补丁去填坑。现代的固件基本不需要这些，而在真正需要的固件上，只要打一些小补丁就可以了。然而，笔记本厂商通常依靠这种方法来确定是否有现代 I2C 输入支持、散热调节功能，或用来添加其他自定义功能。 避免为了启用亮度调节键而给 EC 事件 _Qxx 打补丁。传统的方法通常需要在 DSDT 和 SSDT 上进行大量的修改，而且新系统上的 debug kext 并不稳定。请改用 BrightnessKeys 中内置的亮度调节键检测功能来代替。 尽量避免重命名 _PRW 或 _DSM 之类的魔改举动。 在某些情况下，打补丁是很有用的： 刷新 HPET（或其他设备）的 method header 来避免老硬件上的 _OSI 兼容性检查。可通过将 A0 10 93 4F 53 46 4C 00 替换为 A4 0A 0F A3 A3 A3 A3 A3 的办法，使带有 if ((OSFL () == Zero)) &#123; If (HPTE) ... Return (Zero) 的 _STA method 达到强制返回 0xF 的目的。 在 SSDT 中实现自定义 method，比如在某些计算机上注入关机修复，通过将 _PTS 替换为 ZPTS，把原来的 method 替换为一个假的名字，并添加一个 callback 回调到原 method 中。 TianoCore 源文件 AcpiAml.h 可能会对于理解 ACPI 操作码有所帮助。 注：Find 和 Replace 的长度 必须完全一样，否则 ACPI 表可能会被破坏、导致系统不稳定。必要时请使用「代理」补丁的方法、或使用 NOP 填充剩余区域 4.6 Quirks 属性1. FadtEnableResetType: plist booleanFailsafe: falseDescription: 在 FADT 表中提供寄存器复位标志，用于修复旧硬件的重启和关机。除非需要，否则不建议启用。 只有在传统硬件和少数笔记本上需要。这一 Quirk 也可以修复电源快捷键（译者注：Command + 电源键）。不建议启用，除非不启用就无法关机和重启。 2. NormalizeHeadersType: plist booleanFailsafe: falseDescription: 清理 ACPI 表头字段以解决 macOS ACPI 实现错误导致的引导崩溃。参考：由 Alex James（theracermaster）在调试 AppleACPIPlatform 时发现。在 macOS Mojave (10.14) 中，这个错误已经被修复。 3. RebaseRegionsType: plist booleanFailsafe: falseDescription: 尝试试探性地重定位 ACPI 内存区域。不建议启用这一选项，除非你需要自定义 DSDT。 ACPI 表通常由底层固件动态生成。在与位置无关的代码中，ACPI 表可能包含用于设备配置的 MMIO 区域的物理地址，通常按区域（例如：OperationRegion）分组。 更改固件设置或硬件配置，升级或修补固件不可避免地会导致动态生成的 ACPI 代码发生变化，这有时会导致上述 OperationRegion 结构中的地址发生变化。 因此，对 ACPI 表进行任何形式的修改都是非常危险的。最好的方法是对 ACPI 进行尽可能少的更改，避免替换任何表，尤其是 DSDT。如果无法不得不替换 DSDT，则至少应尝试确保自定义 DSDT 基于最新的 DSDT 或避免对受影响区域的读写。 如果没有其他帮助，可以尝试通过尝试修复 ACPI 地址来避免在 macOS 引导的 PCI Configuration Begin 阶段出现停顿的情况。然而，这不是一个灵丹妙药，只在最典型的情况下有效。除非绝对需要，否则不要使用，因为它在某些平台上可能产生相反的效果，导致启动失败。 4. ResetHwSigType: plist booleanFailsafe: falseDescription: 将 FACS 表中 HardwareSignature 的值重置为 0。 启用这一选项可以解决固件无法在重新启动过程中保持硬件签名导致的休眠唤醒问题。 5. ResetLogoStatusType: plist booleanFailsafe: falseDescription: 将 BGRT 表中 Displayed 状态字段重置为 false。 这适用于提供 BGRT 表、但随后无法处理屏幕更新的固件。如果在开机时无法显示 OEM Windows 标志可以尝试开启。 6. SyncTableIdsType: plist booleanFailsafe: falseDescription: 将表的标识符与 SLIC 表进行同步。 这可以解决打了补丁的表与 SLIC 表不兼容导致的旧版 Windows 系统中的许可问题。"},{"title":"6. DeviceProperties","url":"/6-device-properties.html","content":"6.1 简介设备相关配置通过专用的缓存区（EfiDevicePathPropertyDatabase）提供给 macOS，这个缓冲区是设备路径到属性名称与值的键值对的序列化映射。 属性相关数据可以使用 gfxutil 进行调试。在 macOS 下获取当前属性数据请使用 ioreg： 设备属性属于 macOS IO Registry 中的 IODeviceTree(gIODT) 层面，这个层面有很多与平台初始化相关的构建阶段（Construction Stage）。尽管早期的构建阶段是由 XNU 内核用 IODeviceTreeAlloc Method 来执行的，绝大部分仍然是由 Platform Expert 来构建、用 AppleACPIPlatformExpert.kext 来实现的。 AppleACPIPlatformExpert 包含了两个阶段的 IODeviceTree 构建，通过调用AppleACPIPlatformExpert::mergeDeviceProperties 来实现： 在 ACPI 表初始化过程中，通过调用 AppleACPIPlatformExpert::createDTNubs 递归扫描 ACPI 命名空间。 在 IOService 注册（IOServices::registerService）回调过程中，作为 AppleACPIPlatformExpert::platformAdjustService 函数和它私有的、针对 PCI 设备的 Worker Method AppleACPIPlatformExpert::platformAdjustPCIDevice 的一部分。 各阶段的应用取决于 ACPI 表中存在的设备。第一阶段适用于很早、但只适用于存在于 ACPI 表中的设备。第二阶段适用于所有晚于 PCI 配置的设备，如果设备没有出现在 ACPI 中，则会重复第一阶段。 所有的内核驱动可以在不探测设备的情况下检查 IODeviceTree 层面，例如 Lilu 和它的插件以及 WhateverGreen，因此确保 ACPI 表中的设备存在是尤其重要的。如果不这样做，则可能会因为注入的设备属性被忽略而导致各种不稳定的行为，原因是它们没有在第一阶段被构建出来。参见 SSDT-IMEI.dsl 和 SSDT-BRG0.dsl 的例子。 6.2 属性列表1. AddType: plist dictDescription: 将设备属性从设备路径的映射（plist dict）设置为变量名称和值的映射（plist dict），其中变量名称和值的格式为 plist metadata。 注 1：设备路径必须以规范化字符串格式（Canonical String Format）提供，例如： PciRoot(0x0)/Pci(0x1,0x0)/Pci(0x0,0x0。 注 2：现有的属性不会被改变，除非在 DeviceProperties 部分删除。 2. DeleteType: plist dictDescription: 从设备路径的映射（plist dict）到 plist string 格式的变量名数组（数据类型 plist array）中删除设备属性。 注：目前，现有的属性可能只存在于具有 DeviceProperties 驱动程序的固件上（例如：Apple）。因此，除非安装了新的驱动程序，否则通常没有理由删除变量。 译者注：这里的设置等同于 Clover 里的 ACPI 重命名 _DSM → XDSM =&gt; TgtBridge 6.3 常见属性一些已知的属性包括： device-id用户指定的设备标识符，用于 I/O 套件匹配。数据类型为 4 byte data。 vendor-id用户指定的供应商标识符，用于 I/O 套件匹配。数据类型为 4 byte data。 AAPL,ig-platform-idIntel GPU 缓冲帧标识符，用于在 Ivy Bridge 上选择缓冲帧区域。数据类型为 4 byte data。 AAPL,snb-platform-idIntel GPU 缓冲帧标识符，用于在 Sandy Bridge 上选择缓冲帧区域。数据类型为 4 byte data。 layout-idAppleHDA 的音频布局，4 byte data。 "},{"title":"OpenCore 简体中文参考手册","url":"/","content":" OpenCore 参考手册 阅读须知你现在访问的是由 非官方 维护的 OpenCore 参考手册的简体中文翻译（以下简称本网站）。 本网站以及网站的维护人员和 OpenCore 的开发团队 acidanthera 以及 OpenCore 的文档版权所有者 vit9696 没有任何关系。本网站对 OpenCore 的 Logo（商标）的使用已经通过 acidanthera 的授权。 OpenCore 仍处于积极的维护之中，OpenCore 参考手册 仍然在高频率更新，本网站提供的内容 仅可供参考。本网站的内容和 OpenCore 官方的参考手册的任何出入，请以 OpenCore 官方的参考手册为准。 本网站提供的翻译基于如下描述的 OpenCore 官方文档： OpenCore 文档释出日期：2023.07.25 OpenCore 文档版本：d74d43bb0279e494a75546fad8834d75172eb01e 本网站提供的翻译适用于如下描述的 OpenCore 版本： OpenCore 版本：0.9.4 本网站以及 acidanthera 不会对因本网站引起的任何损失负责，包括但不限于 Kernel Panic、设备无法开机或正常使用、硬盘损坏或数据丢失、原子弹爆炸、第三次世界大战、SCP 基金会 无法阻止的全球 CK 级现实重构等。 有用的链接 OpenCore 官方文档 OpenCore 官方文档迭代 OpenCore Install Guide — 从零开始的 OpenCore 台式机安装指南。本网站有考虑提供对该指南的简体中文翻译。 从 Clover 到 OpenCore — 由本网站的发起人和创始人 Sukka 编写的 Clover 迁移 OpenCore 的教程。 精解 OpenCore | 黑果小兵 — 本网站的部分翻译参考的就是黑果小兵前辈的这篇文章。 使用 OpenCore 引导黑苹果 | Xjn’s Blog — 提供了很多台式机上排错和完善的指南。 维护者OpenCore 简体中文参考手册 © Sukka. 由 Sukka 和 众多的贡献者 一起维护。 Sukka’s Homepage · Sukka’s Blog · GitHub @SukkaW · Telegram Channel @SukkaChannel · Twitter @isukkaw · Keybase @sukka "},{"title":"附录 1. OpenCore 兼容 Kext 列表","url":"/kextlist.html","content":"有线网卡 Name Description MinKernel (Min macOS) MaxKernel (Max macOS) AppleRTL8169Ethernet Realtek RTL8169 官方驱动，通过电子邮件发送下载链接 — — AtherosE2200Ethernet.kext 高通 Atheros Killer E2200 系列驱动 — — AtherosL1cEthernet.kext 高通 Atheros AR813x/815x 驱动 — — IntelMausi.kext 由 Acidanthera 维护的英特尔有线网卡驱动 13.0.0 (10.9) — IntelSnowMausi.kext 由 Acidanthera 维护的 macOS 10.6-10.8 可用的英特尔有线网卡驱动 10.0.0 (10.6) Not tested — IntelMausiEthernet.kext 由原作者（Mieze）提供的英特尔有线网卡驱动 — — NullEthernetInjector.kext RehabMan 提供的仿冒内建网卡 — — RealtekR1000SL.kext Realtek 8111B/C/D/E/EP/F/G/GU/8411B 系列驱动 — — RealtekRTL8100.kext Realtek RTL810X 系列驱动 — — RealtekRTL8111.kext Realtek RTL8111/8168 系列驱动 — — Wi-Fi 和蓝牙 Name Description MinKernel (Min macOS) MaxKernel (Max macOS) AirPortAtheros40.kext 高通 Atheros AR92xx/AR93xx 驱动，仅适用于 macOS 10.13.6 和 macOS 10.14+ 18.0.0 (10.14) From 10.13 — AirportBrcmFixup.kext 非苹果官方博通网卡修复 12.0.0 (10.8) — ATH9KFixup.kext 高通 Atheros AR9xxx 无线网卡修复 — — BrcmPatchRAM.kext 博通网卡蓝牙固件 14.0.0 (10.10) — IntelBluetoothFirmware Intel 蓝牙固件驱动 — — AirportItlwm Intel WIFI固件驱动 — — itlwm Intel WIFI固件驱动 — — MT7610 联发科 MT7610 官方驱动 — — RT5370 联发科 RT5370 官方驱动 — — RTL8192CU Realtek RTL8192CU 驱动 — — 译者注：上述 RTL8192CU 驱动链接为 Google Drive 分享，直链下载地址： macOS 10.6 macOS 10.9 键盘、鼠标和触摸设备 Name Description MinKernel (Min macOS) MaxKernel (Max macOS) ApplePS2SmartTouchPad.kext 触摸板和键盘 — — GK701HIDDevice.kext 华硕 Fn 键、键盘背光灯和环境光传感器驱动 — — NoTouchID.kext 禁用 Touch ID 检测 17.0.0 (10.13) — SerialMouse.kext 使用 Microsoft 串行鼠标协议的串行鼠标驱动 — — VoodooI2C.kext 驱动 I2C 触摸板 / 屏 16.0.0 (10.12) — VoodooPS2Controller.kext 驱动 PS2 键盘 / 鼠标 / 触摸板 15.0.0 (10.11) — VoodooPS2Keyboard.kext — 15.0.0 (10.11) — VoodooPS2Mouse.kext — 15.0.0 (10.11) — VoodooPS2Trackpad.kext — 15.0.0 (10.11) — VoodooInput.kext 为 PS2 输入源提供 Magic TrackPad 2 触控模拟 15.0.0 (10.11) — VoodooSMBus.kext 提供 i801 SMBus 支持和 Thinkpad T480s, L380, P52 的 ELAN 触摸板驱动 18.0.0 (10.14) — VoodooRMI.kext 驱动 Synaptic SMBus 触摸板 / 小红点 15.0.0 (10.11) — AlpsT4USB.kext VoodooI2C 的卫星插件 Kext，为 Alps T4 USB 触控板提供原生苹果手势支持 — — 音频和视频 Name Description MinKernel (Min macOS) MaxKernel (Max macOS) AppleALC.kext 定制声卡驱动 12.0.0 (10.8) — EMUUSBAudio.kext 适用于 Creative Labs EMU USB 的驱动程序 — — kXAudioDriver.kext 适用于 kX 音频设备的驱动 — — Nvidia CUDA drivers NVIDIA CUDA 官方驱动 10.0.0 (10.6) 17.9.9 (10.13) Nvidia Web-drivers NVIDIA 显卡官方驱动 12.0.0 (10.8) 17.9.9 (10.13) SNBGraphicsMojaveInstaller 二代酷睿核显驱动，仅适用于 macOS 10.13.6 和 macOS 10.14+ 18.0.0 (10.14) From 10.13 — VoodooHDA.kext 万能声卡驱动 — — WhateverGreen.kext 显卡补丁驱动 12.0.0 (10.8) — Polaris22Fixup.kext Polaris22/VegaM 显卡修复 18.0.0 (10.14) — CPU 和 SMC Name Description MinKernel (Min macOS) MaxKernel (Max macOS) AAAMouSSE.kext — 16.0.0 (10.12) — AppleMCEReporterDisabler.kext — — — AsusSMC.kext VirtualSMC 插件，为华硕笔记本电脑上的 ALS、键盘背光、Fn 键提供支持 — — CPUFriend.kext CPU 变频管理 15.0.0 (10.11) — HWPEnabler.kext 启用 HWP 驱动 — — OpcodeEmulator.kext Opcode 模拟驱动 — — telemetrap.kext — 18.0.0 (10.14) — TSCAdjustReset.kext TSC 频率同步驱动 — — VoodooTSCSync.kext 由 Rehabman 提供的 TSC 频率同步驱动 — — CpuTscSync.kext Lilu 插件，合并了 VoodooTSCSync 功能 12.0.0 (10.8) — FakeSMC.kext Clover 官方的 FakeSMC — — VirtualSMC.kext Acidanthera 提供的 VirtualSMC 10.0.0 (10.6) - SMCLightSensor.kext VirtualSMC 插件，提供光线传感器支持 10.0.0 (10.6) Not tested — SMCSuperIO.kext VirtualSMC 插件，提供风扇信息读取支持 10.0.0 (10.6) Not tested — SMCBatteryManager.kext VirtualSMC 插件，提供电池相关的传感器支持 10.0.0 (10.6) Not tested — SMCProcessor.kext VirtualSMC 插件，提供 CPU 温度传感器支持 11.0.0 (10.7) Not tested — SMCDellSensor.kext VirtualSMC 插件，为戴尔电脑提供温度和风扇传感器支持 11.0.0 (10.7) Not tested — AMDRyzenCPUPowerManagement.kext XNU 内核扩展，用于 AMD 处理器的电源管理和监控。 11.0.0 (10.7) Not tested — SMCAMDProcessor.kext 收集传感器数据，并发送到 VirtualSMC，以使 macOS 应用程序能够显示传感器数据，该 kext 依赖 AMDRyzenCPUPowerManagement.kext 11.0.0 (10.7) Not tested — USB 和其他端口 Name Description MinKernel (Min macOS) MaxKernel (Max macOS) IOElectrify.kext 在雷电 3 设备上启用常开电源 — — Legacy_InternalHub-EHCx.kext — 15.0.0 (10.11) — Legacy_USB3.kext — 15.0.0 (10.11) — NVMeFix.kext 由 Acidanthera 提供的改善第三方 SSD 兼容性的驱动程序 18.0.0 (10.14) — USBWakeFixup.kext 解决从 USB 唤醒设备时无法唤醒显示器，需要再按一次按键或再按一次鼠标来唤醒显示器的问题 — — SASMegaRAID.kext LSI MegaRAID SAS 系列 RAID 控制器驱动 — — Sinetek-rtsx.kext Realtek RTSX SDHC 读卡器驱动 — — VoodooSDHC.kext SDHC 读卡器驱动 — — 其他 Name Description MinKernel (Min macOS) MaxKernel (Max macOS) AppleIntelInfo.kext CPU / 核显变频测试 — — DebugEnhancer.kext macOS 内核调试输出驱动 12.0.0 (10.8) — HibernationFixup.kext 修复因 RTC 变量和 NVRAM 造成的睡眠问题 14.0.0 (10.10) — Lilu.kext SDK &amp; Library 10.0.0 (10.6) — RTCMemoryFixup.kext 修复 BIOS CMOS (RTC) 内存和 AppleRTC 之间的冲突问题 12.0.0 (10.8) — NightShiftEnabler.kext 解锁 Night Shift 16.0.0 (10.12) — WebCamera.kext 某些旧设备的摄像头驱动 — — TOSMotionSensor.kext 东芝设备的加速度传感器驱动 — — NVMeFix.kext NVMeFix 是 Apple NVMe 存储驱动程序 IONVMeFamily 的一组补丁。其目标是提高与非 Apple SSD 的兼容性。它可以在苹果和非苹果计算机上使用 — — 更完整的列表（包含旧版）托管在 这里。完整的 Lilu 插件列表（包含旧版）托管在 这里。仅供开发者使用。 Acidanthera GitHub 仓库 之外的内核扩展均与 Acidanthera 无关。此列表仅供参考，不作任何形式的保证。 "},{"title":"贡献指南","url":"/about/contributing.html","content":"目录结构文档所有文件位于 source 下。 about 目录：关于项目自身的文档，如你现在看到的「贡献指南」的 md 源文件就位于这个目录下 guide 目录：如果未来项目开始收录 OpenCore 指南类的文章，就将相关的 md 文件放在这个目录下 img 目录：存放文档中使用的图片 logo 目录：存放 OpenCore 的 Logo 和网站的 favicon CNAME 文件：GitHub Pages 绑定自定义域名 index.md 文件：网站首页的 md 源文件 其余 .md 文件：经过整理的 OpenCore 参考手册的 md 源文件（需要翻译的就是这些文件） Markdown 文件的 Front-Matter 的字段说明 当你完成了对一个文件的整理、翻译后，别忘了修改 author_info 和 last_updated 两个字段！ Commit Message 规范 type init: Initialization 初始化项目、模块、组件 docs: Documentation 文档（包括 README 的更新） revert: Revert 代码回退，用于撤回某个改动 feat: New feature 新功能 fix: Fix bug 修补 bug style: Format 格式（不影响代码运行的变动） refactor: Refactor 重构（即不是新增功能，也不是修改 bug 的代码变动） test: Test 测试相关 workflow: WorkFlow 工作流相关 chore: 构建过程或辅助工具的变动 merge: 合并 Pull Request ci: 持续集成和构建相关 允许多个 type 的使用，如修复文档中的 Typo 可以用 docs/type 作为 type。 scope scope 用于说明 commit 影响的范围（一般取修改的文件的名称），紧接 type 置于 () 之内。 scope 非必须，当改动代码范围较大或者范围不明确时可忽略。 当使用 Merge Pull Request 合并不同分支时，scope 为 PR 在 GitHub 上的编号；当使用 revert 回退代码时，scope 为对应 commit 的 Title，也可以是简短的介绍。 subject subject 是 commit 目的的简短描述，不超过 50 个字符。 以动词开头 使用第一人称现在时比如 change，尽可能避免使用 changed 或 changes 首字母小写，并且 尽可能 subject 全部小写 结尾不加句号 . 当 type 是 merge 时，subject 应为 from {base branch name} into {target branch name} body Body 部分是 可选的 对本次 commit 的详细描述，可以分成多行。下面是一个范例。 和 title.subject 不同，Body 的要求如下： Body 是可选、非必须的 使用第一人称现在时比如 change，尽可能避免使用 changed 或 changes 应该说明代码变动的动机，以及与以前行为的对比。 如果使用 Squash 合并分支时，Body 为以无序列表排列的对应多条 commit 记录。 其他参考资料 Hexo 文档 hexo-theme-doku 文档 "},{"title":"12. 排错","url":"/12-troubleshooting.html","content":"12.1 旧版 Apple 操作系统旧版操作系统的安装可能比较复杂，但有时出于各种原因还是需要用到。主板标识符和 CPUID 的兼容性是旧版操作系统正常运行的基础，除此之外还有一些细枝末节的事情需要注意。本章节将尽量阐述与旧版 macOS 操作系统相关的一系列常见问题。 尽管较新的操作系统可以通过互联网下载，但旧版操作系统并不是每个次要版本都有安装介质的，因此要想获得兼容的发行版，可能需要下载特定设备的镜像，并在必要时进行修改。Mac 电脑随附的 macOS 旧版本和旧版号列表，可以从这篇 Apple 支持的 存档文章 中找到，但由于它并不一定准确，下面列出了一些旧版 Apple 操作系统最后发布的版本。 1. macOS 10.8 和 10.9 这两个系统的磁盘映像使用的是 Apple 分区方案（Apple Partitioning Scheme），需要 OpenPartitionDxe 驱动程序来进行 DMG 恢复和安装（OpenDuet 中也同样需要）。可以将 DmgLoading 设置为 Disabled，这样就可以在不加载 DMG 的情况下运行恢复功能，同时也避免了 OpenPartitionDxe 的需求。 缓存的内核映像通常不包括网络（IONetworkingFamily）或音频（IOAudioFamily）的家族驱动，这些家族驱动往往需要使用 Force 加载来注入。 2. macOS 10.7 上述问题均存在 SSSE3 支持（不要和 SSE3 混淆）是 macOS 10.7 内核的硬性要求。 包括 Lilu（使用 32 位内核时）及其插件在内的许多 Kext 在 macOS 10.7 或更低版本上都不支持，它们所需的内核 API 比较新，不在 macOS 10.7 SDK 之中。 macOS 10.8 之前的系统不支持 KASLR slide，因此会导致内存较低的固件分配内存失败，详见 acidanthera/bugtracker#1125。 3. macOS 10.6 上述问题均存在。 SSSE3 支持是启用了 64 位用户空间的 macOS 10.6 内核的要求。这个限制大多可以通过启用 LegacyCommpage Quirk 来解除。 最近发布的 macOS 10.6 安装镜像为 macOS 10.6.7 版本号 10J3250（适用于 MacBookPro8,x）和 10J4139（适用于 iMac12,x，不含 Xcode）。这些镜像仅限于特定的几款机型，并且不支持使用 -no_compat_check 来忽略兼容性检查。如果你拥有 macOS 10.6 的合法副本，又不想被上述限制所约束，可以在 这里（或 MEGA 镜像）找到无机型限制的修改版镜像（ACDT 后缀），更多细节在 DIGEST.txt 中。记住，这些都是经过 OpenCore 测试的最早的 macOS 10.6 版本。 机型检查可以被手动去除，大体思路是用 Flat Package Editor 之类的工具编辑 OSInstall.mpkg，让 Distribution 脚本在 hwbeModelCheck 函数中总是返回 true。仅更新映像中某一的文件而不影响到其他文件是相当困难的，而且还有可能因为内核缓存日期的改变而导致启动速度变慢，因此建议按照如下命令重建映像： 4. macOS 10.5 上述问题均存在。 这个版本的 macOS 不支持 x86_64 内核，需要 i386 内核扩展和补丁。 这个版本的 macOS 使用了第一个版本（V1）的 prelinkedkernel，但它的 Kext 符号表被 Kext 工具破坏了。这个细微的差别使得 prelinkedkernel Kext 无法被 OpenCore 注入。Mkext Kext 的注入仍然正常，也不会有明显的性能消耗，而且当 KernelCache 设置为 Auto 时，Mkext 会被自动选择。 最后发布的 macOS 10.5 的安装镜像是 macOS 10.5.7 版本号 9J3050（适用于 MacBookPro5,3）。与其他版本系统不同的是，这个镜像不受机型限制，可以原样使用。如果你拥有 macOS 10.5 的合法副本，可以在 这里（或 MEGA 镜像）找到原始的 9J3050 镜像，更多细节在 DIGEST.txt 中。注意，这是经过 OpenCore 测试的最早的 macOS 10.5 版本。 5. macOS 10.4 上述问题均存在。 这个版本的 macOS 有一个硬性要求，即需要两张光盘或两个 USB 安装介质来访问第二张 DVD 盘安装介质上的所有可选包。 最后发布的 macOS 10.4 的安装镜像是 macOS 10.4.10 版本号 8R4061a（适用于 MacBookPro3,1）和 8R4088（适用于 iMac7,1）。这些镜像与新版 macOS 一样，仅限于特定的几款机型。如果你拥有 macOS 10.4 的合法副本，可以在 这里（或 MEGA 镜像）找到无机型限制的修改版 8R4088 镜像（后缀为 ACDT），更多细节在 DIGEST.txt 中。注意，这些是经过 OpenCore 测试的最早的 macOS 10.4 版本。 12.2 UEFI 安全启动OpenCore 的设计初衷是在 固件 和 操作系统 之间提供一个安全的启动链。在大多数 x86 平台上，可信加载（Trusted Loading）是通过 UEFI 安全启动 模式实现的。OpenCore 不仅完全支持这种模式，还扩展了它的功能，以确保通过 Vault 进行配置的加密存储，并使用自定义的验证过程向操作系统提供可信加载，例如 Apple 安全启动。正确的安全启动链需要通过以下步骤来仔细配置： 如果要启动的系统是 macOS，则需要通过设置 SecureBootModel 来启用 Apple 安全启动。请注意，并不是每个 macOS 版本都能使用 Apple 安全启动，具体限制详见 Apple 安全启动 章节。 旧的 DMG 恢复镜像往往很脆弱、易受攻击，如果担心因为加载它而突破防线，可以通过设置 DmgLoading 为 Disabled 来禁用 DMG 加载。非必需，但建议使用。参阅 DMG 加载 部分来权衡利弊。 将 MinDate 和 MinVersion 设置为 0，限制旧的驱动程序加载，以确保 APFS JumpStart 功能。更多细节参见 APFS JumpStart 部分。除此之外，手动安装 apfs.efi 驱动也可以达到相同效果。 确保你想要运行的操作系统不加载 Force 驱动也能正常启动。 确保使用 ScanPolicy 限制加载不受信任的设备。要想做到足够安全，最好的办法是禁止加载 所有可移动设备 和 未知的文件系统。 使用私钥给所有已安装的驱动程序和工具签名。不要对提供管理员权限的工具（例如：UEFI Shell）签名。 加密存储你的配置，详见 Vault 部分。 使用同一私钥签名该系统使用的所有 OpenCore 二进制文件（BOOTX64.efi, BOOTIa32.efi, OpenCore.efi, 自定义启动器）。 如果需要用到第三方操作系统（非微软或 Apple 制造）的 bootloader，也同样为它们签名。对于 Linux，可以选择安装微软签名的 Shim bootloader，具体解释见 Debian Wiki。 在 BIOS 中开启 UEFI 安全启动，并用自己的私钥安装证书。很多文章都介绍了生成证书的具体方法，比如 这篇文章，本文档不再赘述。如果需要启动 Windows，还需要添加 Microsoft Windows Production CA 2011 证书。如果需要启动 Option ROM，或决定使用已签名的 Linux 驱动程序，还需要添加 Microsoft UEFI Driver Signing CA。 设置密码保护防止固件设置被篡改，避免 UEFI 安全启动在你不知情的情况下被禁用。 12.3 Windows 支持1. 我能安装 Windows 系统吗？虽然 OpenCore 并没有提供官方的 Windows 支持，但是使用 Boot Camp 安装 64 位 UEFI Windows（即 Windows 8 及更高版本）应该是可以正常工作的。安装第三方 UEFI、或者仅部分支持 UEFI 引导的系统（如 Windows 7）可能需要额外注意。不论如何，记住以下几点： MBR (Master Boot Record) 属于 Legacy 引导，因此将不会被支持。 在 OpenCore 上应用的所有更改（ACPI、NVRAM、SMBIOS）都应该与操作系统本身无关。OpenCore 会将这些改动生效于所有操作系统，这样在 Windows 上可以获得 Boot Camp 的体验。 macOS 要求硬盘中的第一份分区为 EFI 分区，并且与 Windows 的默认布局不支持。尽管 OpenCore 确实提供了一个 解决方法，但是强烈建议不要依赖这个方法。 Windows 系统可能需要重新激活。为了避免这种情况发生，请考虑将 SystemUUID 设置为原始固件的 UUID。请注意，在旧固件上 UUID 可能是无效的（非随机的）。如果你还遇到了什么问题，可以考虑使用 HWID 或 KMS38 的 Windows 许可证。从 OpenCore 0.5.8 开始，你还可以通过设置 UpdateSMBIOSMode 为 Custom 来避免 OEM 激活失效。Windows 激活的细节不在本文档的讨论范围内，你应该能够在网上查找到相关资料。 2. 我需要安装其他什么软件吗？在大多数情况下，要启用多操作系统切换、安装相关驱动程序，你将需要 Boot Camp 提供的 Windows 支持软件。为了简化下载过程、或者配置硬盘中已经安装好的 Windows，可以使用 Brigadier 这个实用软件。请注意在使用 Brigadier 之前，你可能需要先下载并安装 7-Zip。 译者注：7-zip 官方中文网站 记住，一定要使用最新版本的 Boot Camp 的 Windows 支持软件。6.1 之前的版本不支持 APFS 文件系统、因此无法运行。要下载最新的软件，请将最新 Mac 的型号作为参数传递给 Brigadier，如 ./brigadier.exe -m iMac19,1。之后，在不受支持的 Mac 型号上安装 Boot Camp，请以管理员身份运行 PowerShell，输入 msiexec /i BootCamp.msi 即可。如果你之前不小心已经安装了旧版本的 Boot Camp，则必须先通过运行 msiexec /x BootCamp.msi 将其卸载。BootCamp.msi 文件位于 BootCamp/Drivers/Apple 目录中、可以通过资源管理器访问。 译者注：在资源管理器下，按住 Shift 同时右击窗口中空白处，此时菜单中会显示「在此处运行 PowerShell」，即在当前目录下运行 PowerShell。但是这种方式启动的 PowerShell 不具备管理员权限。 尽管 Boot Camp 提供的 Windows 支持软件解决了大多数兼容性问题，但是有时候您还是需要手动解决一些问题： 要反转鼠标滚轮的滚动方向，必须按照 这个网站 提供的方法、设置 FlipFlopWheel 的值为 1。 译者注：涉及到的注册表是 HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Enum\\HID\\VID_???\\VID_???\\Device Parameters.你可以在 PowerShell 中执行下述命令进行设置； 如果需要撤销更改，可以使用下述命令： RealTimeIsUniversal 必须设置为 1 以避免 Windows 和 macOS 之间的时间不同步。 译者注：众所周知，Windows 将硬件时间视为本地时间，而 macOS 会计算 UTC 后当做系统时间。通过修改上述提到的注册表值，可以让 Windows 将硬件时间视为 UTC 时间。用到的 CMD 命令如下所示： 如果要访问 Apple 的文件系统（APFS、HFS），你可能需要安装单独的软件。已知的工具有 Apple HFS+ driver (hack for Windows 10)、HFSExplorer、MacDrive、Paragon APFS、Paragon HFS+、TransMac，等等。 请记住，永远不要试图从 Windows 修改 Apple 文件系统，因为这往往会导致不可恢复的数据丢失。 译者注：切记不要在 Windows 下写入 APFS 或 HFS，十有八九你会导致分区表错误和无法恢复的数据丢失。别怪我们没有警告过你！！ 3. 为什么我会在 Boot Camp 启动硬盘 控制面板 中看到 Basic data partition？Boot Camp 使用 GPT 分区表获取每个引导选项的名称。独立安装 Windows 后，你必须手动重新标记分区。这可以通过许多工具完成，比如开源的 gdisk，使用方法如下： Listing 4: 重新标记 Windows 卷宗 4. 如何选择 NTFS 驱动程序提供 NTFS 读写支持的第三方驱动程序，如 NTFS-3G、Paragon NTFS、Tuxera NTFS 或 希捷移动硬盘 Paragon 驱动程序 会破坏 macOS 的功能，比如 系统偏好设置 中的 启动磁盘 选项。虽然我们仍然不建议使用这些经常破坏文件系统的驱动程序（我们推荐使用 macOS 内建的 NTFS 读写支持，可以通过 终端 或 GUI 启用），但是这些驱动程序的厂商也提供了他们各自的解决方案，在这里我们仅列举两个： Tuxera 的常见问题解答页面 Paragon 相关的技术支持文档 译者注：虽然 acidanthera 团队推荐使用 macOS 内置的 NTFS 支持，但是译者强烈反对这种方法（不论是直接方法还是使用类似 Mounty 的第三方工具）。修改 fstab 的风险是极高的。在你清楚你在做什么之前，不要轻举妄动！！ 12.4 调试与其他硬件相关的项目类似，OpenCore 也支持审计与调试。使用 NOOPT 或 DEBUG 构建版本（而非 RELEASE 构建版本）可以产生更多的调试输出。对于 NOOPT 构建版本，你还可以使用 GDB 或 IDA Pro 进行调试。对于 GDB 请查看 OpenCore Debug 相关页面；对于 IDA Pro，你需要 7.3 或更高版本，更多详细信息请参考 IDA Pro 提供的页面：Debugging the XNU Kernel with IDA Pro。 可以使用串口调试来获取启动过程中的日志。串口调试是在 Target 中开启的，例如 0xB 代表在屏幕上显示并输出串行。可使用 SerialInit 配置选项来初始化串行。对于 macOS 来说，最好是选择基于 CP2102 的 UART 设备。将主板 TX 连接到 USB UART RX，主板 GND 连接到 USB UART GND。使用 screen 实用工具，或者下载 GUI 软件获取输出，例如： CoolTerm。 注：在一些主板（可能还有一些 USB UART 转换器）上，PIN 的命名可能是不正确的。GND 和 RX 互换是很常见的，因此你需要将主板 &quot;TX&quot; 连接到 USB UART GND，主板 &quot;GND&quot; 连接到 USB UART RX。 务必记得在固件设置中启用 COM 口，一定不要使用超过 1 米的 USB 线缆，以免输出数据损坏。如果要额外启用 XNU 内核串行输出，则需要添加 debug=0x8 启动参数。 12.5 技巧和窍门1. 啊呀呀呀我系统没法启动了我该怎么看日志啊？通常情况下，获取实际的错误信息就足够了。为此，请确保： 你正在使用 OpenCore 的 DEBUG 或 NOOPT 版本。 日志已启用（1）并且在屏幕上显示（2）：Misc → Debug → Target = 3。 将以下这些等级的日志输出到屏幕上：DEBUG_ERROR (0x80000000)、DEBUG_WARN (0x00000002) 和 DEBUG_INFO (0x00000040)：Misc → Debug → DisplayLevel = 0x80000042。 遇到 DEBUG_ERROR 这样的致命错误时中止启动：Misc → Security → HaltLevel = 0x80000000。 禁用 Watch Dog 以避免自动重启：Misc → Debug → DisableWatchDog = true。 已启用 启动菜单 显示：Misc → Boot → ShowPicker = true 如果你在日志中看不出明显的错误，请逐一检查 Quirks 部分中可用的 hacks。例如，对于 Early Boot 出现的问题（如 OpenCore 启动菜单无法显示），通过 UEFI Shell（随 OpenCore 打包在一起）可以查看相关调试信息。 2. macOS 启动失败我该怎么调试？ 在 boot-args 中添加 debug=0x100、keepsyms=1、-v 或其他类似的值。 不要忘记开启 AppleDebug 和 ApplePanic 属性。 调整 Booter、Kernel 和 UEFI 里的 Quirk。 可以考虑通过串行端口来检查早期的内核启动失败。为此你可能需要用到 debug=0x108、serial=5 和 msgbuf=1048576 启动参数。如果在串行初始化前就失败了，Sample.plist 中有相关补丁供你参考。 一定要仔细阅读日志。 3. 如何自定义启动项？OpenCore 遵循 Apple Bless 标准模型、从引导目录中的 .contentDetails 和 .disk_label.contentDetails 文件中提取条目名称。这些文件包含带有输入标题的 ASCII 字符串，你可以修改它们。 4. 如何选择默认启动的系统？OpenCore 使用 UEFI 首选启动项 来选择默认的启动项。这个选择可以在 UEFI 设置中改变，具体请参考 macOS 启动磁盘 或 Windows 启动转换 控制面板。 由于使用 OpenCore 提供的 BOOTx64.efi 作为首选启动项会限制这项功能（可能还会导致一些固件删除不兼容的引导选项），我们强烈建议你启用 RequestBootVarRouting Quirk，这会将你所做的选择保留在 OpenCore 变量空间中。请注意，RequestBootVarRouting 需要单独的 .efi 驱动文件（译者注：即 OpenRuntime.efi）。 5. 安装 macOS 最简单的方法是什么？在线安装。将 Recovery 镜像（*.dmg 和 *.chunklist 文件）和 OpenCore 一起复制到一个 FAT32 分区中。加载 OpenCore 的启动菜单并选择后缀为 .dmg 的条目。如果你有强迫症，你可以修改 .contentDetails 文件改变条目显示的文字。 你可能会用到 AppleModels 内置的 macrecovery.py 来下载 Recovery 镜像。 如果你需要进行离线安装，请参考 如何创建可引导的 macOS 安装器。除了通过 App Store 或 系统更新，你还可以使用 第三方工具 下载 macOS 镜像文件。 6. 为什么无法加载 Recovery 恢复镜像 进行在线安装？可能是因为你没带 HFS+ 驱动。目前我们所知道的 Recovery 分区全都是 HFS+ 文件系统。 7. 我可以在 Apple 的硬件、或虚拟机中使用 OpenCore 吗？可以，没有必要，但请加大力度 虚拟机和大多数相对现代的 Mac 机型，最早可以追溯到 MacPro3,1，都是完全支持的。不过，OpenCore 有关在 Mac 硬件上使用的具体细节微乎其微。你可以在 MacRumors.com 查看相关讨论。 8. 为什么 Find 和 Replace 的补丁的长度必须相等？对于 x86 机器码来说，相对寻址 无法进行大小不同的替换。对于 ACPI 代码来说这是有风险的，而且在技术上这与替换 ACPI 表等价，所以 OpenCore 没有实现。更多详细的解答可以在 AppleLife.ru 上和本文档的 ACPI 章节找到。 9. 我应该如何决定哪些 Booter Quirk 需要被启用？这些 Quirk 源自 AptioMemoryFix 驱动，为更多的固件提供了广泛支持。如果你正在使用 OpenRuntime，并且想要获得和 AptioMemoryFix 类似的行为，请启用下述 Quirk： ProvideConsoleGop （UEFI Quirk） AvoidRuntimeDefrag DiscardHibernateMap EnableSafeModeSlide EnableWriteUnprotector ForceExitBootServices ProtectMemoryRegions ProvideCustomSlide RebuildAppleMemoryMap SetupVirtualMap 但是，对于大部分现代的设备来说，上述 Quirk 不一定是必需的。比如 DevirtualiseMmio 和 ProtectUefiServices 通常是需要启用的，但是 DiscardHibernateMap 和 ForceExitBootServices 一般不建议启用。 不幸的是，对于某些 Quirk 来说（RebuildAppleMemoryMap, EnableWriteUnprotector, ProtectMemoryRegions, SetupVirtualMap 和 SyncRuntimePermissions）由于没有明确的参考，因此需要自行尝试最佳组合。详细内容请参考本文档中对这些 Quirk 的描述。"},{"title":"5. Booter","url":"/5-booter.html","content":"5.1 简介本部分允许在 Apple BootLoader（boot.efi）上应用不同种类的 UEFI 修改。目前，这些修改为不同的固件提供了各种补丁和环境更改。其中一些功能最初是作为 AptioMemoryFix.efi 的一部分，如今 AptioMemoryFix.efi 已经不再维护。如果你还在使用，请参考 技巧和窍门 章节提供的迁移步骤。 对 Booter 的修补按照如下顺序执行： Quirks Patch 如果您是第一次在自定义固件上使用此功能，则首先需要执行一系列检查。开始之前，请确保您符合以下条件： 具有最新版本的 UEFI 固件（去主板厂家的官网上看看）。 禁用了 Fast Boot 和 Hardware Fast Boot。如果 BIOS 里有相关选项，禁用掉。 如果有 Above 4G Decoding 或类似功能，请在固件设置中启用。注意，在某些主板上（特别是 ASUS WS-X299-PRO）这个选项会造成不良影响，必须禁用掉。虽然目前还不知道是不是其他主板也有同样问题，但是如果你遇到了不稳定的启动故障，可以首先考虑检查一下这个选项。 启用了 DisableIoMapper Quirk、或者在 BIOS 中禁用 VT-d、或者删去了 ACPI DMAR 表。 NVRAM 和其他地方都 没有 slide 启动参数。 除非你没法开机、并且在日志里看见了 No slide values are usable! Use custom slide!，否则不论如何也不要使用这个启动参数。 CFG Lock (MSR 0xE2 写保护) 在 BIOS 中被禁用。如果 BIOS 中没有、而且你心灵手巧，你可以考虑 手动打补丁将其禁用 。更多细节请参考 ControMsrE2（位于7.8节）。 在 BIOS 中禁用 CSM (Compatibility Support Module)。NVIDIA 6xx / AMD 2xx 或更老的平台可能需要刷新 GOP ROM，具体步骤参考 GopUpdate 或者 AMD UEFI GOP MAKER。 如果有 EHCI / XHCI Hand-off 功能，建议仅在出现 USB 设备连接时启动停滞的情况下启用。 在 BIOS 中启用 VT-x、Hyper Threading、Execute Disable Bit。 有时你还可能需要在 BIOS 中禁用 Thunderbolt Support、Intel SGX 和 Intel Platform Trust。但是这一操作不是必须的。 在调试睡眠问题时，可能需要（临时）禁用 Power Nap 和自动关闭电源，因为这二者似乎有时会导致旧的平台唤醒黑屏或循环启动。具体问题可能因人而异，但通常你应首先检查 ACPI 表。 这是在 Z68 主板 上找到的一些 Bug。要关闭 Power Nap 和其他功能，请在终端中运行以下命令： 注：这些设置可能会在硬件更改、操作系统更新和某些其他情况下重置。要查看它们的当前状态，请在终端中使用 pmset -g 命令。 5.2 属性列表1. MmioWhitelistType: plist arrayFailsafe: EmptyDescription: 设计为用 plist dict 值填充，用来描述在启用 DevirtualiseMmio 这个 Quirk 时特定固件能够运作的关键地址。详见下面的 MmioWhitelist 属性部分。 译者注：如果开机卡在 PCI... 可以尝试开启 Item 1 下的 Patch。 2. PatchType: plist arrayFailsafe: EmptyDescription: 在启动器中执行二进制补丁。 设计为用 plist dictionary 值填充，用来描述每个补丁。参加下面的 Patch 属性部分。 3. QuirksType: plist dictDescription: 应用下面的 Quirks 属性部分中所述的各个引导 Quirk。 5.3 MmioWhitelist 属性1. AddressType: plist integerFailsafe: 0Description: 指排除在外的 MMIO 地址，其内存描述符（Memory Descriptor）应被 DevirtualiseMmio 虚拟化（保持不变）。该值所在的区域会被分配一个虚拟地址，因此在操作系统运行期间，固件能够直接与该内存区域进行通信。 这里写入的地址必须是内存映射的一部分，具有 EfiMemoryMappedIO 类型和 EFI_MEMORY_RUNTIME 属性（最高 bit）。可以使用调试日志找到可能的地址。 2. CommentType: plist stringFailsafe: EmptyDescription: 用于为条目提供人类可读参考的任意 ASCII 字符串（译者注：即注释）。 3. EnabledType: plist booleanFailsafe: falseDescription: 将 MMIO 地址排除在 devirtualisation 程序之外。 5.4 Patch 属性1. ArchType: plist stringFailsafe: Any (适用于任何支持的架构)Description: 启动器补丁架构（i386, x86_64）。 2. CommentType: plist stringFailsafe: EmptyDescription: 用于为条目提供人类可读参考的任意 ASCII 字符串（译者注：即注释）。 3. CountType: plist integerFailsafe: 0 （全部修补）Description: 修补的次数，超过这一次数后便不再修补。 4. EnabledType: plist booleanFailsafe: falseDescription: 设置为 true，则应用该补丁。 5. FindType: plist dataFailsafe: EmptyDescription: 要查找的数据。如果设置，则必须与 Replace 的大小相等。 6. IdentifierType: plist stringFailsafe: Empty (匹配任何启动器)Description: Apple 代表 macOS 启动器（通常是 boot.efi）；带有后缀的名称（例如：bootmgfw.efi）代表特定的启动器。 7. LimitType: plist integerFailsafe: 0 (搜索所以引导程序)Description: 搜索的最大字节数。 8. MaskType: plist dataFailsafe: Empty (Ignored)Description: 在查找比较的过程中使用的数据位掩码。允许通过忽略未被屏蔽的 bit（设置为 0）进行模糊搜索。如果设置，则其大小必须等于 Find。 9. ReplaceType: plist dataFailsafe: EmptyDescription: 一个或多个字节的替换数据。 10. ReplaceMaskType: plist dataFailsafe: Empty (Ignored)Description: 替换时使用的数据位掩码。允许通过更新掩码（设置为非 0）来进行模糊替换。如果设置，否则其大小必须等于 Replace。 11. SkipType: plist integerFailsafe: 0 （不跳过任何发现的事件）Description: 在替换前要跳过的发现的事件数。 5.5 Quirks 属性2. AllowRelocationBlockType: plist booleanFailsafe: falseDescription: 允许通过重定位块来启动 macOS。 重定位块（Relocation Block）是一个分配在低位 4GB 内存的缓冲区。EfiBoot 使用该这部分内存加载内核和相关结构，否则这部分区块会被「非运行时」数据（假定）所占用。在内核启动之前，重定位块的内容会被复制回位于低位的保留内存。同理，所有指向重定位块的其他内存地址也会作出相应调整。在下述情况中重定位块会被使用： 没有更好的 slide（所有内存都被使用了） 强制 slide=0（通过参数或安全模式设置） 不支持 KASLR (slide)（macOS 10.7 及更旧的版本） 这个 Quirk 需要同时启用 ProvideCustomSlide（必需）和 AvoidRuntimeDefrag（通常情况下）才能正常运行。使用重定位块启动时不支持休眠（启用这个 Quirk 并不意味着总是使用重定位块，需要时才会使用重定位块。）。 注：虽然某些低层内存被占用的平台需要这个 Quirk 来运行旧版 macOS 系统，但是这个 Quirk 并不兼容某些硬件及 macOS 11。这种情况下可能需要用 EnableSafeModeSlide 来替代。 2. AvoidRuntimeDefragType: plist booleanFailsafe: falseDescription: 防止 boot.efi 运行时执行内存碎片整理。 这个选项修复了包括日期、时间、NVRAM、电源控制等 UEFI Runtime 服务。提供使用可变存储的某些服务的固件的支持，如变量存储。可变存储可能会尝试通过非可变存储区域的物理地址访问内存，但这有时可能已经被 boot.efi 移动了。这个选项可以防止 boot.efi 移动这种数据。 注：除 Apple 和 VMware 固件外，都需要启用此选项。 3. DevirtualiseMmioType: plist booleanFailsafe: falseDescription: 从某些 MMIO 区域中删除 Runtime 属性。 通过删除已知内存区域的 Runtime bit，此选项可减少内存映射中 Stolen Memory Footprint。 这个 Quirk 可能会使可用的 KASLR slide 增加，但如果没有其他措施，则不一定与目标主板兼容。 通常，这会释放 64 到 256MB 的内存（具体数值会显示在调试日志中）。在某些平台上这是引导 macOS 的唯一方法，否则在引导加载程序阶段会出现内存分配错误。 该选项通常对所有固件都有用，除了一些非常古老的固件（例如 Sandy Bridge）。在某些固件上，可能需要一个例外映射列表。为了使 NVRAM 和休眠功能正常工作，获取其虚拟地址仍然是必要的。 请参考 MmioWhitelist 部分来实现。 译者注：对于某些 300 系列主板是必须的 4. DisableSingleUserType: plist booleanFailsafe: falseDescription: 禁用 Apple 单用户模式。 这个选项可以禁用 CMD+S 热键和 -s 启动参数来限制单用户模式。启用这一 Quirk 后预期行为应和 T2 的机型行为类似。请参考 Apple 的 这篇文章（译者注：原文章已被关闭，此为网站时光机的存档副本）以了解如何在启用这一 Quirk 后继续使用单用户模式。 注：注意：当 Apple Secure Boot 被启用时，单用户模式总是被禁用的。 5. DisableVariableWriteType: plist booleanFailsafe: falseDescription: 防止 macOS 获取 NVRAM 的写入权限。 这个选项可以限制 macOS 对 NVRAM 的写入。这个 Quirk 需要 OpenRuntime.efi（原名 FwRuntimeServices.efi）提供了 OC_FIRMWARE_RUNTIME 协议的实现。 注：这个 Quirk 也可以作为一个临时性的变通办法。避免由于无法将变量写入 NVRAM 而导致的对操作系统的破坏。 译者注：在 Z390/HM370 等没有原生 macOS 支持 NVRAM 的主板上需要开启。 6. DiscardHibernateMapType: plist booleanFailsafe: falseDescription: 复用原始的休眠内存映射。 这一选项强制 XNU 内核忽略新提供的内存映射，并假定它在从休眠状态唤醒后没有改变。这种行为是 Windows 要求的。 因为 Windows 强制要求 S4 唤醒后保留运行内存的大小和位置。 注：这可能用于解决较旧较罕见的硬件上的错误内存映射。例如：Insyde 固件的 Ivy Bridge 笔记本电脑（Acer V3-571G）。除非您完全了解这一选项可能导致的后果，否则请勿使用此功能。 7. EnableSafeModeSlideType: plist booleanFailsafe: falseDescription: 修补引导加载程序以在安全模式下启用 KASLR。 这个选项与启动到安全模式（启动时按住 Shift 或使用 -x 启动参数）有关。默认情况下，安全模式会使用 slide=0，就像系统在启动时使用 slide=0 启动参数一样。这个 Quirk 会试图给 boot.efi 打上补丁，解除这一限制，并允许使用其他值(从 1 到 255)。这个 Quirks 需要启用 ProvideCustomSlide 。 注：除非启动到安全模式失败，否则不需要启用此选项。 8. EnableWriteUnprotectorType: plist booleanFailsafe: falseDescription: 关闭 CR0 寄存器中的写入保护。 这个选项在 UEFI Runtime Services 的代码页中绕过 WˆX 权限，在其执行过程中从 CR0 寄存器中移除写保护 WP bit。这个 Quirk 需要 OpenRuntime.efi 里的 OC_FIRMWARE_RUNTIME 协议来实现。 注：这个 Quirk 可能会潜在地削弱固件的安全性。如果你的固件支持内存属性表 (MAT)，请优先使用下文中的 RebuildAppleMemoryMap Quirk。是否支持 MAT，请参考 OCABC: MAT support is 1/0 日志条目来确定。 9. ForceBooterSignatureType: plist booleanFailsafe: falseDescription: 将 macOS 启动器签名设置为 OpenCore 启动器。 启动器签名，本质上是加载的镜像的 SHA-1 哈希值，在从休眠唤醒时，Mac EFI 使用该签名来验证启动器的真实性。该选项强制 macOS 使用 OpenCore 启动器的 SHA-1 哈希值作为启动器签名，以便让 OpenCore shim 在 Mac EFI 固件上进行休眠唤醒。 注：OpenCore 启动器路径由 LauncherPath 属性决定。 10. ForceExitBootServicesType: plist booleanFailsafe: falseDescription: 在失败时用新的内存映射（Memory Map）重试 ExitBootServices。 开启后会确保 ExitBootServices 即使在 MemoryMap 参数过期时也能调用成功，方法主要是获取当前的内存映射，并重试调用 ExitBootServices。 注：是否启用这个 Quirk 取决于你是否遇到了 Early Boot 故障。除非你详细了解这一选项可能导致的后果，否则请勿启用这一选项。 11. ProtectMemoryRegionsType: plist booleanFailsafe: falseDescription: 保护内存区域免于不正确的读写。 有些固件会错误映射内存区域： CSM 区域会被标记为引导服务的代码或数据，从而成为 XNU 内核的空闲内存。 MMIO 区域会被标记为预留内存，保持不被映射的状态，但在运行时可能需要在 NVRAM 的支持下才能访问。 这一 Quirk 会尝试修复这些区域的类型，比如用 ACPI NVS 标记 CSM，MMIO 标记 MMIO。 注：是否启用这一 Quirk 取决于你是否遇到了休眠、睡眠无法唤醒、启动失败或其他问题。一般来说，只有古董固件才需要启用。 12. ProtectSecureBootType: plist booleanFailsafe: falseDescription: 保护 UEFI 安全启动变量不被写入。 尝试从操作系统写入 db、dbx、PK 和 KEK 时生成报告。 注：这个 Quirk 主要试图避免碎片整理导致的 NVRAM 相关问题，例如：Insyde 或 MacPro5,1。 13. ProtectUefiServicesType: plist booleanFailsafe: falseDescription: 保护 UEFI 服务不被固件覆盖。 一些现代的固件，包括 VMware 等虚拟机上的固件，可能会在加载驱动及相关操作的过程中，更新 UEFI 服务的指针。这一行为会直接破坏其他影响内存管理的 Quirk，例如 DevirtualiseMmio、ProtectMemoryRegions 或 RebuildAppleMemoryMap。也可能会破坏其他 Quirk，具体取决于 Quirk 的作用。 GRUB-shim 对各种 UEFI image services 进行了类似的即时更改，这些服务也受到这个 Quirk 的保护。 注 1：在 VMware 上，是否需要开启这个 Quirk 取决于是否有 Your Mac OS guest might run unreliably with more than one virtual core. 这样的消息。 注 2：如果 OpenCore 是从启用了 BIOS 安全启动的 GRUB 中链式加载的，则需要这个 Quirk。 14. ProvideCustomSlideType: plist booleanFailsafe: falseDescription: 为低内存设备提供自定义 KASLR slide 值。 开启这个选项后，将会对固件进行内存映射分析，检查所有 slide（从 1 到 255）中是否有可用的。由于 boot.efi 私用 rdrand 或伪随机 rdtsc 随机生成此值，因此有可能出现冲突的 slide 值被使用并导致引导失败。如果出现潜在的冲突，这个选项将会强制为 macOS 选择一个伪随机值。这同时确保了 slide= 参数不会被传递给操作系统（出于安全原因）。 注：OpenCore 会自动检查是否需要启用这一选项。如果 OpenCore 的调试日志中出现 OCABC: Only N/256 slide values are usable! 则请启用这一选项。 15. ProvideMaxSlideType: plist integerFailsafe: 0Description: 当更大的 KASLR slide 值不可用时，手动提供最大 KASLR slide 值。 当 ProvideCustomSlide 启用时，该选项通过用户指定的 1 到 254（含）之间的值来覆盖上限为 255 的最大 slide 值。较新的固件会从上到下分配内存池中的内存，导致扫描 slide 时的空闲内存被当作内核加载时的临时内存来使用。如果这些内存不可用，启用这个选项则不会继续评估更高的 slide 值。 注：当 ProvideCustomSlide 启用、并且随机化的 slide 落入不可用的范围时，如果出现随机的启动失败，则有必要开启这个 Quirk。开启 AppleDebug 时，调试日志通常会包含 AAPL: [EB|‘LD:LKC] &#125; Err(0x9) 这样的信息。如果要找到最合适的值，请手动将 slide=X 追加到 boot-args 里，并用日志记录下不会导致启动失败的最大值。 16. RebuildAppleMemoryMapType: plist booleanFailsafe: falseDescription: 生成与 macOS 兼容的内存映射。 Apple 内核在解析 UEFI 内存映射时有几个限制： 内存映射的大小不能超过 4096 字节，因为 Apple 内核将其映射为一个 4KiB 页面。由于某些固件的内存映射大小非常大（大约超过 100 个条目），Apple 内核会在启动时崩溃。 内存属性表会被忽略。EfiRuntimeServicesCode 内存静态获得 RX 权限，其他内存类型则获得 RW 权限。某些固件驱动会在运行时把数据写到全局变量中，因此 Apple 内核在调用 UEFI Runtime Services 时会崩溃，除非驱动的 .data 部分有 EfiRuntimeServicesData 类型。为了解决这些限制，这个 Quirk 将内存属性表的权限应用到传递给 Apple 内核的内存映射中，如果生成的内存映射超过 4KiB，则可选择尝试统一类似类型的连续插槽。 注 1：由于许多固件自带的内存保护不正确，所以这个 Quirk 一般要和 SyncRuntimePermissions 一起启用。 注 2：根据是否遇到第一阶段启动失败再决定是否启用这一 Quirk。在支持内存属性表 (MAT) 的平台上，这一 Quirk 是 EnableWriteUnprotector 更好的替代。在使用 OpenDuetPkg 时一般是不需要启用这个 Quirk 的，但如果要启动 macOS 10.6 或更早的版本则可能需要启用，原因暂不明确。 17. ResizeAppleGpuBarsType: plist booleanFailsafe: -1Description: 减少 GPU PCI BAR 的大小，以便与 MacOS 兼容。 这个 Quirk 将 MacOS 的 GPU PCI BAR 大小减少到指定的值，如果不支持的话，则更低。指定的值遵循 PCI Resizable BAR 规则。虽然 MacOS 支持理论上的1GB最大值。实际上，所有非默认值可能无法正常工作。由于这个原因，这个 Quirk 的唯一支持值是最小的 BAR 大小，即 0。 使用 -1 来禁用这个 Quirk。 出于开发的目的，可以冒险尝试其他数值。考虑具有 2 个 BAR 的 GPU。 BAR0 支持从 256MB 到 8GB 的大小。它的值是 4GB。 BAR1 支持从 2MB 到 256MB 的大小。它的值是 256MB。 例 1*：将 ResizeAppleGpuBars 设置为 1GB，将 BAR0 改为 1GB，BAR1 保持不变。*例 2: 将 ResizeAppleGpuBars 设置为 1MB 将改变 BAR0 为 256MB，BAR0 为 2MB。例 3：将 ResizeAppleGpuBars 设置为 16GB，将不做任何改变。 注：请参阅 ResizeGpuBars quirk 了解 GPU PCI BAR size 配置和有关该技术的更多详细信息。 18. SetupVirtualMapType: plist booleanFailsafe: falseDescription: 将 SetVirtualAddresses 调用修复为虚拟地址。 选择让固件在调用 SetVirtualAddresses 后通过虚拟地址访问内存，可能会导致 Early Boot 故障。这个 Quirk 可通过对分配的虚拟地址和物理内存进行 Early Boot 身份映射来解决这个问题。 注：是否启用这个 Quirk 取决于你是否遇到了 Early Boot 故障。 19. SignalAppleOSType: plist booleanFailsafe: falseDescription: 不论使用什么操作系统，总是向 OS Info 报告启动的是 macOS。 Mac 设备在不同的操作系统中具有不同的行为，因此如果你在使用 Mac 设备，这一功能会非常有用。例如，你可以通过启用这一选项为某些双 GPU 的 MacBook 型号中在 Windows 和 Linux 中启用 Intel GPU。 20. SyncRuntimePermissionsType: plist booleanFailsafe: falseDescription: 更新运行时环境的内存权限。 某些固件无法正确处理运行时权限，表现为： 把 OpenRuntime 在内存映射中错误地标记为不可执行。 把 OpenRuntime 在内存属性表中错误的标记为不可执行。 在 OpenRuntime 加载之后丢失内存属性表中的条目。 把内存属性表中的项目标记为 read-write-execute。这个 Quirk 会通过更新内存映射和内存属性表来纠正这一问题。 注：是否开启这一 Quirk 取决于是否遇到 Early Boot 故障（包括但不限于在黑屏时停止以及更明显的崩溃，影响同一台机子上的其他系统）。一般来说，只有 2017 年以后发布的固件才会受到影响。"},{"title":"9. NVRAM","url":"/9-nvram.html","content":"9.1 简介设置易失性 UEFI 变量（通常被称作 NVRAM 变量）。使用 man nvram 获取详细信息。macOS 广泛使用 NVRAM 变量使 操作系统、BootLoader、固件 之间互通，因此需要提供多个 NVRAM 变量才能正常运行 macOS。 每个 NVRAM 变量均由其名称、值、属性（参考 UEFI 规范）以及 GUID 组成，表示 NVRAM 变量属于哪一区域。macOS 使用如下（包括但不限于）几种 GUID： 4D1EDE05-38C7-4A6A-9CC6-4BCCA8B38C14 (APPLE_VENDOR_VARIABLE_GUID) 7C436110-AB2A-4BBB-A880-FE41995C9F82 (APPLE_BOOT_VARIABLE_GUID) 5EDDA193-A070-416A-85EB-2A1181F45B18 (Apple Hardware Configuration Storage for MacPro7,1) 8BE4DF61-93CA-11D2-AA0D-00E098032B8C (EFI_GLOBAL_VARIABLE_GUID) 4D1FDA02-38C7-4A6A-9CC6-4BCCA8B30102 (OC_VENDOR_VARIABLE_GUID) 注：某些变量可以通过 PlatformNVRAM 或 PlatformInfo 部分的 Generic 子节添加。请确保本节中的变量不会与它们发生冲突，否则可能导致未定义的行为。 为了使 macOS 正常运行，通常需要使用 OC_FIRMWARE_RUNTIME 协议。该协议的实现目前是 OpenRuntime（原名 FwRuntimeServices.efi）驱动程序的一部分。虽然可能带来一些好处，但根据用途不同也会存在某些限制。 并非所有工具都可能知道受保护的名称空间。当使用 RequestBootVarRouting 时，在独立的命名空间中会限制对 Boot 前缀的变量访问。要访问原始变量，工具必须了解 OC_FIRMWARE_RUNTIME 协议的工作原理。 9.2 属性列表1. AddType: plist dictDescription: 从一组 GUID 映射（plist dict）中读取格式为 plist metadata 的变量映射，并将其添加到 NVRAM 中。GUID 必须以 Canonical String 格式提供，大写或小写均可（如 8BE4DF61-93CA-11D2-AA0D-00E098032B8C）。 创建的变量会设置 EFI_VARIABLE_BOOTSERVICE_ACCESS 和 EFI_VARIABLE_RUNTIME_ACCESS 的属性。变量只有在不存在且未被屏蔽的情况下才会被设置，也就是说，如果想要覆盖一个现有的变量值，请将该变量的名称添加到 Delete 部分，这种方法能够提供一个默认的值，直到操作系统接手为止。 注：如果 plist key 不符合 GUID 格式，则可能出现一些未定义的行为。 2. DeleteType: plist dictDescription: 从一组 GUID 映射（plist dict）读取一组包含 plist string 的数组（plist array），这些将会被从 NVRAM 变量中被删除。 3. LegacyOverwriteType: plist booleanFailsafe: falseDescription: 允许用 nvram.plist 文件中的变量覆盖现有 NVRAM 中的变量。 注：只有操作系统访问的到的变量会被覆盖。 4. LegacySchemaType: plist dictDescription: 允许从 GUID 映射（plist dict）中选择 NVRAM 变量设置到一个变量名称数组（plist array），格式为 plist string。 可用 * 值来接受所有用来选择 GUID 的变量。 警告选择变量要非常慎重，因为 nvram.plist 不会被存储。比如，不要把 boot-args 或 csr-active-config 放进去，因为会绕过 SIP。 5. WriteFlashType: plist booleanFailsafe: falseDescription: 允许将所有添加的变量写入闪存。 注：这个 Quirk 本应该在大多数固件上启用，但是由于可能存在 NVRAM 变量存储 garbage collection 或类似的问题的固件，所以我们将这个 Quirk 设计为可配置的。 要从 macOS 中读取 NVRAM 变量的值，可以使用 nvram，并将变量 GUID 和名称用 : 符号隔开，形如 nvram 7C436110-AB2A-4BBB-A880-FE41995C9F82:boot-args。 变量列表可参照相关文档（持续更新）：NVRAM Variables。 9.3 强制变量警告这些变量可通过 PlatformNVRAM 或 PlatformInfo 的 Generic 部分添加。推荐使用 PlatformInfo 来设置这些变量。 以下变量为 macOS 运行必需： 4D1EDE05-38C7-4A6A-9CC6-4BCCA8B38C14:FirmwareFeatures32 位 FirmwareFeatures。存在于所有 Mac 上，用来避免额外解析 SMBIOS 表。 4D1EDE05-38C7-4A6A-9CC6-4BCCA8B38C14:FirmwareFeaturesMask32 位 FirmwareFeaturesMask。存在于所有 Mac 上，用来避免额外解析 SMBIOS 表。 4D1EDE05-38C7-4A6A-9CC6-4BCCA8B38C14:MLBBoardSerialNumber。存在于较新的 Mac 上（至少 2013 年以后），用来避免额外解析 SMBIOS 表，尤其是在 boot.efi 中。 4D1EDE05-38C7-4A6A-9CC6-4BCCA8B38C14:ROM主要的网络适配器的 MAC 地址或替换值。存在于较新的 Mac（至少 2013 年以后）上，用来避免访问特殊内存区域，尤其是在 boot.efi 中。 9.4 推荐变量建议使用以下变量来加快启动速度或改善其他表现： 4D1EDE05-38C7-4A6A-9CC6-4BCCA8B38C14:BridgeOSHardwareModelBridge OS 的硬件模型变量，用于通过 EfiBoot 传播到 IODT 桥接模型。由 hw.target sysctl 读取，由 SoftwareUpdateCoreSupport 使用。 7C436110-AB2A-4BBB-A880-FE41995C9F82:csr-active-config系统完整性保护的位掩码（32-bit），声明于 XNU 源码 csr.h。 4D1EDE05-38C7-4A6A-9CC6-4BCCA8B38C14:ExtendedFirmwareFeatures结合 FirmwareFeatures 和 ExtendedFirmwareFeatures。存在于较新的 Mac 上，用来避免额外解析 SMBIOS 表。 4D1EDE05-38C7-4A6A-9CC6-4BCCA8B38C14:ExtendedFirmwareFeaturesMask结合 FirmwareFeaturesMask 和 ExtendedFirmwareFeaturesMask。存在于较新的 Mac 上，用来避免额外解析 SMBIOS 表。 4D1EDE05-38C7-4A6A-9CC6-4BCCA8B38C14:HW_BID硬件 BoardProduct（如 Mac-35C1E88140C3E6CF）。在真正的 Mac 上不存在，但可用于避免额外解析 SMBIOS 表，尤其是在 boot.efi 中。 4D1EDE05-38C7-4A6A-9CC6-4BCCA8B38C14:HW_MLB硬件 BoardSerialNumber。覆盖 MLB，存在于较新的 Mac 上（至少 2013 年以后）。 4D1EDE05-38C7-4A6A-9CC6-4BCCA8B38C14:HW_ROM硬件 ROM。覆盖 ROM，存在于较新的 Mac 上（至少 2013 年以后）。 7C436110-AB2A-4BBB-A880-FE41995C9F82:prev-lang:kbd定义默认键盘布局的 ASCII 字符串。格式为 lang-COUNTRY:keyboard，例如 ru-RU:252 代表俄语和 ABC 键盘。也接受简短形式：ru:252 或 ru:0（美国键盘，兼容 10.9）。完整的键盘列表解码来自 AppleKeyboardLayouts-L.dat，可前往这里查看。与之前或之后的 macOS 版本不同，在 10.14 上，使用非拉丁语键盘将无法启用 ABC 键盘，因此假如你需要使用 10.14 版本则不建议你使用这一变量。 7C436110-AB2A-4BBB-A880-FE41995C9F82:security-mode定义 FireWire 安全模式的 ASCII 字符串。这一变量旧版本才有，可在 IOFireWireController.cpp 中的 IOFireWireFamily 源码里找到。建议不要设置这个变量，这样可能会加快启动速度。设置为 full 等同于不设置该变量，设置为 none 将禁用 FireWire 安全性。 4D1EDE05-38C7-4A6A-9CC6-4BCCA8B38C14:UIScale定义 boot.efi 用户界面缩放比例的一字节数据。普通屏幕应为 01，HiDPI 屏幕应为 02。 7C436110-AB2A-4BBB-A880-FE41995C9F82:ForceDisplayRotationInEFI32-bit 整数，定义显示旋转。可以是 0 表示没有旋转，也可以是 90、180、270 中的任何一个表示匹配的旋转度数。 4D1EDE05-38C7-4A6A-9CC6-4BCCA8B38C14:DefaultBackgroundColor定义 boot.efi 用户界面背景色的四字节 BGRA 数据。标准色包括 BF BF BF 00（浅灰）和 00 00 00 00（西拉黑）。其他颜色可根据用户喜好设置。 9.5 其他变量以下变量对于某些特定的配置或进行故障排除可能会很有用： 7C436110-AB2A-4BBB-A880-FE41995C9F82:boot-args内核参数，用于将配置传递给 Apple 内核和驱动程序。很多参数可以通过在内核或驱动程序代码中寻找 PE_parse_boot_argn 函数找到。已知的引导参数包括： acpi_layer=0xFFFFFFFF acpi_level=0xFFFF5F — 表示 ACPI_ALL_COMPONENTS arch=i386 — 强制内核架构为 i386，详见 KernelArch 选项 batman=VALUE — AppleSmartBatteryManager 调试掩码 batman-nosmc=1 — 禁用 AppleSmartBatteryManager SMC 接口 cpus=VALUE — 最大可用 CPU 数量 debug=VALUE — Debug 掩码 io=VALUE — IOKit 调试掩码 ioaccel_debug=VALUE — IOAccelerator 调试掩码 keepsyms=1 — 显示 Panic 日志调试符号 kextlog=VALUE — Kext 调试掩码 nvram-log=1 — 启用 AppleEFINVRAM 日志 nv_disable=1 — 禁用 NVIDIA GPU 加速 nvda_drv=1 — 启用 NVIDIA web driver 的传统方法，这一参数在 macOS 10.12 中被去除 npci=0x2000 — 旧方法 禁用 kIOPCIConfiguratorPFM64 lapic_dont_panic=1 — 禁用 AP 内核的 LAPIC Panic 伪中断行为 panic_on_display_hang=1 — 显示设备挂起时触发 Panic panic_on_gpu_hang=1 — GPU 挂起时触发 Panic serial=VALUE(配置串行记录模式) — 以下是 XNU 使用的 bits。 0x01 (SERIALMODE_OUTPUT, bit 0) — 启用串行输出。 0x02 (SERIALMODE_INPUT, bit 1) — 启用串行输入。 0x04 (SERIALMODE_SYNCDRAIN, bit 2) — 启用串口同步。 0x08 (SERIALMODE_BASE_TTY, bit 3) — Load Base/恢复/VUnlock TTY。 0x10 (SERIALMODE_NO_IOLOG, bit 4) — 防止 IOLogs 写入串行。 slide=VALUE — 手动设置 KASLR 偏移值 smcdebug=VALUE — AppleSMC 调试掩码 spin_wait_for_gpu=1 — 减少 GPU 高负载情况下的超时时间 -amd_no_dgpu_accel — 替代 WhateverGreen 的 -radvesa，用于较新的 GPUs -nehalem_error_disable -no_compat_check — 禁用机型检查（适用于 10.7 以上的版本） -s — 单用户模式 -v — 啰嗦模式 -x — 安全模式 这里有一些网站收集了 macOS 内置的启动参数列表：列表 1、列表 2. 7C436110-AB2A-4BBB-A880-FE41995C9F82:bootercfgBooter 参数，类似于 boot-args，但用于 boot.efi 。接受参数为一组十六进制的 64 位值，带或不带 0x。在不同阶段，boot.efi 会请求不同的调试（日志）模式（例如，在 ExitBootServices 之后它只会打印到串行调试接口）。有些 Booter 参数会控制这些请求是否成功。下面是已知请求的列表： 0x00 – INIT 0x01 – VERBOSE （例如：-v，强制控制台记录日志） 0x02 – EXIT 0x03 – RESET:OK 0x04 – RESET:FAIL （例如未知的 board-id，休眠错配，Panic 循环，等等） 0x05 – RESET:RECOVERY 0x06 – RECOVERY 0x07 – REAN:START 0x08 – REAN:END 0x09 – DT （不再将日志记录到设备树） 0x0A – EXITBS:START （仅强制的串行调试接口） 0x0B – EXITBS:END （仅强制的串行调试接口） 0x0C – UNKNOWN 在 10.15 中，由于某种重构和 新调试协议 的引入，10.15.4 之前的调试支持基本上不能用了。下面的一些参数和值可能不适用于 10.15.4 之前的版本。以下是已知参数的列表： boot-save-log=VALUE — 正常启动时的调试日志保存模式 0 1 2 — 默认 3 4 — 保存到文件 wake-save-log=VALUE — 休眠唤醒时的调试日志保存模式 0 — 禁用 1 2 — 默认 3 — 不可用 4 — 保存到文件，不可用 breakpoint=VALUE — 调试中断相关（在产品 boot.efi 中缺少） 0 — 禁用错误时的调试中断（默认） 1 — 启用错误时的调试中断 console=VALUE — 启用控制台日志记录 0 — 禁用控制台日志记录 1 — 当缺少调试协议时，启用控制台日志记录（默认） 2 — 无条件启用控制台日志记录（不可用） embed-log-dt=VALUE — 设备树日志记录相关 0 — 禁用设备树日志记录 1 — 启用设备树日志记录 kc-read-size=VALUE — 用于网络或磁盘缓冲 I/O 的数据块大小，用于预链接内核读取和相关用途。默认设置为 1MB(0x100000)，可以通过调整使启动更快 log-level=VALUE — 日志等级位掩码 0x01 — 启用跟踪记录（默认） serial=VALUE — 串行控制台日志记录相关 0 — 禁用串行日志记录（默认） 1 — 从 EXITBS:END 开始启用串行日志记录 2 — 从 EXITBS:START 开始启用串行日志记录 3 — 当缺少调试协议时，启用串行日志记录 4 — 无条件启用串行日志记录 timestamps=VALUE — 时间戳日志记录相关 0 — 禁用时间戳记录 1 — 启用时间戳记录（默认） log=VALUE — 10.15 开始弃用 1 — AppleLoggingConOutOrErrSet/AppleLoggingConOutOrErrPrint (classical ConOut/StdErr) 2 — AppleLoggingStdErrSet/AppleLoggingStdErrPrint (StdErr or serial?) 4 — AppleLoggingFileSet/AppleLoggingFilePrint (BOOTER.LOG/BOOTER.OLD file on EFI partition) debug=VALUE — 10.15 开始弃用 1 — 启用输出到 BOOTER.LOG（如果出现了被精简过的代码，则意味着可能发生过崩溃） 2 — 启用性能日志（Perf Log），记录到 /efi/debug-log 4 — 为调用 printf 启用时间戳输出 level=VALUE — 10.15 开始弃用DEBUG 输出的详细程度。默认除 0x80000000 以外，其他内容都会被精简掉。 注：如要查看现代 macOS 版本上的 boot.efi verbose 输出，请启用 AppleDebug 选项。这样会把日志保存到通用 OpenCore 日志中。对于 10.15.4 之前的版本，将 bootercfg 设置为 log=1，可以将 verbose 输出打印在屏幕上。 7C436110-AB2A-4BBB-A880-FE41995C9F82:bootercfg-once在首次启动后删除 Booter 参数覆盖，否则等同于 bootercfg。 7C436110-AB2A-4BBB-A880-FE41995C9F82:csr-data指定将被批准的 KEXT 的来源，无论 SIP CSR_ALLOW_UNAPPROVED_KEXTS 值如何。示例如下：kext-allowed-teams{DEVELOPER-TEAM-ID}%00 7C436110-AB2A-4BBB-A880-FE41995C9F82:efiboot-perf-record启用 boot.efi 中的性能日志保存功能。性能日志会被保存到物理内存中，并通过 efiboot-perf-record-data 和 efiboot-perf-record-size 变量进行指向。从 10.15.4 开始，它也可以通过 AppleDebug 选项保存到 OpenCore 日志中。 7C436110-AB2A-4BBB-A880-FE41995C9F82:fmm-computer-name当前保存的主机名称，格式为 ASCII 字符串。 7C436110-AB2A-4BBB-A880-FE41995C9F82:nvda_drvNVIDIA Web Driver 的控制变量。用 ASCII 数字 1 来启用或用 0 来禁用已安装的驱动程序。 7C436110-AB2A-4BBB-A880-FE41995C9F82:run-efi-updater覆盖 macOS 中对 EFI 固件更新（MultiUpdater、ThorUtil）等的支持。将此值设置为 No 或其他可以转换为布尔类型的值将能够禁用 10.10 起的 macOS 固件更新。 7C436110-AB2A-4BBB-A880-FE41995C9F82:StartupMute开机时禁用固件引导提示音。8 进制整数。0x00 表示不静音、其他任何值（或缺少该值）表示静音。 7C436110-AB2A-4BBB-A880-FE41995C9F82:SystemAudioVolume用于固件音频支持的系统音频音量水平。8 位无符号整数。0x80 表示静音。其余的位用于编码原始的放大器增益设置，以应用于使用中的音频放大器。这个值的确切含义取决于编解码器（也可能取决于编解码器内的特定放大器）。该值以 MaximumBootBeepVolume AppleHDA layout 值为上限，以避免固件中的音频播放声音过大。 7C436110-AB2A-4BBB-A880-FE41995C9F82:SystemAudioVolumeDB当前的系统音频音量水平，单位是分贝（dB）。8 位有符号整数。该值表示相对于放大器参考值 0dB 的音频偏移（如果是正值，则为增益，如果是负值，则为衰减），单位为 dB。0dB 所代表的确切音量取决于编解码器（也可能取决于编解码器中的特定放大器），但它通常是在或接近最大的可用放大器音量。这个变量的典型值从大约 -60 （具体数值取决于音频硬件）到精确的 0。注意：与SystemAudioVolume不同，这个值没有上限。 5EDDA193-A070-416A-85EB-2A1181F45B18:PEXConfMacPro7,1 用户 PCI 扩展插槽配置。8 个字节的序列描述了默认的 PCI 插槽配置。每个字节指的是一个专用 PCI 插槽的配置。 插槽 1 位于 IOService:/AppleACPIPlatformExpert/PC01@0/AppleACPIPCI/BR1A@0，其路径为硬编码。此插槽不在 muxer 后面。 插槽 3 位于 IOService:/AppleACPIPlatformExpert/PC03@0/AppleACPIPCI/BR3A@0，其路径为硬编码。此插槽不在 muxer 后面。 槽位 2 和 4 到 8 是动态的，根据 AAPL,slot-name 属性与 Slot-N 值进行匹配，其中 N 是槽位编号。此插槽不在 muxer 后面。关于 MacPro7,1 插槽如何配置的更多细节，请参考支持页面。 5EDDA193-A070-416A-85EB-2A1181F45B18:SlotUtilPEXConfMacPro7,1 用户 PCI 扩展插槽配置。8 个字节的序列描述了默认的 PCI 插槽配置 "},{"title":"10. PlatformInfo","url":"/10-platform-info.html","content":"机型信息由手动生成或填充的字段组成，以便与 macOS 服务兼容。配置的基础部分可以从 AppleModels 获得，这是一个可以从 YAML 格式的数据库中生成一组接口的工具包。这些字段将会被写入三个位置： SMBIOS DataHub NVRAM 大多数字段会在 SMBIOS 中指定覆盖内容，字段的名称符合 EDK2 SmBios.h 头文件。但是，有些重要的字段会驻留在 Data Hub 和 NVRAM 中。有些值可以在多个字段 和/或 目标中找到，因此有两种方法可以控制它们的更新过程：手动指定所有值（默认方法）；半自动，仅（自动地）指定所选值用于之后的系统配置。 可以使用 dmidecode 工具来检查 SMBIOS 内容。你可以从 Acidanthera/dmidecode 下载 Acidanthera 制作的增强版。 10.1 属性列表1. AutomaticType: plist booleanFailsafe: falseDescription: 基于 Generic 属性而不是 DataHub、NVRAM 和 SMBIOS 属性生成机型信息。 考虑到 Generic 部分的数据十分灵活，启用这个选项会很有用： 当启用这个选项时，SMBIOS、DataHub 和 PlatformNVRAM 中的数据将不会被使用。 当禁用这个选项时，Generic 部分的数据将不会被使用。 警告强烈不建议把此项设置为 false。只有在需要对 SMBIOS 进行小规模修正的情况下，才有理由不使用 Automatic，否则可能会导致 debug 困难。 2. CustomMemoryType: plist booleanFailsafe: falseDescription: 使用在 Memory 部分所填写的自定义内存配置。该选项将完全取代 SMBIOS 中任何现有的内存配置，只有当 UpdateSMBIOS 设置为 true 时才生效。 3. UpdateDataHubType: plist booleanFailsafe: falseDescription: 更新 Data Hub 字段。根据 Automatic 的值，这些字段会从 Generic 或 DataHub 中读取。 注：几乎所有系统（包括 Apple 硬件）的 EFI 固件都实施了 Data Hub 协议，这意味着现有的 Data Hub 条目不能被覆盖。新条目会被添加到 Data Hub 的末尾，而 macOS 会忽略旧条目。这可以通过使用 ProtocolOverrides 部分替换 Data Hub 协议来解决。详情请参考 DataHub 协议的 override 描述。 4. UpdateNVRAMType: plist booleanFailsafe: falseDescription: 是否更新 NVRAM 中关于机型信息的相关字段。 根据 Automatic 的值，这些字段会从 Generic 或 PlatformNVRAM 中读取。所有其他字段都将在 NVRAM 部分中指定。 如果将此值设置为 false，则可以使用 nvram 部分更新上述变量；反之若将此值设置为 true，而同时 nvram 部分存在任何字段，会产生未定义行为。 5. UpdateSMBIOSType: plist booleanFailsafe: falseDescription: 更新 SMBIOS 字段。根据 Automatic 的值，这些字段会从 Generic 或 SMBIOS 中读取。 6. UpdateSMBIOSModeType: plist stringFailsafe: CreateDescription: 更新 SMBIOS 字段的方式有： TryOverwrite — 如果新的数据的大小，小于等于按页对齐的原始数据，且对解锁 legacy region 没有影响，则选择 Overwrite 方式；否则选择 Create 方式。在某些硬件上可能会有问题。 Create — 在 AllocateMaxAddress 将表替换为新分配的 EfiReservedMemoryType，没有回退机制。 Overwrite — 如果数据大小合适则覆盖现有的 gEfiSmbiosTableGuid 和 gEfiSmbiosTable3Guid，否则将以不明状态中止。 Custom — 把第一个 SMBIOS 表（gEfiSmbios(3)TableGuid）写入 gOcCustomSmbios(3)TableGuid，以此来解决固件在 ExitBootServices 覆盖 SMBIOS 内容的问题；否则等同于 Create。需要对 AppleSmbios.kext 和 AppleACPIPlatform.kext 打补丁来读取另一个 GUID: &quot;EB9D2D31&quot; - &quot;EB9D2D35&quot; (in ASCII)， 这一步由 CustomSMBIOSGuid Quirk 自动完成。 注： 使用 Custom 有一个副作用（译者注：我怎么感觉是好事）使得 SMBIOS 设置只对 macOS 生效，避免了与现有的 Windows 激活和依赖机型的 OEM 设置的相关问题。不过，苹果在 Windows 下的特定工具（译者注：如 BootCamp for Windows）可能会受到影响。 7. UseRawUuidEncodingType: plist booleanFailsafe: falseDescription: 对 SMBIOS 的 UUID 使用原始编码。 基本上每个 UUID AABBCCDD-EEFF-GGHH-IIJJ-KKLLMMNNOOPP 都是 16 字节的十六进制数字，编码方式有两种： Big Endian — 按原样书写所有字节，顺序不作任何变化（&#123;AA BB CC DD EE FF GG HH II JJ KK LL MM NN OO PP&#125;）。这种方法也被称为 RFC 4122 编码，或 Raw 编码。 Little Endian — 将字节解释为数字，并使用小字节序（Little Endian）编码格式（&#123;DD CC BB AA FF EE HH GG II JJ KK LL MM NN OO PP&#125;）。 SMBIOS 规范没有明确规定 UUID 的编码格式，直到 SMBIOS 2.6 才说明应使用 Little Endian 编码，这就导致了固件实现和系统软件的双重混乱，因为在此之前不同的厂商使用不同的编码格式。 Apple 普遍使用 Big Endian 编码格式，唯一例外的是 macOS 的 SMBIOS UUID。 dmidecode 对 SMBIOS 2.5.x 或更低的版本使用 Big Endian 编码格式。对 2.6 或更高的版本使用 Little Endian 编码格式。这三种格式 Acidanthera dmidecode 均可打印。 Windows 普遍使用 Little Endian 编码格式，但它只影响数值的观感。 OpenCore 在生成修改过的 DMI 表时，总是设置最新的 SMBIOS 版本（目前是 3.2）。如果启用了 UseRawUuidEncoding，则使用 Big Endian 编码格式来存储 SystemUUID 数据，否则使用 Little Endian 编码格式。 注：由于 DataHub 和 NVRAM 中使用的 UUID 是由 Apple 添加的，未经过标准化，所以这个选项并不会影响它们。与 SMBIOS 不同，它们总是以 Big Endian 编码格式存储。 8. GenericType: plist dictonaryDescription: 在 Automatic 模式下更新所有字段。 注：当 Automatic 为 false 时将自动忽略此部分，但不可将此部分删除。 9. DataHubType: plist dictonaryOptional: Automatic 为 true 时可不填Description: 在非 Automatic 模式下更新 Data Hub 字段。 注：当 Automatic 为 true 时将自动忽略此部分，此部分也可以删除。 10. MemoryType: plist dictionaryOptional: When CustomMemory is falseDescription: 用于设置自定义的内存配置。 注：当 CustomMemory 为 false 时将自动忽略此部分，此部分也可以删除。 11. PlatformNVRAMType: plist dictonaryOptional: Automatic 为 true 时可不填Description: 在非 Automatic 模式下更新 platform NVRAM 字段。 注：当 Automatic 为 true 时将自动忽略此部分，此部分也可以删除。 12. SMBIOSType: plist dictonaryOptional: Automatic 为 true 时可不填Description: 在非 Automatic 模式下更新 SMBIOS 字段。 注：当 Automatic 为 true 时将自动忽略此部分，此部分也可以删除。 10.2 Generic 属性1. SpoofVendorType: plist booleanFailsafe: falseDescription: 将 SMBIOS 中的 Vendor 字段设置为 Acidanthera。 由于在 SystemManufacturer 中阐述的原因，在 SMBIOS 的 Vendor 字段中使用 Apple 是危险的。但是，某些固件可能无法提供有效值，可能会导致某些软件的破坏。 2. AdviseFeaturesType: plist booleanFailsafe: falseDescription: 用支持的 bit 更新 FirmwareFeatures 向 FirmwareFeatures 中添加如下 bit： FW_FEATURE_SUPPORTS_CSM_LEGACY_MODE (0x1) - 如果没有此 bit，且 EFI 分区不是硬盘中的第一个分区，那么则无法重新启动到硬盘里的 Windows 系统。 FW_FEATURE_SUPPORTS_UEFI_WINDOWS_BOOT (0x20000000) - 如果没有此 bit，且 EFI 分区是硬盘中的第一个分区，那么则无法重新启动到硬盘里的 Windows 系统。 FW_FEATURE_SUPPORTS_APFS (0x00080000) - 如果没有此 bit，就不可能在 APFS 磁盘上安装 macOS。 FW_FEATURE_SUPPORTS_LARGE_BASESYSTEM (0x800000000) - 如果没有此 bit，就无法安装large BaseSystem 镜像的 macOS，例如：macOS 12。 注：在大多数较新的固件上，这些 bit 已经设置好，当使用新功能 “升级” 固件时，可能需要该选项。 3. MaxBIOSVersionType: plist booleanFailsafe: falseDescription: 将 BIOSVersion 设置为 9999.999.999.999.999，在使用 Automatic PlatformInfo 时推荐用于旧版的 Mac，以避免在非官方支持的 macOS 版本中进行 BIOS 更新。 4. SystemMemoryStatusType: plist stringFailsafe: AutoDescription: 用来表示内存是否可以更换和升级，此值也控制着「关于本机」中「内存」选项卡的可见性。 有效值如下： Auto — 使用原始的 PlatformFeature 值。 Upgradable — 在 PlatformFeature 中明确取消设置 PT_FEATURE_HAS_SOLDERED_SYSTEM_MEMORY (0x2)。 Soldered — 在 PlatformFeature 中明确设置的 PT_FEATURE_HAS_SOLDERED_SYSTEM_MEMORY (0x2)。 注：在某些型号的 Mac 上，SPMemoryReporter.spreporter 会自动忽略 PT_FEATURE_HAS_SOLDERED_SYSTEM_MEMORY，并认为其内存是不可升级的，如 MacBookPro10,x 和所有的 MacBookAir。 5. ProcessorTypeType: plist integerFailsafe: 0 (Automatic)Description: 请参考下文 SMBIOS 章节中的 ProcessorType。 6. SystemProductNameType: plist stringFailsafe: Empty（OEM specified or not installed）Description: 请参考下文 SMBIOS 章节中的 SystemProductName。 7. SystemSerialNumberType: plist stringFailsafe: Empty（OEM specified or not installed）Description: 请参考下文 SMBIOS 章节中的 SystemSerialNumber。 指定特殊字符串值 OEM，以从 NVRAM（SSN 变量）或 SMBIOS 中提取当前值，并在各节中使用它。贯穿各部分。这个功能只能在与 Mac 兼容的固件上使用。 8. SystemUUIDType: plist string, GUIDFailsafe: Empty（OEM specified or not installed）Description: 请参考下文 SMBIOS 章节中的 SystemUUID。 指定特殊的字符串值 OEM，从 NVRAM（system-id 变量）或 SMBIOS 中提取当前值，并在各节中使用。并在整个章节中使用它。由于不是每个固件实现都有有效的（和唯一的）值，这个功能不适用于某些设置。由于不是每个固件实现都有有效的（和唯一的）值，所以这个功能不适用于某些设置，并且可能提供意想不到的结果。我们强烈建议明确指定 UUID。请参考 UseRawUuidEncoding 来决定如何解析 SMBIOS 值。 9. MLBType: plist stringFailsafe: Empty（OEM specified or not installed）Description: 请参考下文 SMBIOS 章节中的 BoardSerialNumber。 指定特殊字符串值 OEM，以从 NVRAM（MLB 变量）或 SMBIOS 中提取当前值，并在各节中使用它。贯穿各部分。这个功能只能在与 Mac 兼容的固件上使用。 10. ROMType: plist data, 6 bytesFailsafe: Empty（OEM specified or not installed）Description: 参考 4D1EDE05-38C7-4A6A-9CC6-4BCCA8B38C14:ROM。 指定特殊字符串值 OEM，以从 NVRAM（ROM 变量）或 SMBIOS 中提取当前值，并在各节中使用它。贯穿各部分。这个功能只能在与 Mac 兼容的固件上使用。 10.3 DataHub 属性1. PlatformNameType: plist stringFailsafe: Empty（Not installed）Description: 在 gEfiMiscSubClassGuid 中设置 name。在 Mac 上找到的值为 ASCII 码形式的 platform。 2. SystemProductNameType: plist stringFailsafe: Empty（Not installed）Description: 在 gEfiMiscSubClassGuid 中设置 Model。在 Mac 上找到的值等于 Unicode 形式的 SMBIOS SystemProductName。 3. SystemSerialNumberType: plist stringFailsafe: Empty（Not installed）Description: 在 gEfiMiscSubClassGuid 中设置 SystemSerialNumber。在 Mac 上找到的值等于 Unicode 形式的 SMBIOS SystemSerialNumber。 4. SystemUUIDType: plist string，GUIDFailsafe: Empty（Not installed）Description: 在 gEfiMiscSubClassGuid 中设置 system-id。在 Mac 上找到的值等于 SMBIOS SystemUUID（字节顺序调换）。 5. BoardProductType: plist stringFailsafe: Empty（Not installed）Description: 在 gEfiMiscSubClassGuid 中设置 board-id。在 Mac 上找到的值等于 ASCII 码形式的 SMBIOS BoardProduct。 6. BoardRevisionType: plist data，1 byteFailsafe: 0Description: 在 gEfiMiscSubClassGuid 中设置 board-rev。在 Mac 上找到的值似乎与 Internal Board Revision 相对应（例如：01）。 7. StartupPowerEventsType: plist integer，64-bitFailsafe: 0Description: 在 gEfiMiscSubClassGuid Sets 中设置 StartupPowerEvents。在 Mac 上找到的值是 Power Management State 位掩码，通常为 0。 X86PlatformPlugin.kext 能读取的已知 bit 有： 0x00000001 — Shutdown cause was a PWROK event (Same as GEN_PMCON_2 bit 0) 0x00000002 — Shutdown cause was a SYS_PWROK event (Same as GEN_PMCON_2 bit 1) 0x00000004 — Shutdown cause was a THRMTRIP#event (Same as GEN_PMCON_2 bit 3) 0x00000008 — Rebooted due to a SYS_RESET# event (Same as GEN_PMCON_2 bit 4) 0x00000010 — Power Failure (Same as GEN_PMCON_3 bit 1 PWR_FLR) 0x00000020 — Loss of RTC Well Power (Same as GEN_PMCON_3 bit 2 RTC_PWR_STS) 0x00000040 — General Reset Status (Same as GEN_PMCON_3 bit 9 GEN_RST_STS) 0xffffff80 — SUS Well Power Loss (Same as GEN_PMCON_3 bit 14) 0x00010000 — Wake cause was a ME Wake event (Same as PRSTS bit 0, ME_WAKE_STS) 0x00020000 — Cold Reboot was ME Induced event (Same as PRSTS bit 1 ME_HRST_COLD_STS) 0x00040000 — Warm Reboot was ME Induced event (Same as PRSTS bit 2 ME_HRST_WARM_STS) 0x00080000 — Shutdown was ME Induced event (Same as PRSTS bit 3 ME_HOST_PWRDN) 0x00100000 — Global reset ME Wachdog Timer event (Same as PRSTS bit 6) 0x00200000 — Global reset PowerManagment Wachdog Timer event (Same as PRSTS bit 15) 8. InitialTSCType: plist integer，64-bitFailsafe: 0Description: 在 gEfiProcessorSubClassGuid 中设置 InitialTSC。设置初始 TSC 值，通常为 0。 9. FSBFrequencyType: plist integer，64-bitFailsafe: 0 (Automatic)Description: 在 gEfiProcessorSubClassGuid 中设置 FSBFrequency。 设置 CPU FSB 频率。此值等于 CPU 主频除以最高总线比率，以 Hz 为单位。请参考 MSR_NEHALEM_PLATFORM_INFO(CEh) MSR 值来确定 Intel CPU 的最高总线比率。 注：此值虽然不是用于 Skylake 或更新的平台，但也可设置。 10. ARTFrequencyType: plist integer，64-bitFailsafe: 0 (Automatic)Description: 在 gEfiProcessorSubClassGuid 中设置 ARTFrequency。 此值包含 CPU ART 频率，即晶体时钟频率。为 Skylake 或更新的平台独有，以 Hz 为单位。Client Intel segment 通常为 24 MHz，Server Intel segment 通常为 25 MHz，Intel Atom CPUs 通常为 19.2 MHz。macOS 10.15 及以下均默认为 24 MHz。 注：由于 Intel Skylake X 平台特有 EMI-reduction 电路，其 ART 频率可能会比 24 或 25 MHz 有所损失（大约 0.25%）。参考 Acidanthera Bugtracker。 11. DevicePathsSupportedType: plist integer，32-bitFailsafe: 0（Not installed）Description: 在 gEfiMiscSubClassGuid 中设置 DevicePathsSupported。必须设置为 1 才能确保 AppleACPIPlatform.kext 将 SATA 设备路径添加到 Boot#### 和 efi-boot-device-data 变量。所有新款 Mac 都设置为 1。 12. SmcRevisionType: plist data，6 bytesFailsafe: Empty（Not installed）Description: 在 gEfiMiscSubClassGuid 中设置 REV。自定义属性由 VirtualSMC 或 FakeSMC 读取，用于生成 SMC REV key。 13. SmcBranchType: plist data，8 bytesFailsafe: Empty（Not installed）Description: 在 gEfiMiscSubClassGuid 中设置 RBr。自定义属性由 VirtualSMC 或 FakeSMC 读取，用于生成 SMC RBr key。 14. SmcPlatformType: plist data，8 bytesFailsafe: Empty（Not installed）Description: 在 gEfiMiscSubClassGuid 中设置 RPlt。自定义属性由 VirtualSMC 或 FakeSMC 读取，用于生成 SMC RPlt key。 10.4 Memory 属性1. DataWidthType: plist integer，16-bitFailsafe: 0xFFFF (unknown)SMBIOS: Memory Device (Type 17) — Data WidthDescription: 指定内存的数据宽度，以位为单位。DataWidth 为 0 且 TotalWidth 为 8 时，表示改设备仅用于提供 8 个纠错位。 2. DevicesType: plist arrayFailsafe: EmptyDescription: 指定要添加的自定义内存设备。 用 plist dictionary 来描述每个内存设备，具体参见下面的 Memory Devices 属性部分。这里应该填写所有的内存插槽，包括没有插内存的插槽。 3. ErrorCorrectionType: plist integer，8-bitFailsafe: 0x03SMBIOS: Physical Memory Array (Type 16) — Memory Error CorrectionDescription: 指定内存支持的主要硬件纠错或检测方法。 0x01 — Other 0x02 — Unknown 0x03 — None 0x04 — Parity 0x05 — Single-bit ECC 0x06 — Multi-bit ECC 0x07 — CRC 4. FormFactorType: plist integer，8-bitFailsafe: 0x02SMBIOS: Memory Device (Type 17) — Form FactorDescription: 指定内存的规格。在 Mac 上通常是 DIMM 或 SODIMM。下面列举的是一些常见的规格。 当 CustomMemory 设置为 false 时，该值会根据所设置的 Mac 机型自动设置。 当 Automatic 为 true 时，如果有的话，设置相应的 Mac 模型的初始值。否则，设置 OcMacInfoLib 的值。当 Automatic 为 false 时，设置用户指定的值（如果有）。否则，设置固件的初始值。如果没有提供，将设置 Failsafe 的值。 0x01 — Other 0x02 — Unknown 0x09 — DIMM 0x0D — SODIMM 0x0F — FB-DIMM 5. MaxCapacityType: plist integer，64-bitFailsafe: 0SMBIOS: Physical Memory Array (Type 16) — Maximum CapacityDescription: 指定系统支持的最大内存量，以字节为单位。 6. TotalWidthType: plist integer，16-bitFailsafe: 0xFFFF (unknown)SMBIOS: Memory Device (Type 17) — Total WidthDescription: 指定内存的总宽度，以位为单位，包括任何检查或纠错位。如果没有纠错位，则这个值应该等于 DataWidth。 7. TypeType: plist integer，8-bitFailsafe: 0x02SMBIOS: Memory Device (Type 17) — Memory TypeDescription: 指定内存类型。常用的类型如下： 0x01 — Other 0x02 — Unknown 0x0F — SDRAM 0x12 — DDR 0x13 — DDR2 0x14 — DDR2 FB-DIMM 0x18 — DDR3 0x1A — DDR4 0x1B — LPDDR 0x1C — LPDDR2 0x1D — LPDDR3 0x1E — LPDDR4 8. TypeDetailType: plist integer，16-bitFailsafe: 0x4SMBIOS: Memory Device (Type 17) — Type DetailDescription: 指定附加的内存类型信息。 Bit 0 — Reserved，set to 0 Bit 1 — Other Bit 2 — Unknown Bit 7 — Synchronous Bit 13 — Registered (buffered) Bit 14 — Unbuffered (unregistered) 10.4.1 Memory Device 属性1. AssetTagType: plist stringFailsafe: UnknownSMBIOS: Memory Device (Type 17) — Asset TagDescription: 指定该内存的资产标签。 2. BankLocatorType: plist stringFailsafe: UnknownSMBIOS: Memory Device (Type 17) — Bank LocatorDescription: 指定内存设备所在的物理标签库。 3. DeviceLocatorType: plist stringFailsafe: UnknownSMBIOS: Memory Device (Type 17) — Device LocatorDescription: 指定内存设备所在的物理标签插槽或主板上的位置。 4. ManufacturerType: plist stringFailsafe: UnknownSMBIOS: Memory Device (Type 17) — ManufacturerDescription: 指定该内存设备的制造商。 对于空插槽，必须设置为 NO DIMM，以便 macOS 系统分析器正确显示某些 Mac 型号上的内存插槽。某些 Mac 型号（例如MacPro7,1）对内存布局提出了额外要求。 安装的内存的数量必须是以下之一：4、6、8、10、12。使用其他的值都会在系统分析器中引起错误。 内存插槽的数量必须等于 12。使用其他的值都会在系统分析器中引起错误。 内存必须安装在对应的内存插槽中，这在支持页面上有说明。SMBIOS 内存设备被映射到以下插槽：8、7、10、9、12、11、5、6、3、4、1、2。 5. PartNumberType: plist stringFailsafe: UnknownSMBIOS: Memory Device (Type 17) — Part NumberDescription: 指定该内存设备的部件号。 6. SerialNumberType: plist stringFailsafe: UnknownSMBIOS: Memory Device (Type 17) — Serial NumberDescription: 指定该内存设备的序列号。 7. SizeType: plist integer，32-bitFailsafe: 0SMBIOS: Memory Device (Type 17) — SizeDescription: 指定内存设备的大小，以兆字节为单位。0 表示该插槽未插入内存。 8. SpeedType: plist integer，16-bitFailsafe: 0SMBIOS: Memory Device (Type 17) — SpeedDescription: 指定设备的最大速度，单位为每秒百万传输量（MT/s）。0 表示未知速度。 10.5 PlatformNVRAM 属性1. BIDType: plist stringFailsafe: Empty（Not installed）Description: 指定 NVRAM 变量 4D1EDE05-38C7-4A6A-9CC6-4BCCA8B38C14:HW_BID。 2. ROMType: plist data，6 bytesFailsafe: Empty（Not installed）Description: 指定 NVRAM 变量 4D1EDE05-38C7-4A6A-9CC6-4BCCA8B38C14:HW_ROM 和 4D1EDE05-38C7-4A6A-9CC6-4BCCA8B38C14:ROM。 3. MLBType: plist stringFailsafe: Empty（Not installed）Description: 指定 NVRAM 变量 4D1EDE05-38C7-4A6A-9CC6-4BCCA8B38C14:HW_MLB 和 4D1EDE05-38C7-4A6A-9CC6-4BCCA8B38C14:MLB。 4. FirmwareFeaturesType: plist data，8 bytesFailsafe: Empty（Not installed）Description: 此变量与 FirmwareFeaturesMask 配对使用。指定 NVRAM 变量： 4D1EDE05-38C7-4A6A-9CC6-4BCCA8B38C14:FirmwareFeatures 4D1EDE05-38C7-4A6A-9CC6-4BCCA8B38C14:ExtendedFirmwareFeatures 5. FirmwareFeaturesMaskType: plist data，8 bytesFailsafe: Empty（Not installed）Description: 此变量与 FirmwareFeatures 配对使用。指定 NVRAM 变量： 4D1EDE05-38C7-4A6A-9CC6-4BCCA8B38C14:FirmwareFeaturesMask 4D1EDE05-38C7-4A6A-9CC6-4BCCA8B38C14:ExtendedFirmwareFeaturesMask 6. SystemUUIDType: plist stringFailsafe: Empty（Not installed）Description: 指定 NVRAM 变量 4D1EDE05-38C7-4A6A-9CC6-4BCCA8B38C14:system-id 的值，仅用于启动服务。在 Mac 上找到的值等于 SMBIOS SystemUUID。 10.6 SMBIOS 属性1. BIOSVendorType: plist stringFailsafe: Empty（OEM specified）SMBIOS: BIOS Information (Type 0) — VendorDescription: BIOS 供应商。SystemManufacturer 的所有规则都适用。 2. BIOSVersionType: plist stringFailsafe: Empty（OEM specified）SMBIOS: BIOS Information (Type 0) — BIOS VersionDescription: 固件版本。此值更新时会同时影响更新推送配置文件以及 macOS 版本的兼容性。在较旧的固件中看起来类似于 MM71.88Z.0234.B00.1809171422，并且在 BiosId.h 中有所描述。在较新的固件中看起来类似于 236.0.0.0.0 或 220.230.16.0.0 (iBridge: 16.16.2542.0.0,0)。 iBridge 版本是从 BridgeOSVersion 变量中读取的，并且只在具有 T2 芯片的 Mac 上有显示。 3. BIOSReleaseDateType: plist stringFailsafe: Empty（OEM specified）SMBIOS: BIOS Information (Type 0) — BIOS Release DateDescription: 固件发布日期。与 BIOSVersion 类似，看起来像是 12/08/2017 这种格式。 4. SystemManufacturerType: plist stringFailsafe: Empty（OEM specified）SMBIOS: System Information (Type 1) — ManufacturerDescription: 特定主板的 OEM 制造商。除非特别需要，否则最好不要设定，也不要包含 Apple Inc. 字样，这样做会混淆操作系统中的大量服务，例如固件更新、eficheck 以及 Acidanthera 开发的内核扩展（如 Lilu 及其插件）。此外还可能导致某些操作系统（如 Linux）无法引导。 5. SystemProductNameType: plist stringFailsafe: Empty（OEM specified）SMBIOS: System Information (Type 1) — Product NameDescription: 用于标记设备为操作系统所支持的首选 Mac 型号。在任何配置中都应指定该值，以便之后自动生成 SMBIOS 表的相关值和相关配置参数。如果 SystemProductName 与目标操作系统不兼容，可用引导参数 -no_compat_check 来作为替代。 注：如果 SystemProductName 未知，并且相关字段也未指定，则默认值会被设定为 MacPro6,1。目前已知产品的列表详见 AppleModels。 6. SystemVersionType: plist stringFailsafe: Empty（OEM specified）SMBIOS: System Information (Type 1) — VersionDescription: 产品迭代版本号。看起来类似于 1.1。 7. SystemSerialNumberType: plist stringFailsafe: Empty（OEM specified）SMBIOS: System Information (Type 1) — Serial NumberDescription: 按照格式定义的产品序列号。已知的序列号的格式在 macserial 中可以找到。 8. SystemUUIDType: plist string，GUIDFailsafe: Empty（OEM specified）SMBIOS: System Information (Type 1) — UUIDDescription: UUID 被设计为在时间和空间上都是唯一的标识符，其生成是随机与去中心化的。 9. SystemSKUNumberType: plist stringFailsafe: Empty（OEM specified）SMBIOS: System Information (Type 1) — SKU NumberDescription: Mac 主板 ID (board-id)。在旧型号的机器中看起来类似于 Mac-7BA5B2D9E42DDD94 或 Mac-F221BEC8。有时它可以留空的。 10. SystemFamilyType: plist stringFailsafe: Empty（OEM specified）SMBIOS: System Information (Type 1) — FamilyDescription: 机型名称，看起来类似于 iMac Pro。 11. BoardManufacturerType: plist stringFailsafe: Empty（OEM specified）SMBIOS: Baseboard (or Module) Information (Type 2) — ManufacturerDescription: 主板制造商。SystemManufacturer 的所有规则都适用。 12. BoardProductType: plist stringFailsafe: Empty（OEM specified）SMBIOS: Baseboard (or Module) Information (Type 2) — ProductDescription: Mac 主板 ID (board-id)。在旧型号机器中看起来类似于 Mac-7BA5B2D9E42DDD94 或 Mac-F221BEC8。 13. BoardVersionType: plist stringFailsafe: Empty（OEM specified）SMBIOS: Baseboard (or Module) Information (Type 2) — VersionDescription: 主板版本号。有各种各样，可能与 SystemProductName 或 SystemProductVersion 匹配。 14. BoardSerialNumberType: plist stringFailsafe: Empty（OEM specified）SMBIOS: Baseboard (or Module) Information (Type 2) — Serial NumberDescription: 主板序列号，有对应的格式，具体格式见 macserial 的描述。 15. BoardAssetTagType: plist stringFailsafe: Empty（OEM specified）SMBIOS: Baseboard (or Module) Information (Type 2) — Asset TagDescription: 资产标签号。有各种各样，可以是空的或填 Type2 - Board Asset Tag。 16. BoardTypeType: plist integerFailsafe: 0 Empty（OEM specified）SMBIOS: Baseboard (or Module) Information (Type 2) — Board TypeDescription: 0xA (Motherboard (includes processor, memory, and I/O)) 或 0xB (Processor/Memory Module)，详见 Table 15 — Baseboard: Board Type。 译者注：此处提及的 Table 请参见 DMTF Specifications 中的相关文档。 17. BoardLocationInChassisType: plist stringFailsafe: Empty（OEM specified）SMBIOS: Baseboard (or Module) Information (Type 2) — Location in ChassisDescription: 各种各样，可以留空或填 Part Component。 18. ChassisManufacturerType: plist stringFailsafe: Empty（OEM specified）SMBIOS: System Enclosure or Chassis (Type 3) — ManufacturerDescription: 主板制造商。SystemManufacturer 的所有规则都适用。 19. ChassisTypeType: plist integerFailsafe: 0 （OEM specified）SMBIOS: System Enclosure or Chassis (Type 3) — TypeDescription: 机箱类型，详见 Table 17 — System Enclosure or Chassis Types。 译者注：此处所提及的 Table 请参见 DMTF Specifications 中的相关文档。 20. ChassisVersionType: plist stringFailsafe: Empty（OEM specified）SMBIOS: System Enclosure or Chassis (Type 3) — VersionDescription: 应与 BoardProduct 匹配。 21. ChassisSerialNumberType: plist stringFailsafe: Empty（OEM specified）SMBIOS: System Enclosure or Chassis (Type 3) — VersionDescription: 应与 SystemSerialNumber 匹配。 22. ChassisAssetTagType: plist stringFailsafe: Empty（OEM specified）SMBIOS: System Enclosure or Chassis (Type 3) — Asset Tag NumberDescription: 机箱类型名称。有各种各样，可以留空或填 MacBook-Aluminum。 23. PlatformFeatureType: plist integer，32-bitFailsafe: 0xFFFFFFFF（在苹果硬件上指定的 OEM，否则不提供表）SMBIOS: APPLE_SMBIOS_TABLE_TYPE133 - PlatformFeatureDescription: 平台功能位掩码（较旧的 Mac 上缺失该位掩码），详情请参考 AppleFeatures.h。 24. SmcVersionType: plist data，16 bytesFailsafe: All zero（在苹果硬件上指定的 OEM，否则不提供表）SMBIOS: APPLE_SMBIOS_TABLE_TYPE134 - VersionDescription: ASCII 字符串，包含 SMC 版本号（大写）。配备 Apple T2 安全芯片的 Mac 没有这一字段。 25. FirmwareFeaturesType: plist data，8 bytesFailsafe: 0（在苹果硬件上指定的 OEM，否则不提供表，否则为 0）SMBIOS: APPLE_SMBIOS_TABLE_TYPE128 - FirmwareFeatures and ExtendedFirmwareFeaturesDescription: 64 位固件功能位掩码。详情请参考 AppleFeatures.h。低 32 位与 FirmwareFeatures 匹配，高 64 位与 ExtendedFirmwareFeatures 匹配。 26.FirmwareFeaturesMaskType: plist data，8 bytesFailsafe: 0（在苹果硬件上指定的 OEM，否则不提供表，否则为 0）SMBIOS: APPLE_SMBIOS_TABLE_TYPE128 - FirmwareFeaturesMask and ExtendedFirmwareFeaturesMaskDescription: 扩展固件功能位掩码。详情请参考 AppleFeatures.h。低 32 位与 FirmwareFeatures 匹配，高 64 位与 ExtendedFirmwareFeatures 匹配。 27. ProcessorTypeType: plist integer，16-bitFailsafe: 0 (Automatic)SMBIOS: APPLE_SMBIOS_TABLE_TYPE131 - ProcessorTypeDescription: 由处理器的主要和次要类型组成。 自动生成的值（Automatic）是根据当前的 CPU 规格提供的最准确的值，如果有问题请务必到 bugtracker 创建一个 Issue，并附上 sysctl machdep.cpu 和 dmidecode 的输出结果。所有可用值及其限制条件（该值只在核心数匹配的情况下才适用）都可以在 Apple SMBIOS 定义 头文件 里找到。"},{"title":"7. Kernel","url":"/7-kernel.html","content":"7.1 简介本章节介绍了如何在 Apple Kernel（XNU）上应用各种不同的内核空间修改，包括内核驱动程序（Kext）注入、修补以及屏蔽。 对 Kernel 和 Kext 的修补按照如下顺序执行： Block Add 和 Force Emulate 和 Quirks Patch 7.2 属性列表1. AddType: plist arrayFailsafe: EmptyDescription: 从 OC/Kexts 目录加载选定的 Kext 驱动。 设计为使用 plist dict 数据填充以描述每个驱动程序。请参阅下述 Add 属性章节。 注 1：Kext 驱动程序加载的顺序遵照数组中项目的顺序，因此如 Lilu 这种其他驱动程序的依赖驱动应该位于前面。 注 2：可以通过检查 Kext 驱动中 Info.plist 的 OSBundleLibraries 值的方法来确定其依赖驱动的加载顺序。OSBundleLibraries 中的任何依赖驱动都必须在此 Kext 之前加载。 注 3：Kext 驱动的内部可能也附带另外的 Kext (Plug-Ins)，每个内部的 Kext 也都必须单独添加，并遵循与其他 Kext 相同的全局排序规则。 2. BlockType: plist arrayFailsafe: EmptyDescription: 从 Prelinked Kernel 中移除选定的 Kext。 设计为使用 plist dict 数据填充以描述每个驱动程序。请参阅下述 Block 属性章节。 3. EmulateType: plist dictDescription: 在内核空间中仿真选定的硬件。请参考下文 Emulate 属性。 4. ForceType: plist arrayFailsafe: EmptyDescription: 如果内核驱动没有被缓存，则从系统卷宗强制加载内核驱动。 设计为使用 plist dict 值来填充，用于描述驱动程序。参见下面的 Force 属性部分。依赖其他驱动的驱动程序不能被缓存，该部分着重解决了这种驱动程序注入的难点。这个问题会映像到旧的操作系统，在旧的操作系统中存在各种依赖性的 Kext，比如 IOAudioFamily 和 IONetworkingFamily，可能默认不存在于内核缓存中。 注 1：加载的顺序是 Kexts 在 array 中出现的顺序。因此，依赖关系必须出现在依赖它们的 Kexts 之前。 注 2：Force 发生在 Add 之前。 注 3：”forced” 的 Kexts 的签名没有经过任何检查。这使得使用这个功能非常危险并且不适合安全启动。 注 4：在较新的操作系统中，这个功能可能在加密的分区上不起作用。 5. PatchType: plist arrayFailsafe: EmptyDescription: 在添加和删除驱动程序步骤之前执行的对现有 Kext 驱动程序的二进制修补。 设计为使用 plist dictionary 数据填充以描述每个驱动程序。请参阅下述 Patch 属性部分。 6. QuirksType: plist dictDescription: 应用下面的 Quirks 属性章节中描述的各个内核和驱动程序 Quirk。 7. SchemeType: plist dictDescription: 通过参数来定义内核空间的操作模式，具体参数见下面 Scheme 属性部分的描述。 7.3 Add 属性1. ArchType: plist stringFailsafe: Any (适用于任何支持的架构)Description: Kext 架构（i386, x86_64）。 2. BundlePathType: plist stringFailsafe: EmptyDescription: Kext 相对于 EFI/OC/kexts/Other/ 的路径，如 Lilu.kext 或 MyKext.kext/Contents/PlugIns/MySubKext.kext。 译者注：如 VoodooPS2Controller.kext 这种包括其他 Kext 驱动的，需要分别单独添加，如 VoodooPS2Controller.kext/Contents/PlugIns/VoodooPS2Keyboard.kext。 3. CommentType: plist stringFailsafe: EmptyDescription: 用于为条目提供人类可读参考的任意 ASCII 字符串（译者注：即注释）。 4. EnabledType: plist booleanFailsafe: falseDescription: 设置为 true 以加载该驱动。 5. ExecutablePathType: plist stringFailsafe: EmptyDescription: Kext 中实际可执行文件的路径（例如 Lilu.kext 中的可执行文件路径是 Contents/MacOS/Lilu）。 译者注：空壳 Kext 没有可执行文件（例如：USBPorts.kext），此项留空即可。 6. MaxKernelType: plist stringFailsafe: Empty stringDescription: 在小于等于指定的 macOS 版本或更高版本中添加该 Kext 驱动程序。 你可以使用 uname -r 指令获取当前内核版本，一般为三个整数、中间由半角局点分隔，如 18.7.0 代表的是 10.14.6。OpenCore 对内核版本解释的实现方式如下图所示： 内核版本比较的实现如下图所示： 将 Darwin 内核版本号字符串从左到右以 . 符号作为分隔符分割成三个整数，即为 ParseDarwinVersion 的三个参数。FindDarwinVersion 函数将会通过在内核镜像中查找形如 的字符串来定位 Darwin 内核版本号。 7. MinKernelType: plist stringFailsafe: Empty stringDescription: 在大于等于指定的 macOS 版本中添加该 Kext 驱动程序。 注：匹配逻辑请参阅 Add MaxKernel 的描述。 译者注：以上两个属性定义了这个驱动将在什么版本范围的 macOS 中加载。留空表示在所有的 macOS 版本下都加载。 8. PlistPathType: plist stringFailsafe: EmptyDescription: Kext 中 Info.plist 文件的路径。例如：Contents/Info.plist。 7.4 Block 属性1. ArchType: plist stringFailsafe: Any (适用于任何支持的架构)Description: Kext block 架构（i386，x86_64）。 2. CommentType: plist stringFailsafe: EmptyDescription: 用于为条目提供人类可读参考的任意 ASCII 字符串（译者注：即注释）。 3. EnabledType: plist booleanFailsafe: falseDescription: 除非设置为 true，否则这个内核驱动不会被加载。 4. IdentifierType: plist stringFailsafe: EmptyDescription: Kext Bundle 标识符（例如：com.apple.driver.AppleTyMCEDriver）。 5. MaxKernelType: plist stringFailsafe: EmptyDescription: 在小于等于指定的 macOS 版本中阻止 Kext 驱动程序。 注：匹配逻辑请参阅 Add MaxKernel 的描述。 6. MinKernelType: plist stringFailsafe: Empty stringDescription: 在大于等于指定的 macOS 版本中阻止 Kext 驱动程序。 7. StrategyType: plist stringFailsafe: Disable（强行让内核驱动 kmod 的启动代码返回失败）。Description: 阻止内核驱动加载。 有效值： Disable - 强行让内核驱动的 kmod 启动代码返回失败。 Exclude - 通过删除 plist entry 并填入 0，从内核缓存中删除内核驱动。 注 1：排除作为其他依赖项的 Kext 是有风险的。 注 2：目前排除仅适用于预链接内核和更新的机制。 注 3：在大多数情况下，删除内核驱动之后需要注入新的 Kext 作为替代品。 7.5 Emulate 属性1. Cpuid1DataType: plist data, 16 bytesFailsafe: All zeroDescription: EAX、EBX、ECX、EDX 值的序列，用来取代 XNU 内核中的 CPUID (1) 调用。 该属性主要应用于以下三种需求： 对不支持的 CPU 型号启用支持（比如英特尔的奔腾处理器）。 对特定 macOS 版本（通常是旧版）不支持的 CPU 型号启用支持。 对不支持的 CPU Variant 启用 XCPM 支持。 注 1：还有一种可能的情况，即 CPU 型号是支持的，但其电源管理不支持（比如虚拟机）。在这种情况下，可以通过设置 MinKernel 和 MaxKernel 来限制特定 macOS 内核版本的 CPU 虚拟化和虚拟电源管理补丁。 注 2：通常来讲只需要处理 EAX 的值，因为它代表完整的 CPUID。剩余的字节要留为 0。字节顺序是小端字节序（Little Endian），比如 C3 06 03 00 代表 CPUID 0x0306C3 (Haswell)。 注 3：推荐使用下面的组合启用 XCPM 支持。请注意，需要设置与所安装的 CPU 相匹配的正确频率向量。： Haswell-E (0x0306F2) to Haswell (0x0306C3):Cpuid1Data: C3 06 03 00 00 00 00 00 00 00 00 00 00 00 00 00Cpuid1Mask: FF FF FF FF 00 00 00 00 00 00 00 00 00 00 00 00 Broadwell-E (0x0406F1) to Broadwell (0x0306D4):Cpuid1Data: D4 06 03 00 00 00 00 00 00 00 00 00 00 00 00 00Cpuid1Mask: FF FF FF FF 00 00 00 00 00 00 00 00 00 00 00 00 Comet Lake U62 (0x0A0660) to Comet Lake U42 (0x0806EC):Cpuid1Data: EC 06 08 00 00 00 00 00 00 00 00 00 00 00 00 00Cpuid1Mask: FF FF FF FF 00 00 00 00 00 00 00 00 00 00 00 00 Rocket Lake (0x0A0670) to Comet Lake (0x0A0655):Cpuid1Data: 55 06 0A 00 00 00 00 00 00 00 00 00 00 00 00 00Cpuid1Mask: FF FF FF FF 00 00 00 00 00 00 00 00 00 00 00 00 Alder Lake (0x090672) to Comet Lake (0x0A0655):Cpuid1Data: 55 06 0A 00 00 00 00 00 00 00 00 00 00 00 00 00Cpuid1Mask: FF FF FF FF 00 00 00 00 00 00 00 00 00 00 00 00 注 4：请记住，目前以下配置不被 XCPM 兼容（至少还没有人成功过）： 消费级的 Ivy Bridge（0x0306A9），因为苹果针对它禁用了 XCPM 并推荐用户使用传统的电源管理。如果要使用这一选项，你还需要手动添加 _xcpm_patch 二进制修补以强制启用 XCPM。 低端处理器（如基于 Haswell 或奔腾），因为它们不被 macOS 支持。如果要启用这些 CPU 请参阅 acidanthera/bugtracker#365 中的 Special NOTES 相关内容。 2. Cpuid1MaskType: plist data, 16 bytesFailsafe: All zeroDescription: Cpuid1Data 中激活的 bit 的位掩码。 当每个 Cpuid1Mask bit 都设置为 0 时将使用原始的 CPU bit，否则取 Cpuid1Data 的值。 3. DummyPowerManagementType: plist booleanFailsafe: falseRequirement: 10.4-12Description: 禁用 AppleIntelCpuPowerManagement。 注 1：这一选项旨在替代 NullCpuPowerManagement.kext，用于 macOS 中没有相应电源管理驱动程序的 CPU。 注 2：虽然通常只有不支持的平台才需要启用这个选项来禁用 AppleIntelCpuPowerManagement，但是如果想要禁用这个 Kext 本身而不考虑其他情况（比如 Cpuid1Data 留空），也依然可以启用这个选项。 4. MaxKernelType: plist stringFailsafe: Empty stringDescription: 模拟 CPUID，并在小于等于指定的 macOS 版本上使用 DummyPowerManagement。 注：匹配逻辑请参阅 Add MaxKernel 的描述。 5. MinKernelType: plist stringFailsafe: Empty stringDescription: 模拟 CPUID，并在大于等于指定的 macOS 版本上使用 DummyPowerManagement。 注：匹配逻辑请参阅 Add MaxKernel 的描述。 7.6 Force 属性1. ArchType: plist stringFailsafe: Any （适用于任何受支持的架构）Description: Kext 架构（i386，x86_64）。 2. BundlePathType: plist stringFailsafe: EmptyDescription: Kext 路径，例如：System/Library/Extensions/IONetworkingFamily.kext。 3. CommentType: plist stringFailsafe: EmptyDescription: 用于为条目提供人类可读参考的任意 ASCII 字符串（译者注：即注释）。 4. EnabledType: plist booleanFailsafe: falseDescription: 设置为 true 则在内核缓存中不存在时从系统卷加载此 kext 驱动程序。 5. ExecutablePathType: plist stringFailsafe: EmptyDescription: Kext 中实际可执行文件的路径，例如：Contents/MacOS/IONetworkingFamily。 6. IdentifierType: plist stringFailsafe: EmptyDescription: Kext 标识符，以便在添加前检查是否存在，例如：com.apple.iokit.IONetworkingFamily。只有在缓存中找不到标识符的驱动程序才会被添加。 7. MaxKernelType: plist stringFailsafe: EmptyDescription: 在小于等于指定的 macOS 版本中添加 Kext 驱动程序。 注：匹配逻辑请参阅 Add MaxKernel 的描述。 8. MinKernelType: plist stringFailsafe: EmptyDescription: 在大于等于指定的 macOS 版本中添加 Kext 驱动程序。 注：匹配逻辑请参阅 Add MaxKernel 的描述。 9. PlistPathType: plist stringFailsafe: EmptyDescription: Kext 中 Info.plist 文件的路径。一般为 Contents/Info.plist。 7.7 Patch 属性1. ArchType: plist stringFailsafe: Any （适用于任何受支持的架构）Description: Kext patch 架构（i386，x86_64）。 2. BaseType: plist stringFailsafe: Empty (Ignored)Description: 通过获取所提供的 Symbol 名称的地址，来选择 Symbol 匹配的 Base 进行补丁查找（或直接替换）。 3. CommentType: plist stringFailsafe: EmptyDescription: 用于为条目提供人类可读参考的任意 ASCII 字符串（译者注：即注释）。 4. CountType: plist integerFailsafe: 0Description: 修补的次数，超过这一次数后便不再修补。0 表示修补所有查找到的地方。 5. EnabledType: plist booleanFailsafe: falseDescription: 除非设置为 true，否则不会使用此内核补丁。 6. FindType: plist dataFailsafe: Empty (Immediate replacement at base)Description: 需要查找的数据。如果设置，则其大小必须等于 Replace。 7. IdentifierType: plist stringFailsafe: EmptyDescription: Kext Bundle 标识符（如 com.apple.driver.AppleHDA）或内核补丁的 kernel。 8. LimitType: plist integerFailsafe: 0 （搜索整个 Kext 或内核）Description: 搜索的最大字节数。 9. MaskType: plist dataFailsafe: Empty (Ignored)Description: 在查找比较的过程中使用数据位掩码。允许通过忽略未被屏蔽的 bit（设置为 0）进行模糊搜索。如果设置，则其大小必须等于 Replace。 10. MaxKernelType: plist stringFailsafe: Empty stringDescription: 在小于指定的或更早的 macOS 版本上打补丁。 注：匹配逻辑请参阅 Add MaxKernel 的描述。 11. MinKernelType: plist stringFailsafe: Empty stringDescription: 在大于等于指定的 macOS 版本上打补丁。 注：匹配逻辑请参阅 Add MaxKernel 的描述。 12. ReplaceType: plist dataFailsafe: Empty dataDescription: 一个或多个字节的替换数据。 13. ReplaceMaskType: plist dataFailsafe: Empty dataDescription: 替换时使用的数据位掩码。允许通过更新掩码（设置为非 0）来进行模糊替换。若留空则代表忽略，否则其大小必须等于 Replace。 14. SkipType: plist integerFailsafe: 0 （不跳过任何事件）Description: 在替换前要跳过的发现事件数。 7.8 Quirks 属性1. AppleCpuPmCfgLockType: plist booleanFailsafe: falseRequirement: 10.4Description: 禁用 AppleIntelCPUPowerManagement.kext 中的 PKG_CST_CONFIG_CONTROL (0xE2) 修改，从而避免早期 Kernel Panic。 注：AppleIntelCPUPowerManagement.kext 自 macOS 13 起，已被删除。但是，可以注入旧版本 AppleIntelCPUPowerManagement.kext 并使用此 quirk 进行修补。 某些固件会锁定 PKG_CST_CONFIG_CONTROL MSR 寄存器。可以使用附带的 ControlMsrE2 工具检查其状态。请注意，某些类型的固件仅将此寄存器锁定在某些内核上。由于现代固件已经提供了 CFG Lock 相关设置、从而可以配置 PKG_CST_CONFIG_CONTROL 寄存器锁定，此选项应该尽可能避免。 对于一些不显示 CFG Lock 配置的固件，可以按照下述配置进行修改： 下载 UEFITool 和 IFR-Extractor 使用 UEFITool 中打开固件镜像文件，找到 CFG Lock 的 Unicode 字符串。如果你没有找到，意味着你的固件可能不支持 CFG Lock 解锁，那么你现在可以停下来了。 从 UEFITool 菜单中的 Extract Body 选项提取 Setup.bin 中的 PE32 镜像部分。 对提取出来的文件执行 IFR-Extractor（./ifrextract Setup.bin Setup.txt）。 从 Setup.txt 中找到 CFG Lock, VarStoreInfo (VarOffset/VarName):，记住紧随其后的偏移量值（例如 0x123）。 下载并执行由 brainsucker 编译的 修改版 GRUB Shell。你也可以使用 datasone 制作的 新版 GRUB Shell。 在 GRUB Shell 中，使用 setup_var 0x123 0x00（其中 0x123 应该被替换为你在前几步找到的偏移值），然后重启电脑。 警告可变偏移量对于每个主板乃至每一个固件版本都是唯一的。永远不要尝试使用别人的偏移量！ 在选定的平台上，ControlMsrE2 工具也可以改变这种隐藏的选项。传递所需的参数：lock, unlock for CFG Lock。或者通过控制台来查找和修改其他隐藏选项。 作为最后的手段，考虑修补 BIOS（仅适用于高级用户）。 2. AppleXcpmCfgLockType: plist booleanFailsafe: falseRequirement: 10.8 (not required for older)Description: 禁用 XNU 内核对 PKG_CST_CONFIG_CONTROL (0xE2) 修改，从而避免早期 Kernel Panic(XCPM power management)。 注：这一选项应该避免被使用，请参考上文中关于 AppleCpuPmCfgLock 的介绍。 3. AppleXcpmExtraMsrsType: plist booleanFailsafe: falseRequirement: 10.8 (not required for older)Description: 对于没有 XCMP 支持的设备，禁用对选定 CPU 的多 MSR 访问。 通常将其与 Haswell-E，Broadwell-E，Skylake-SP 和类似 CPU 的 Emulate 结合使用。更多关于 XCPM 修补的信息可以在 acidanthera/bugtracker#365 找到。 注：Ivy Bridge 或 Pentium CPU 将需要其他未提供的补丁。建议对前者使用 AppleIntelCpuPowerManagement.kext。 4. AppleXcpmForceBoostType: plist booleanFailsafe: falseRequirement: 10.8 (not required for older)Description: 在 XCPM 模式下强制使用最大性能。 该补丁将 0xFF00 写入 MSR_IA32_PERF_CONTROL (0x199)，有效地做到了一直保持最大倍数。 注：尽管有助于提高性能，但是在所有操作系统上都强烈建议不要启用这一选项，但明确专用于科学或媒体计算的系统除外。只有在某些 Xeon 型号的 CPU 才有可能从这个选项中受益。 5. CustomPciSerialDeviceType: plist booleanFailsafe: falseRequirement: 10.7Description: 在一个定制的 PCI 串行设备上修改 PMIO 寄存器的基本地址。 该补丁改变了 XNU 内核用于串行输入和输出的 PMIO 寄存器基址，从默认的内置COM1串行端口 0x3F8，改为存储在指定 PCI 设备的第一个 IO BAR 中的基址，或者是一个特定的基址（例如 0x2F8 用于 COM2）。 注 1：默认情况下，串行日志是禁用的。 启动参数 serial=3，启用串行输入和输出，使 XNU 将日志打印到串行端口。 注 2：除此修补程序外，应防止 kext Apple16X50PCI0 连接，以使 kprintf 方法正常工作。这可以通过使用 PCIeSerialDisable 实现。此外，对于某些雷电卡，IOKit personality IOPCITunnelCompatible 也需要设置为 true，这可以由 Acidantarea/bugtracker#2003 上附带的 PCIeSerialThunderboltEnable.kext 完成。 注 3：要正确应用这个补丁，必须启用 Override，并在 Custom 中正确设置所有的选项。在 Misc-&gt;Serial 部分。 注 4：这个补丁是为了支持 PMIO，因此如果 Misc-&gt;Serial-&gt;Custom 部分的 UseMmio 为 false，则不适用。对于 MMIO，有启动参数 pcie_mmio_uart=ADDRESS 和 mmio_uart=ADDRESS，允许内核使用 MMIO 来访问串行端口。 注 5：串行波特率必须在 Misc-&gt;Serial-&gt;Custom 部分的 BaudRate 和通过启动参数 serialbaud=VALUE 正确设置。这两个参数应该相互匹配。默认的波特率是 115200。 6. CustomSMBIOSGuidType: plist booleanFailsafe: falseRequirement: 10.4Description: 对 UpdateSMBIOSMode 自定义模式执行 GUID 修补，通常用于戴尔笔记本电脑。 7. DisableIoMapperType: plist booleanFailsafe: falseRequirement: 10.8 (not required for older)Description: 禁用 XNU (VT-d) 中的 IOMapper 支持，这可能与固件的实现相冲突。 注 1：该选项是直接在 ACPI 表中删除 DMAR 和在固件首选项中禁用 VT-d 的首选替代方案。不会妨碍其他操作系统中的 VT-d 支持。 注 2：固件中错误配置的 IOMMU 可能导致设备损坏，如以太网或 Wi-Fi 适配器。例如，以太网适配器可能会无限在连接-断开中循环，Wi-Fi 适配器可能无法发现网络。技嘉是出现这些问题的最常见的 OEM 厂商之一。 8. DisableIoMapperMappingType: plist booleanFailsafe: falseRequirement: 13.3(not required for older)Description: 在 IOMMU(VT-d) 中禁止映射 PCI 桥接设备内存。 这个选项解决了在原生 DMAR 表包含一个或多个保留内存区域且安装了超过 16 GB 内存的系统上启用 AppleVTD 时与 Wi-Fi、以太网和 Thunderbolt 设备的兼容性问题。在某些系统上，只有在启用 iGPU 时才需要这个 Quirk。 注 1：在 AMD 系统上不需要这个选项。 9. DisableLinkeditJettisonType: plist booleanFailsafe: falseRequirement: 11Description: 禁止丢弃 __LINKEDIT。 这个选项能让 Lilu.kext 和其他一些可能的 kext 在 macOS Big Sur 中以最佳性能运行，而不需要 keepsyms=1 启动参数。 9. DisableRtcChecksumType: plist booleanFailsafe: falseRequirement: 10.4Description: 禁用 AppleRTC 初始校验和（0x58-0x59）写入。 注 1：这个选项不能确保其他区域不被覆盖，如有需要，请使用 RTCMemoryFixup。 注 2：这个选项不能确保区域在固件阶段不被覆盖（例如 macOS bootloader）。如有需要，请参阅 AppleRtcRam 协议描述。 10. ExtendBTFeatureFlagsType: plist booleanFailsafe: falseRequirement: 10.8-11Description: 将 FeatureFlags 设置为 0x0F，以实现蓝牙的全部功能（包括连续互通功能）。 注：此选项是 BT4LEContinuityFixup.kext 的替代品。由于补丁进度较晚，无法正常工作。 11. ExternalDiskIconsType: plist booleanFailsafe: falseRequirement: 10.4Description: 修补 AppleAHCIPort.kext 图标，使 macOS 将所有 AHCI 存储设备显示为内部硬盘。 注：这一选项应尽量避免使用。现代固件通常情况下都是兼容的。 12. ForceAquantiaEthernetType: plist booleanFailsafe: falseRequirement: 10.15.4Description: 启用基于 Aquantia AQtion 的 10GbE 网卡支持。 这个选项可以使基于 Aquantia AQtion 的 10GbE 网卡得到支持，在macOS 10.15.4之前，这些网卡是原生支持的。 注 1：为了使 Aquantia 卡正常工作，必须禁用 DisableIoMapper，不得丢弃 DMAR ACPI 表，并且必须在 BIOS 中启用 VT-d。 注 2：虽然此补丁应支持所有 Aquantia AQtion 系列的以太网卡，但它仅在基于 AQC-107s 的 10GbE 网卡上进行了测试。 注 3：为了解决 AppleVTD 在应用这个 Quirk 后的不兼容问题，DMAR ACPI表中相应设备的保留内存区域部分可能被删除。这个表应该被拆解和编辑，然后用 iASL 工具重新编译成 AML。为了添加修补后的 DMAR 表，应该删除原来的表。更多细节可以在 commit 2441455 中找到。 13. ForceSecureBootSchemeType: plist booleanFailsafe: falseRequirement: 11Description: 强制采用 x86 方案进行 IMG4 核查。 注：在虚拟机上使用 x86legacy 以外的 SecureBootModel 时需要开启此选项。 14. IncreasePciBarSizeType: plist booleanFailsafe: falseRequirement: 10.10Description: 允许 IOPCIFamily 用 2GB PCI BAR 启动 通常情况下，macOS 将 PCI BAR 限制为 1GB。启用这个选项（仍然）并不能让 macOS 实际使用具有更大 PCI BAR 的设备。 注：你应该尽可能避免使用这一选项。通常这一选项只需要在配置错误或损坏的固件上开启。 译者注：如果你的 BIOS 中存在 Above4GDecoding 选项，请直接在 BIOS 中启用。 15. LapicKernelPanicType: plist booleanFailsafe: falseRequirement: 10.6 (64-bit)Description: 禁用 LAPIC 中断导致的 Kernal Panic。 译者注：惠普电脑可能需要启用这一选项。 16. LegacyCommpageType: plist booleanFailsafe: falseRequirement: 10.4 - 10.6Description: 默认的 64 位 commpage bcopy 的实现需要 SSSE3，这个选项把它替换为「不需要 SSSE3」的实现，这对于不支持 SSSE3 的旧平台很有必要，防止因不存在「不需要 SSSE3 的 64 位 bcopy 函数」而导致的 commpage no match for last Panic。 17. PanicNoKextDumpType: plist booleanFailsafe: falseRequirement: 10.13 (not required for older)Description: 在发生内核崩溃时阻止输出 Kext 列表，提供可供排错参考的崩溃日志。该 Quirk 在 10.13 及以上起作用。 18. PowerTimeoutKernelPanicType: plist booleanFailsafe: falseRequirement: 10.15 (not required for older)Description: 修复 macOS Catalina 中由于设备电源状态变化超时而导致的内核崩溃。 macOS Catalina 新增了一项额外的安全措施，导致在电源切换超时的时候会出现 Kernel Panic。配置错误的硬件可能会因此出现问题，特别是数字音频、有的时候会导致睡眠唤醒的问题。这一 Quirk 和引导参数 setpowerstate_panic=0 功能大部分一致，但是后者只应该用于调试用途。 19. ProvideCurrentCpuInfoType: plist booleanFailsafe: falseRequirement: 10.4 (10.14)Description: 向内核提供当前的 CPU 信息。 这个 Quirk 的工作方式因 CPU 不同而不同： 对于微软的 Hyper-V，它向内核提供正确的 TSC 和 FSB 值，以及禁用 CPU 拓扑验证（10.8以上）。 对于 KVM 和其他管理程序，它提供预计算的 MSR 35h 值，解决内核在 -cpu host 下的 kernel panic。 对于英特尔 CPU 来说，它通过将核心数与线程数打补丁的方式，增加了对非对称 SMP 系统（例如：Intel Alder Lake）的支持，同时还补充了所需的补充修改（10.14以上）。当使用 10.4 时，还提供了缓存大小和缓存行大小的值，因为 Intel Penryn 和更新的产品可能只有 CPUID leaf 0x4 中的缓存信息，而 10.4 是不支持的。 20. SetApfsTrimTimeoutType: plist integerFailsafe: -1Requirement: 10.14 (not required for older)Description: 为 SSD 上的 APFS 文件系统设置微秒级的 trim 超时时间。 APFS 文件系统的设计方式是，空间由 Spaceman (The Space Manager) 结构控制，要么为已使用，要么为空闲。而其他文件系统，则可以被标记为 已使用、空闲 或 未映射。macOS 启动时，所有空闲的空间都会被 trim 处理。由于 DSM 命令的特性，每个命令最多拥有 256 个范围，因此 NVMe 驱动器的 trim 过程发生在 LBA 范围内。硬盘上存储的内容越分散，就需要越多的命令对所有空闲空间进行 trim。 Trim 过程耗时取决于 SSD 控制器和硬盘碎片，可能需要相当长的时间，导致启动时间肉眼可见地变长，APFS 驱动程序忽略之前未映射的区域，并在启动时一次又一次地对这些区域进行 trim。为了解决开机速度慢的问题，macOS 驱动引入了一个超时时间（9.999999 秒）来中止未能及时完成的 trim 操作。在一些控制器上（如三星）解除分配的过程较慢，很容易达到超时时间。从本质上讲，这意味着碎片级别很高，macOS 会尝试 trim 之前已经解除分配的低位区块，但永远没有足够的时间去解除分配高位区块。这意味着这些 SSD 安装后不久，trim 指令就会不起作用，导致闪存的额外损耗，甚至损坏。 解决这个问题的方法之一是将超时时间设置为一个非常高的值（例如：4294967295），这样将会以较长的启动时间（数分钟）为代价来确保所有的区块都被 trim 处理。另一种方法是利用超额配置（如果支持），或者创建一个专用的未映射分区，控制器可以在该分区中找到保留块。在这种情况下，可以设置一个非常低的超时时间来禁止 trim 操作，例如：999。更多细节详见 这篇文章。 注 1：Failsafe -1 表示不应用此补丁，这样 apfs.ext 将保持不动。 注 2：在 macOS 12.0 及以上版本中，不再可能指定 trim 超时时间。但可以通过设置为 0 来禁用 trim。 注 3：trim 操作只在启动阶段受到影响，当启动卷被加载时。无论是指定超时时间，或者设置为 0 完全禁用 trim，都不会影响正常的 MacOS 运行。 译者注：设置为 0 完全禁用 trim 只影响进入系统的启动阶段，对系统启动之后无影响。设置为 0 或 999 基本上没有差别，主要是 macOS 12.0 及以上版本，只有设置为 0 才能禁用 trim。 21. ThirdPartyDrivesType: plist booleanFailsafe: falseRequirement: 10.6 (not required for older)Description: 修补 IOAHCIDeleteStorage.kext，为第三方驱动器启用 TRIM、硬盘休眠等功能。 注：NVMe SSD 通常无需这一修改。对于 AHCI SSD（如 SATA SSD），macOS 从 10.15 开始提供 trimforce，可以将 01 00 00 00 值写入 APPLE_BOOT_VARIABLE_GUID 命名空间中的 EnableTRIM 变量。 22. XhciPortLimitType: plist booleanFailsafe: falseRequirement: 10.11 (not required for older)Description: 修补 AppleUSBXHCI.kext、AppleUSBXHCIPCI.kext、IOUSBHostFamily.kext 以移除 15 端口限制。 注：请尽可能避免使用这一选项。USB 端口数量限制是由 locationID 的 bit 决定的，想要移除限制就需要对操作系统进行大量修改。真正长期有效的解决方案是限制可用的 USB 端口个数在 15 以下（通过 USB 定制的方法）。详细信息请参考AppleLife.ru。 7.9 Scheme 属性这些属性对于旧版 macOS 操作系统尤为重要。更多关于如何安装此类 macOS 及相关排错的详细信息，请参考 旧版 Apple 操作系统。 1. CustomKernelType: plist booleanFailsafe: falseDescription: 使用位于 ESP 分区下的 Kernels 目录下的定制内核缓存。 不支持的平台，包括 Atom 和 AMD，需要修改的 XNU 内核版本才能启动。这个选项提供了使用定制内核缓存的可能性，其中包含来自 ESP 分区的这种修改。 2. FuzzyMatchType: plist booleanFailsafe: falseDescription: 在可用时使用校验值不同的 kernelcache。 在 macOS 10.6 和更早的版本中，kernelcache 文件名有一个校验值，本质上是对 SMBIOS 产品名称和 EfiBoot 设备路径进行 adler32 校验和的计算。在某些固件上，由于 ACPI 或硬件的特殊性，UEFI 和 macOS 的 EfiBoot 设备路径不同，使得 kernelcache 的校验和总是不同。 这一设置可以在无后缀的 kernelcache 不可用时，将最新的 kernelcache 与合适的架构进行匹配，从而提高 macOS 10.6 在多个平台上的启动性能。 3. KernelArchType: plist stringFailsafe: Auto (自动选择首选架构)Description: 如果可用，优先选择指定的内核架构（i386, i386-user32, x86_64）。 macOS 10.7 和更早版本中，XNU 内核可能不会使用 x86_64 架构来启动。当 macOS 和配置支持时，该设置将使用指定的架构来启动 macOS: i386 — 如果可用，则使用 i386（32 位）内核。 i386-user32 — 在可用的情况下使用 i386（32 位）内核，并在 64 位处理器上强制使用 32 位用户空间（前提是系统支持）。 在 macOS 上，64 位处理器会被认为支持 SSSE3 指令集，但对于较老的 64 位奔腾处理器来说，实际情况并非如此，因此会导致一些应用程序在 macOS 10.6 上崩溃。该行为对应 -legacy 内核启动参数。 由于 XNU 内核中存在一段未被初始化的 64 位片段，导致 AppleEFIRuntime 错误地将 64 位代码作为 16 位来执行，因此该选项对于 64 位固件上运行的 10.4 和 10.5 系统是不可用的。 x86_64 — 如果可用，则使用 x86_64（64 位）内核。 下面是确定内核架构的计算过程： arch 参数位于映像参数（比如从 UEFI Shell 启动时）或 boot-args 变量中，覆盖兼容性检查，强制指定架构，并完成此计算过程。 对于 32 位 CPU Variant，OpenCore 会将架构兼容性限制在 i386 和 i386-user32 模式。 确定 EfiBoot 版本所限制的架构: 10.4-10.5 — i386 或 i386-user32（仅限用于 32 位固件） 10.6 — i386、i386-user32 或 x86_64 10.7 — i386 或 x86_64 10.8 及更新的版本 — x86_64 如果 KernelArch 被设置为 Auto，并且 CPU 不支持 SSSE3 指令集， 则兼容性会被限制为 i386-user32（如果 EfiBoot 支持的话）。 主板标识符（来自 SMBIOS）基于 EfiBoot 版本，如果有任何 i386 的 CPU Variant 与之兼容，就会在不支持的机型上禁用 x86_64 架构。Auto 不参与这个过程，因为在 EfiBoot 中，该列表是不可覆盖的。 当没有设置为 Auto 时，KernelArch 会把系统支持限制在明确指定的架构（如果该架构兼容）。 按以下顺序选择参数可以获得最佳的架构支持：x86_64、i386、i386-user32。 macOS 10.7 只会将特定的主板标识符视为仅 i386 架构的设备，macOS 10.5 或更早版本的内核则不支持 x86_64，而 macOS 10.6 非常特殊，与这二者都不同。macOS 10.6 上的架构选择取决于很多因素，不仅包括主板标识符，还包括 macOS 的类型（客户端 或 服务器端）、macOS 发布时间和内存容量。检测这些因素很复杂，也不实用，因为好几个发布版本都有 bug，不能在第一时间正确地进行服务器检测。因此，对于 macOS 10.6，无论主板支持情况如何，OpenCore 都会回退到 x86_64 架构，就像 macOS 10.7 那样。以下是 64 位 Mac 型号的兼容性介绍，对应于 macOS 10.6.8 和 10.7.5 EfiBoot 的实际行为： Model 10.6 (minimal) 10.6 (client) 10.6 (server) 10.7 (any) Macmini 4,x (Mid 2010) 5,x (Mid 2011) 4,x (Mid 2010) 3,x (Early 2009) MacBook Unsupported Unsupported Unsupported 5,x (2009/09) MacBookAir Unsupported Unsupported Unsupported 2,x (Late 2008) MacBookPro 4,x (Early 2008) 8,x (Early 2011) 8,x (Early 2011) 3,x (Mid 2007) iMac 8,x (Early 2008) 12,x (Mid 2011) 12,x (Mid 2011) 7,x (Mid 2007) MacPro 3,x (Early 2008) 5,x (Mid 2010) 3,x (Early 2008) 3,x (Early 2008) Xserve 2,x (Early 2008) 2,x (Early 2008) 2,x (Early 2008) 2,x (Early 2008) 注：不支持用热键 3+2 和 6+4 来选择偏好架构，这是因为这个热键是由 EfiBoot 处理的，很难正确地检测到。 3. KernelCacheType: plist stringFailsafe: AutoDescription: 如果可用，优先选择指定的内核缓存（Kernel Cache）类型（Auto, Cacheless, Mkext, Prelinked）。 macOS 的版本不同，支持的内核缓存变量也不同，其目的是提高启动性能。如果出于调试和稳定性的考虑，可利用这个设置防止使用较快的内核缓存变量。举个例子，如果指定 Mkext，那么会为 10.6 禁用 Prelinked，10.7 则不受影响。 可用的内核缓存类型及其当前在 OpenCore 中的支持情况列表如下： macOS i386 NC i386 MK i386 PK x86_64 NC x86_64 MK x86_64 PK x86_64 KC 10.4 YES YES (V1) NO (V1) — — — — 10.5 YES YES (V1) NO (V1) — — — — 10.6 YES YES (V2) YES (V2) YES YES (V2) YES (V2) — 10.7 YES — YES (V3) YES — YES (V3) — 10.8-10.9 — — — YES — YES (V3) — 10.10-10.15 — — — — — YES (V3) — 11+ — — — — — YES (V3) YES 注：不支持第一个版本（V1）的 32 位 prelinkedkernel ，因为 Kext 符号表被工具破坏了，在这个版本中 Auto 会阻止 prelinkedkernel 启动。同时，这也会使 keepsyms=1 在这些系统上不可用。"},{"title":"8. Misc","url":"/8-misc.html","content":"8.1 简介本部分包含关于 OpenCore 操作系统加载行为的各种配置选项，以及不能被分类到其它章节的配置条目的说明。 OpenCore 大体上遵循 bless 模式，即 Apple Boot Policy。bless 模式的主要特点是允许在文件系统中嵌入启动选项（而且能通过专门的驱动程序访问），同时，相比于 UEFI 规范中的可移动媒体列表，它还支持更多的预定义启动路径。 只有当分区符合 Scan policy 时才能被启动（Scan policy 是一组限制条件，能够使其仅使用特定文件系统和特定设备类型的分区）。具体的扫描策略（Scan policy）将在下面的 ScanPolicy 属性中阐述。 扫描过程从获取 Scan policy 过滤过的分区开始。每个分区可能会产生多个主选项和备用选项。主选项描述的是安装在这个介质上的操作系统。备用选项描述的是介质上的操作系统的恢复项。备用选项可以在没有主选项的情况下存在，反之亦然。 替代选项可能在没有主选项的情况下存在，反之亦然。 请注意，这些选项描述的操作系统不一定都在同一个分区上。 每个主选项和备用选项都可以作为辅助选项（Auxiliary Option），也可以不作为辅助选项。 具体细节参考下面的 HideAuxiliary 章节。 8.1.1 引导算法用来确定启动选项的算法如下： 通过 Scan policy（和驱动可用性）过滤，获取所有可用的分区句柄。 从 BootOrder UEFI 变量中，获取所有可用的启动选项。 对于每个找到的启动选项： 检索该启动选项的设备路径。 执行对设备路径的修复（如 NVMe 子类型修复）和扩展（例如： Boot Camp）。 失败时，如果是 OpenCore 自定义条目设备路径，则预先构建相应的自定义条目并继承。 通过定位到所产生的设备路径，来获取句柄（失败时忽略）。 在分区句柄列表中找到设备句柄（缺失时忽略）。 对磁盘设备路径（不指定引导程序）执行 bless（可能返回不止一个条目）。 对文件设备路径直接检查其文件系统。 如果在 bootloader 附近或相关位置（见下文）内有一个内容为 ASCII 编码的 Disabled 的 .contentVisibility 文件，（并且如果当前的 InstanceIentifier 与存在的 Instance-List 匹配（参见下文），则排除该条目。 如果有分区句柄列表，则在列表中将设备句柄标记为 used。 将生成的条目注册为主选项，并确定他们的类型。某些类型的选项作为辅助选项（如 Apple HFS Recovery）。对于某些类型（例如 Apple HFS recovery）或其 .contentVisibility 文件包含 Auxiliary 时（并且如果当前的 InstanceIentifier 与存在的 Instance-List 匹配，请见下文。），该选项将成为辅助性的。 对于每个分区句柄： 如果分区句柄被标记为 unused，则执行 bless 主选项列表检索。如果设置了 BlessOverride 列表，那么不仅能找到标准的 bless 路径，还能找到自定义的路径。 在 OpenCore 启动分区中，通过 Header Check 排除所有 OpenCore Bootstrap 文件。 将生成的条目注册为主选项，并确定他们的类型。某些类型的选项作为辅助选项（如 Apple HFS Recovery）。 如果分区已经具有来 Apple Recovery 类型的主选项，则继续处理下一个句柄。 通过 bless 恢复选项列表检索和预定义路径，来查找备用条目。 将生成的条目注册为备用辅助选项，并确定它们的类型。 把自定义条目和工具添加为主选项（以前预先构造的除外），不做有关 Auxiliary 的任何检查。 把系统条目（如 Reset NVRAM）添加为主要的辅助选项。 .contentVisibility 文件可以放置在 bootloader 附近（例如：boot.efi），或者放置在引导文件夹中（对于基于 DMG 文件夹的引导项）。从 macOS 内部看到的示例位置是： /System/Volumes/Preboot/{GUID}/System/Library/CoreServices/.contentVisibility /Volumes/{ESP}/EFI/BOOT/.contentVisibility此外，.contentVisibility 文件可以放置在特定于实例（对于 macOS）或与启动项相关的绝对根文件夹中，例如： /System/Volumes/Preboot/{GUID}/.contentVisibility /System/Volumes/Preboot/.contentVisibility /Volumes/{ESP}/.contentVisibility（不推荐） 这些根文件夹位置专门针对 macOS 支持，因为 Apple 引导加载程序旁边的非 Apple 文件会被 macOS 更新删除。支持但不建议将 .contentVisibility 文件放置在非 macOS 根位置（例如上面显示的最后一个位置），因为它会隐藏驱动器上的所有条目。 .contentVisibility 文件（如果存在）可以选择仅针对 OpenCore 的特定实例。其内容为 [ {Instance-List}: ] (Disabled|Auxiliary)。如果存在冒号 (:)，则前面的 Instance-List 是逗号分隔的 InstanceIdentifier 值列表（例如：OCA,OCB:Disabled）。当此列表存在时，仅当当前 OpenCore 实例的 InstanceIdentifier 存在于列表中时才应用指定的可见性。当列表不存在时，指定的可见性将应用于 OpenCore 的所有实例。 注 1：对于任何没有 InstanceIdentifier 值的 OpenCore 实例，带有 Instance-List 的 .contentVisibility 文件中指定的可见性将永远不会应用。 注 2：在 OpenCore 的早期版本中，具有可见性列表的可见性将被视为无效，因此会被忽略 - 这在比较旧版本和新版本的行为时可能很有用。 注 3：避免 .contentVisibility 文件中出现无关空格：这些空格不会被视为空格，而是作为相邻标记的一部分。 OpenCore 启动选择器中的启动选项的显示顺序和启动过程，是通过扫描算法分别来确定的。 显示顺序如下： 备用选项跟随主选项，即，Apple Recovery 会尽可能地跟随相关的 macOS 选项。 选项会按照文件系统句柄固件的顺序列出，以便在整个启动过程中保持一个既定的顺序，不因加载操作系统的不同而变化。 自定义条目、工具和系统条目会被添加到所有选项之后。 辅助选项只有在进入「扩展模式」后才会显示（一般是按空格键）。 启动过程如下： 尝试通过 BootNext UEFI 变量查找第一个有效的主选项。 如果失败，则通过 BootOrder UEFI 变量查找第一个有效的主选项。 将该选项标记为默认启动选项。 是否通过启动选择器来启动选项，取决于 ShowPicker 选项的设置。 如果还出现问题，则显示启动选择器。 注 1：这个过程只有在启用了 RequestBootVarRouting 选项，或者固件不控制 UEFI 启动选项（如 OpenDuetPkg 或其他自定义 BDS）时，才会可靠地工作。如果不启用 LauncherOption，那么其他操作系统有可能会覆盖 OpenCore，如果你打算使用其他操作系统，请确保启用这个选项。 注 2：UEFI 变量引导选项的引导参数，如果存在的话则会被丢弃，因为它们包含的一些参数可能会对操作系统产生不利影响，这在启用安全引导时是不可取的。 注 3：某些操作系统（说的就是你，Windows）会在第一次启动时，或 NVRAM 重置后，创建他们的启动选项，并将其标记为最上面的选项。这种情况发生时，默认的启动条目选择将会更新，直到下一次重新手动配置。 译者注：全新安装 windows 会使用已有的 ESP 分区的，并在里面放入自己的 EFI 文件。升级 win11，会覆盖 ESP 分区的 EFI 文件夹里的 BOOT 文件夹。总之备份好 opencore。 8.2 属性列表1. BootType: plist dictDescription: 应用本章节 Boot 属性中的引导相关设置。 2. BlessOverrideType: plist arrayDescription: 通过 Bless Model 添加自定义扫描路径。 设计为填充 plist string 条目，其中包含指向自定义引导程序的绝对 UEFI 路径，例如，用于 Debian 引导程序的 \\EFI\\debian\\grubx64.efi。这允许引导选择器自动发现异常的引导路径。在设计上它们等效于预定义的 Bless 路径（如 \\System\\Library\\CoreServices\\boot.efi 和 \\EFI\\Microsoft\\Boot\\bootmgfw.efi），但与预定义的 Bless 路径不同，它们具有最高优先级。 3. DebugType: plist dictDescription: 应用本章节 Debug 属性中的调试相关设置。 4. EntriesType: plist arrayDescription: 在开机引导菜单中添加引导项。 应填入 plist dict 类型的值来描述相应的加载条目。详见 Entry 属性部分。 5. SecurityType: plist dictDescription: 应用本章节 Security 属性中的安全相关设置。 6. SerialType: plist dictDescription: 执行串行端口初始化并配置 BaseSerialPortLib16550 要求的 PCD 值，以使串行端口正常运行。这些值在下面的 Serial 属性和 Serial Custom 属性部分列出和描述。 通过启用 Init，这部分可以确保在固件没有完成的情况下对串行端口进行初始化。为了使 OpenCore 向串行端口打印日志，必须设置 Misc-&gt;Debug 部分的 Target 第 3 位（即串行日志）。 当使用串口调试时，BaseSerialPortLib16550 默认只识别由主板提供的内部串口。如果启用了 Override 选项，将覆盖 BaseSerialPortLib16550.inf 中列出的 PCD 值，这样外部串口（例如来自 PCI 卡）也能正常工作。具体来说，在排除 macOS 的故障时，除了覆盖这些 PCD 值之外，还需要打开 CustomPciSerialDevice 内核 Quirks，以便 XNU 使用这些外部串口。 请参考 MdeModulePkg.dec 对每个键的解释。 7. ToolsType: plist arrayDescription: 将工具条目添加到开机引导菜单。 应填入 plist dict 类型的值来描述相应的加载条目。详见 Entry 属性部分。 注：某些 UEFI 工具（例如 UEFI shell）可能非常危险，利用这些工具可以轻易地绕过安全启动链，所以 千万不要 出现在生产环境配置中，尤其是设置了 Vault 和安全启动保护的设备（译者注：即，工具仅作调试用）。具体的工具示例参见本文档的 UEFI 部分。 8.3 Boot 属性1. ConsoleAttributesType: plist integerFailsafe: 0Description: 为控制台设置特定的属性。 根据 UEFI 规范，文本渲染器支持的颜色参数为前景色与背景色之和。黑色背景色和黑色前景色的值(0) 是预留的。以下是颜色名称一览： 0x00 — EFI_BLACK（黑色字体） 0x01 — EFI_BLUE（蓝色字体） 0x02 — EFI_GREEN（绿色字体） 0x03 — EFI_CYAN（青色字体） 0x04 — EFI_RED（红色字体） 0x05 — EFI_MAGENTA（紫色字体） 0x06 — EFI_BROWN（棕色字体） 0x07 — EFI_LIGHTGRAY（亮灰色字体） 0x08 — EFI_DARKGRAY（暗灰色字体） 0x09 — EFI_LIGHTBLUE（淡蓝色字体） 0x0A — EFI_LIGHTGREEN（淡绿色字体） 0x0B — EFI_LIGHTCYAN（淡青色字体） 0x0C — EFI_LIGHTRED（淡红色字体） 0x0D — EFI_LIGHTMAGENTA（淡紫色字体） 0x0E — EFI_YELLOW（黄色字体） 0x0F — EFI_WHITE（白色字体） 0x00 — EFI_BACKGROUND_BLACK（黑色背景） 0x10 — EFI_BACKGROUND_BLUE（蓝色背景） 0x20 — EFI_BACKGROUND_GREEN（绿色背景） 0x30 — EFI_BACKGROUND_CYAN（青色背景） 0x40 — EFI_BACKGROUND_RED（红色背景） 0x50 — EFI_BACKGROUND_MAGENTA（紫色背景） 0x60 — EFI_BACKGROUND_BROWN（棕色背景） 0x70 — EFI_BACKGROUND_LIGHTGRAY（亮灰色背景） 注：这个选项可能和 TextRenderer 的 System 参数有冲突，设置一个非黑的背景可以用来测试 GOP 是否正常运行。 2. HibernateModeType: plist stringFailsafe: NoneDescription: 休眠检测模式。 支持以下模式： None — 忽略休眠状态 Auto — 从 RTC 或 NVRAM 中检测 RTC — 从 RTC 检测 NVRAM — 从 NVRAM 检测 注：如果固件自身能处理休眠（大多数 Mac 的 EFI 固件都可以），你应该在此处设置为 None 来让固件处理休眠状态并传递给 OpenCore。 3. HibernateSkipsPickerType: plist booleanFailsafe: falseDescription: 从 macOS 唤醒时不显示启动选择器。 限制条件： 只支持 macOS 的休眠唤醒，Windows 和 Linux 目前不在范围内。 只应在 macOS 中具有可靠休眠唤醒功能的系统上使用，否则用户可能无法直观地看到可能发生的启动循环。 强烈建议将该选项与 PollAppleHotKeys 搭配使用，允许在休眠唤醒出现问题时进入启动选择程序。 休眠唤醒的视觉指示目前超出范围。 4. HideAuxiliaryType: plist booleanFailsafe: falseDescription: 默认情况下，隐藏开机引导项菜单中的辅助条目。 满足任一以下条件的引导项条目即会被视为「辅助项目」 该引导项是 macOS Recovery 分区 该引导项是 macOS Time Machine 分区 该引导项被标记为 Auxiliary 该引导项是系统提供的（例如：Reset NVRAM） 即使被隐藏，你仍然可以通过按空格键进入「扩展模式」查看所有条目（引导项菜单会被重新加载），隐藏辅助条目可能有助于提高多磁盘系统的引导性能，简单来说就是可能提高启动速度。 5. InstanceIdentifierType: plist stringFailsafe: falseDescription: OpenCore 当前实例的可选标识符。 这通常应该是一个短的字母数字字符串。当前该值的用途是选择性地将 .contentVisibility 文件定位到 OpenCore 的特定实例，如引导算法部分中所述。 6. LauncherOptionType: plist stringFailsafe: EmptyDescription: 在固件偏好设置中注册启动器选项，以保证 bootloader 的持久与一致性。 有效值有： Disabled — 什么都不做。 Full — 在 bootloader 启动时，在 UEFI 变量存储中创建或更新最高优先级的启动项。要使用这个选项，必须同时开启 RequestBootVarRouting。 Short — 创建一个短的、非完整的启动项。此值对于某些固件很有用（例如：Insyde），或者其他无法处理完整设备路径的固件。 System — 不创建启动项，而是认为该项是 blessed 的。这种 variant 在依赖 ForceBooterSignature 属性和 OpenCore 启动器路径时非常有用。管理是通过 bless 工具进行的，不涉及 OpenCore。 在安装和升级第三方操作系统时 \\EFI\\BOOT\\BOOTx64.efi 文件可能会被覆盖掉，该选项则保证了出现覆盖情况时 bootloader 的一致性。创建一个自定义启动项后，\\EFI\\BOOT\\BOOTx64.efi 这个文件路径将不再用于引导 OpenCore。自定义的引导路径在 LauncherPath 选项中指定。 注 1：某些固件的 NVRAM 本身存在问题，可能会出现无启动项支持，或者其他各种不兼容的情况。虽然可能性不大，但使用此选项可能会导致启动失败。请在已知兼容的主板上使用，风险自行考虑。请查看 acidanthera/bugtracker#1222 来了解与 Haswell 及其他一些主板相关的已知问题。 注 2：虽然从 OpenCore 执行的 NVRAM 重置不会清除在 Bootstrap 模式中创建的启动选项，但在加载 OpenCore 之前重置 NVRAM 则会同时清除。在进行某些涉及重要实现的更新时（例如：OpenCore 0.6.4），须确保在禁用 Bootstrap 的情况下执行一次 NVRAM 重置，然后再重新启用。 注 3：英特尔 Visual BIOS 的某些版本（例如：英特尔 NUC）有一个不幸的错误，即如果添加了提及 USB 驱动器路径的任何启动选项，那么从那时起，当插入任何 USB 驱动器时，这将是唯一的启动选项。如果在该固件上从 USB 驱动器启动 OpenCore，并将 LauncherOption 设置为 Full 或 Short，那么这一点就适用，之后在插入任何其他 USB 时，只能看到 OpenCore 的启动项（这种高度非标准的 BIOS 行为也会影响其他软件）。避免这种情况的最佳方法是在任何版本的 OpenCore 上将LauncherOption 设置为 Disabled 或 System，该固件将从 USB 驱动器启动。 如果问题已经发生，最快的可靠修复方法是： 在 Intel Visual BIOS 中启用 system UEFI Shell 在关闭电源的情况下，插入 OpenCore USB 开机并选择 system UEFI Shell 由于 system Shell 不包括 bcfg，因此使用 system Shell 来启动 OpenCore 的 OpenShell（例如输入FS2:\\EFI\\OC\\Tools\\OpenShell.efi 命令，但你需要弄清楚 OpenCore 在哪个驱动器上，并相应地修改驱动器编号FS#:）。 在 OpenShell 中，使用 bcfg boot dump 显示 NVRAM 启动选项，然后使用 bcfg boot rm #（其中#是OpenCore启动条目的编号）来删除 OpenCore 条目。 如果你有一个为系统配置的 OpenCore，也可以直接从 OpenCore 启动菜单中启动 OpenShell。在这种情况下，如果 OpenCore 启用了 RequestBootVarRouting，就有必要在使用 bcfg 之前运行命令 \\EFI\\OC\\Tools\\OpenControl.efi disable （在禁用 OpenControl 之后，有必要在启动操作系统之前重启或运行 OpenControl restore）。如果你的机器上有一个工作版本的Linux，也可以在 Linux 中使用 efibootmgr 来删除违规的条目。Linux 必须不通过 OpenCore 启动，或者通过禁用 RequestBootVarRouting 的 OpenCore 启动，这样才能发挥作用。 7. LauncherPathType: plist stringFailsafe: DefaultDescription: LauncherOption 的启动引导路径。 Default 用于引导 OpenCore.efi。其他的路径（例如：\\EFI\\Launcher.efi）可用来提供自定义加载器，用于自行加载 OpenCore.efi。 8. PickerAttributesType: plist integerFailsafe: 0Description: 设置开机引导菜单的属性。 可以用属性掩码来设置引导菜单的不同属性，其中掩码包含 OpenCore 的预留值（BIT0 到 BIT15）和 OEM 特定值（BIT16 到 BIT31）。 目前 OpenCore 的预留值有： 0x0001 — OC_ATTR_USE_VOLUME_ICON，为启动项提供自定义图标：OpenCore 将尝试通过搜索加载卷宗图标，不存在时回退到默认图标： APFS 卷宗图标的 .VolumeIcon.icns 文件，置于 Preboot 卷宗目录（/System/Volumes/Preboot/&#123;GUID&#125;/，当在 macOS 内的默认位置时）下（如果存在）。 APFS 卷宗图标的 .VolumeIcon.icns 文件，置于 Preboot 根目录(/System/Volumes/Preboot/，当在 macOS 内的默认位置时)下（其他情况）。 其他文件系统的 .VolumeIcon.icns 文件，置于其卷宗根目录下。 注 1：Apple 启动器部分支持在 macOS 内的默认位置放置卷图标文件，将其放置在操作系统的数据卷根目录 /System/Volumes/Data/。这种方法是有缺陷的：当 FileVault 2 被启用时，文件既不能被 OpenCanopy 访问，也不能被 Apple picker 访问，而 FileVault 2 应该是默认选择。因此，OpenCanopy 不尝试支持苹果的方法。卷图标文件可以放在 Preboot 卷的根部，以便与 OpenCanopy 和 Apple picker兼容，或者使用 Preboot 每个卷的位置，如上所述， OpenCanopy 是苹果方法的首选替代方案。 注 2：请注意，在任何驱动器上使用卷图标会覆盖该驱动器的正常 OpenCore 启动器行为，即根据驱动器是内部还是外部选择适当的图标。 0x0002 — OC_ATTR_USE_DISK_LABEL_FILE，对所有文件系统的引导程序旁边的 .disk_label (.disk_label_2x)文件的引导条目使用自定义的预渲染标题。这些标签可以通过 disklabel 工具或 bless --folder &#123;FOLDER_PATH&#125; --label &#123;LABEL_TEXT&#125; 命令生成。当预渲染的标签被禁用或缺失时，如果存在的话，使用 bootloader 旁边的 .contentDetails（或 .disk_label.contentDetails）文件中的标签文本代替，否则将渲染条目名称本身。 0x0004 — OC_ATTR_USE_GENERIC_LABEL_IMAGE，为没有自定义条目的启动项提供预定义的标签图像。可能会缺少实际启动项的详细信息。 0x0008 — OC_ATTR_HIDE_THEMED_ICONS，优先选择特定图标集的图标，以配合主题风格，比如可以强制显示特定图标集内置的 Time Machine 图标。需要同时启用 OC_ATTR_USE_VOLUME_ICON。 0x0010 — OC_ATTR_USE_POINTER_CONTROL，在启动选择器中启用指针控制。例如，可以利用鼠标或触摸板来控制 UI 元素。 0x0020 - OC_ATTR_SHOW_DEBUG_DISPLAY，在启动选择器中显示额外的时间和调试信息。仅在 Dubug 和 NOOPT 版本的 Builtin picker 中生效。 0x0040 - OC_ATTR_USE_MINIMAL_UI，显示最小化 UI，不显示关机或重启的按钮。在 OpenCanopy 和 Builtin picker 中生效。 0x0080 - OC_ATTR_USE_FLAVOUR_ICON，提供弹性的启动项内容描述，可以在不同的图标集中选择最好的图标： 当启用的时候，OpenCanopy 中的启动项和 audio assist 项目音频以及 Builtin boot picker 可以被 content flavor 指定。要指定 content flavor，请参考以下规则： 对于一个 Tool 项目，将会从其 Flavour 中读取 对于一个自动发现项目，包括由 OpenLinuxBoot 驱动生成的引导入口协议条目，将会从 bootloader 同目录下的 .contentFlavour 文件中读取（如果有的话） 对于一个自定义项目，如果其 Flavour 为 Auto，则从 bootloader 同目录下的 .contentFlavour 文件中读取，否则由 Flavour 指定 如果读取到的 Flavour 项目为 Auto 或 .contentFlavour 文件不存在，则根据启动项类型来选择图标（例如：Windows 将会被自动设置为 Windows 图标） Flavour 的值是一个由 : 分隔的名字，必须是可打印的 7-bit ASCII，最长限制在 64 字符内。此项目大约能填写五个名字，最前面的名字有最高的优先级，最后面的名字由最低的优先级。这样的结构允许用一个更具体的方式来描述一个启动项，根据音频-图标集的支持情况，灵活选择图标。如果找不到音频或图标文件，则启动器会自动尝试下一个 flavour，而如果所有的 flavour 都找不到文件，则启动器会根据启动项类型来自动选择图标。以下是一个 flavour 的例子：BigSur:Apple, Windows10:Windows. OpenShell:UEFIShell:Shell. 使用 flavour 意味着你可以容易地在图标集之中选择自己想要的图标，在图标集所有的图标中选择一个最合适的图标。比如，指定一个 flavour 图标 Debian:Linux 则将会尝试使用 Debian.icns 这个图标，如果没找到的话则尝试 Linux.icns，如果还没找到的话则会回退到 OS 的默认图标，也就是 HardDrive.icns。 一些需要注意的事情： 为了安全考虑，Ext&lt;Flavour&gt;.icns 和 &lt;Flavour&gt;.icns 都会被支持，并且当启动项是外接硬盘时仅有 Ext&lt;Flavour&gt;.icns 会被使用（就像默认的 ExtHardDrive.icns 那样）。 当 .VolumeIcon.icns 和 .contentFlavour 都存在时，以 .VolumeIcon.icns 为准。 为了使 tools 的图标和屏幕朗读工作正常（例如：UEFI Shell），在 Flavour 设置中指定的系统的默认启动项图标（见 Docs/Flavours.md）将仍然被应用，即使 Flavour 是禁用状态。在这个情况下非系统的图标将会被忽略。此外，UEFIShell 和 NVRAMReset 的 flavours 将会被特殊处理，以辨识它们的正确的屏幕朗读器、默认 builtin 标签等。 一个推荐的 falvours 列表在 Docs/Flavours.md 中 9. PickerAudioAssistType: plist booleanFailsafe: falseDescription: 在开机引导菜单中启用屏幕朗读。 macOS Bootloader 屏幕朗读的偏好设置是存在 isVOEnabled.int32 文件的 preferences.efires 中、并受操作系统控制。这里仅提供一个等效的开关。切换 OpenCore 开机引导菜单和 macOS BootLoader FileVault 2 登录界面也可以使用快捷键 Command+F5。 注：屏幕朗读依赖可以正常工作的音频设备。详情请参考 UEFI Audio 属性部分。 10. PollAppleHotKeysType: plist booleanFailsafe: falseDescription: 在开机引导菜单中启用 Modifier Hotkey。 除了在 PickerMode 部分描述的、通常由 Apple BDS 处理的 Action Hotkeys 之外，还存在由操作系统引导程序（boot.efi）处理的修改键。这些键允许通过提供不同的启动模式来改变操作系统的行为。 在某些固件上，由于驱动程序不兼容，使用 Modifier Hotkey 可能会有问题。为了解决这个问题，这个选项允许在 OpenCore 启动选择器中以更宽松的方式注册某些热键。这种扩展包括支持在选择启动项目之前敲击组合键，以及在选择启动项目时可靠地检测 Shift 键，以解决在启动期间持续按住的热键在许多 PS/2 键盘上不能被可靠地检测的问题。 已知的 Modifier Hotkey 如下： CMD+C+MINUS — 禁用主板兼容性检查。 CMD+K — 从 RELEASE 版本的内核启动，类似于 kcsuffix=release 参数。 CMD+R — 从恢复分区启动。 CMD+S — 启动至单用户模式。 CMD+S+MINUS — 禁用 KASLR slide，需要事先禁用 SIP。 CMD+V — 启用 -v。 Shift+Enter，Shift+Index — 启用安全模式，可与 CTRL+Enter、CTRL+[数字] 结合使用。 11. ShowPickerType: plist booleanFailsafe: falseDescription: 是否显示开机引导菜单。 12. TakeoffDelayType: plist integer, 32 bitFailsafe: 0Description: 在处理引导项启动和处理 Action Hotkey 之前的延迟，以微秒为单位。 引入一个延迟可以提供额外的时间来保持正确的 Action Hotkey 序列，例如，启动到恢复模式。在大多数系统中，初始启动标志的出现是一个很好的指示，表明可以按住热键的时间。比这更早的时间，按键可能不会被注册。在一些平台上，由于键盘驱动程序的性质，要访问动作热键，还需要将该选项设置为至少 5000-10000 微秒。 如果配置了开机报时（见音频配置选项），那么以较慢的启动速度为代价，可以使用半秒到一秒的更长的延迟（500000-1000000）来创造类似于真正的 Mac 的行为，其中报时本身可以作为热键可以被按下的一个信号。在 OpenCore 中，由于必须首先加载和连接非本地驱动程序，因此开机鸣叫在开机顺序中不可避免地比在苹果硬件上晚。配置开机鸣叫并增加这个较长的额外延迟，对于那些开机时间快或显示器信号同步慢的系统可能导致在某些开机或重启时根本不显示开机标识的情况也很有用。 13. TimeoutType: plist integer，32 bitFailsafe: 0Description: 开机引导菜单中，启动默认启动项之前超时时间（以秒为单位）。 使用 0 禁用倒计时。 译者注：0 为关闭倒计时而非跳过倒计时，相当于 Clover 的 -1。 14. PickerModeType: plist stringFailsafe: BuiltinDescription: 选择启动管理器的界面。 这里描述的是具有可选用户界面的底层启动管理器，支持以下值： Builtin — 使用由 OpenCore 处理的启动管理器，简单的文本用户界面。 External — 如果可用，则使用外部启动管理器协议，否则使用 Builtin 模式。 Apple — 如果可用，则使用 Apple 启动管理器，否则使用 Builtin 模式。 External 模式一旦成功，就会完全禁用 OpenCore 中的除策略强制执行的所有其他启动管理器，而 Apple 模式下可以绕过策略的强制执行。请参阅 OpenCanopy 插件以了解自定义用户界面的实例。 OpenCore 内置的启动选择器包含了一系列在启动过程中选择的操作。支持的操作与 Apple BDS 类似，一般来说能够通过在启动过程中按住 Action Hotkey 来实现，目前有以下几种： Default — 此项为默认选项，可以让 OpenCore 内置的启动选择器按照 启动磁盘 偏好设置中指定的方式加载默认的启动项。 ShowPicker — 此项会强制显示启动选择器，通常可以在启动时按住 OPT 键来实现。将 ShowPicker 设置为 true 会使 ShowPicker 成为默认选项。 BootApple — 此项会启动到第一个找到的 Apple 操作系统，除非 Apple 已经默认选择了操作系统。按住 X 键来选择此选项。 BootAppleRecovery — 此项会启动到 Apple 操作系统的恢复系统。这里的系统要么是「与默认选中的操作系统相关的恢复系统」，要么是「第一个找到的非 Apple 的默认操作系统的恢复系统」，要么是「无恢复系统」。按住 CMD+R 组合键来选择此选项。 注 1：在非 Apple 固件上需要激活 KeySupport、OpenUsbKbDxe 或类似的驱动程序才能工作。然而，并非所有的键处理功能都能在几种类型的固件上实现。 注 2：除了 OPT 之外，OpenCore 还支持在 ShowPicker 被禁用时使用 Escape 和 Zero 键进入 OpenCore 启动选择器。Escape 的存在是为了支持与 Apple 启动选择器共存（包括 OpenCore Apple 启动选择器模式），并支持未能报告持有 OPT 键的固件，如某些 PS/2 键盘上。此外，提供 Zero 是为了支持 Escape 已经被分配给一些其他预启动固件功能的系统。在不需要 KeySupport 的系统中，从开机后按住这些键中的一个，直到选择器出现，应该总是能成功。如果为系统正确配置了 KeySupport 模式，即有足够长的 KeyForgetThreshold，那么在使用 KeySupport 模式时也应该适用。如果按住键不能成功地进入挑选器，可以尝试多次重复按键来代替。 注 3：对于 GOP 有问题的 Mac，如果 OpenCore 的 bless 状态丢失，可能很难重新设置。如果设置为 OpenCore 的工具，并启用 FullNvramAccess，可以使用 BootKicker 实用程序解决此问题。它会启动 Apple picker，允许选择下一个要启动的项目（使用 Enter 键），或者一直选择下一个项目，直到下一次更改。 15. PickerVariantType: plist stringFailsafe: AutoDescription: 选择启动管理器所使用的图标集。 图标集是一个相对于 Resources/Image 的目录路径，其中有图标和一个可选的清单。我们建议使用 Vendor/Set 格式的图标集，例如 Acidanthera\\GoldenGate。 作为 OcBinaryData 资源库的一部分提供的样本资源提供了以下图标集： Acidanthera\\GoldenGate - macOS 11风格的图标集。 Acidanthera\\Syrah - macOS 10.10风格的图标集。 Acidanthera\\Chardonnay - macOS 10.4风格的图标集。 为了方便起见，还有一些预定义的别名: Auto — 根据 DefaultBackground 颜色，自动选择一组图标。Acidanthera\\GoldenGate 为西拉黑，Acidanthera\\Chardonnay 为浅灰色。 Default —Acidanthera\\GoldenGate。 8.4 Debug 属性1. AppleDebugType: plist booleanFailsafe: falseDescription: 启用将 boot.efi 调试日志保存到 OpenCore 日志。 注：此项仅适用于 10.15.4 和更新版本。 2. ApplePanicType: plist booleanFailsafe: falseDescription: 将 macOS Kernel Panic 保存到 OpenCore 根分区。 保存的文件为 panic-YYYY-MM-DD-HHMMSS.txt。强烈建议使用 keepsyms=1 引导参数来查看 Panic 日志中的调试符号。如果没有，可以用 kpdescribe.sh 实用工具（OpenCore 绑定）来部分恢复堆栈跟踪。 开发者内核和调试内核会产生更有用的 Kernel Panic。调试的时候，可以考虑从 developer.apple.com 下载并安装 KernelDebugKit。如果要激活开发者内核，需要添加一个 kcsuffix=development 引导参数。使用 uname -a 命令来确保你当前加载的内核是一个开发者（或调试）内核。 如果没有使用 OpenCore 的 Kernel Panic 保存机制，仍然可以在 /Library/Logs/DiagnosticReports 目录下找到 Panic 日志。从 macOS Catalina 开始，Kernel Panic 会以 JSON 格式储存，所以在传递给 kpdescribe.sh 之前需要预处理： 3. DisableWatchDogType: plist booleanFailsafe: falseDescription: 某些固件启动操作系统的速度可能不够快（尤其是调试模式下），看门狗定时器会因此中止引导过程。此选项用来关闭看门狗定时器。 4. DisplayDelayType: plist integerFailsafe: 0Description: 屏幕上打印每行输出之间的延迟。 5. DisplayLevelType: plist integer，64 bitFailsafe: 0Description: 与屏幕显示相关的 EDK II 调试级别的位掩码（总和）。除非 Target 启用了控制台在屏幕上输出日志，否则屏幕上的调试输出将不可见。 支持以下级别（更多详细信息参见 DebugLib.h）： 0x00000002 (bit 1) — DEBUG_WARN in DEBUG, NOOPT, RELEASE. 0x00000040 (bit 6) — DEBUG_INFO in DEBUG, NOOPT. 0x00400000 (bit 22) — DEBUG_VERBOSE in custom builds. 0x80000000 (bit 31) — DEBUG_ERROR in DEBUG, NOOPT, RELEASE. 6. LogModulesType: plist booleanFailsafe: *Description: 按模块过滤日志条目。 该选项过滤特定模块在日志和屏幕上生成的日志。支持两种模式： + — Positive filtering：仅显示选定的模块。 - — Negative filtering：排除所选模块。 当选择多个日志行标识时，应使用逗号 ， 作为分隔符。例如：+OCCPU，OCA，OCB 这表示只打印 OCCPU、OCA、OCB 模块的日志。而 -OCCPU，OCA，OCB 表示这些模块被过滤掉（即不记录）。由于日志中可能存在没有有效前缀的行（即日志行不是由 OpenCore 的部分生成，而是由其他加载的驱动程序生成），因此特殊模块名称问号 (?) 可以包含在列表中以包含 (使用正过滤）或排除（使用负过滤）这些非标准行。当不指定 + 或 - 符号时，将使用正向过滤 (+)。* 表示所有模块都被记录下来。 注 1：库的首字母缩写词可以在下面的库部分找到。 注 2：在配置日志协议之前打印的消息不能从早期屏幕日志中过滤，但在从早期日志缓冲区中取消缓冲后，将根据其他日志目标的要求进行过滤。 注 3：为避免遗漏关键问题，不过滤警告和错误日志消息。 7. SysReportType: plist booleanFailsafe: falseDescription: 在 EFI 分区中保存系统报告。 启用这一选项后，EFI 分区中将会新建一个 SysReport 目录。这一目录中将会保存包含 ACPI、SMBIOS 和音频编解码器的调试信息。保存音频编解码器信息需要加载音频后端驱动。 注：基于安全的考虑，RELEASE 构建的 OpenCore 将不会内置这一功能。如果需要使用这一功能请使用 DEBUG 构建版。 8. TargetType: plist integerFailsafe: 0Description: 启用日志记录目标的位掩码（总和）。默认所有日志的输出都是隐藏的，所以当需要调试时，有必要设置这个选项。 支持以下日志记录目标： 0x01 (bit 0) — 启用日志记录，否则所有日志都会被丢弃 0x02 (bit 1) — 在屏幕上输出日志 0x04 (bit 2) — 启用把日志记录到 Data Hub 0x08 (bit 3) — 启用串行端口记录 0x10 (bit 4) — 启用 UEFI 变量记录 0x20 (bit 5) — 启用非易失性 UEFI 变量记录 0x40 (bit 6) — 启用在 ESP 分区生成日志文件 0x80 (bit 7) — 与 0x40 结合使用，使在 ESP 分区生成日志文件更快，但不安全（请参阅下面的警告 2）。 控制台日志会比其他日志少，根据 build 类型（RELEASE、DEBUG 或 NOOPT）的不同，读取到的日志量也会不同（从最少到最多）。 Data Hub 日志中不包括 Kernel 和 Kext 的日志。要获取 Data Hub 日志，请使用以下命令： UEFI 变量日志中不包含某些信息，也没有性能数据。为了保持系统的完整性，日志大小被限制在 32KB。有些固件可能会提前截断它，或者在没有内存的情况下完全放弃。使用非易失性 flag 将会在每打印一行后把日志写入 NVRAM 闪存。如要获取 UEFI 变量日志，请在 macOS 中使用以下命令： 要获取 UEFI 变量日志，请在 macOS 中使用以下命令： 警告 1某些固件似乎有 NVRAM 垃圾收集的缺陷。因此，它们可能无法在变量删除后始终释放空间。除非特别需要，否则不要在这类设备上启用非易失性 NVRAM 记录。 虽然 OpenCore 的引导日志已经包含了基本的版本信息（包括 build 类型和日期），但即使在禁用引导日志的情况下，这些数据也可以在 NVRAM 中的 opencore-version 变量中找到。 文件记录会在 EFI 卷宗的根目录下创建一个名为 opencore-YYYY-MM-DD-HHMMSS.txt 的文件，其中包含了日志的内容（大写字母部分会被替换为固件中的日期和时间）请注意，固件中的一些文件系统驱动程序不可靠，并且可能会通过 UEFI 写入文件时损坏数据。因此，OpenCore 会尝试用最安全同时也是最慢的方式来写入日志。当你在使用慢速存储驱动器时，请确保已将 DisableWatchDog 设置为 true。如果你在使用 SSD，应该尽量避免使用这一选项，大量的 I/O 操作会加速消耗 SSD 的寿命。 警告 2启用快速文件记录，需要完全兼容的固件 FAT32 驱动程序。在不合适的 FAT32 写入支持的驱动程序上（例如：APTIO IV，可能还有其他），这个设置可能会导致 ESP 文件系统出现损坏，甚至使 ESP 文件系统无法使用。因此，如果要测试这个选项，请重新创建 ESP 分区用于测试。在某些合适的固件上可以显着地提高记录速度，但在一些固件上可能几乎没有速度差异。 在解释日志时，请注意这些行的前缀是描述日志行的相关位置（模块）的标签，从而确定该行日志的归属。 以下是已知的前缀列表： Drivers and tools: BMF — OpenCanopy, bitmap font BS — Bootstrap GSTT — GoptStop HDA — AudioDxe KKT — KeyTester LNX — OpenLinuxBoot MMDD — MmapDump OCPAVP — PavpProvision OCRST — ResetSystem OCUI — OpenCanopy OC — OpenCore main, also OcMainLib VMOPT — VerifyMemOpt Libraries: AAPL — OcLogAggregatorLib, Apple EfiBoot logging OCABC — OcAfterBootCompatLib OCAE — OcAppleEventLib OCAK — OcAppleKernelLib OCAU — OcAudioLib OCA — OcAcpiLib OCBP — OcAppleBootPolicyLib OCB — OcBootManagementLib OCLBT — OcBlitLib OCCL — OcAppleChunkListLib OCCPU — OcCpuLib OCC — OcConsoleLib OCDC — OcDriverConnectionLib OCDH — OcDataHubLib OCDI — OcAppleDiskImageLib OCDM — OcDeviceMiscLib OCFS — OcFileLib OCFV — OcFirmwareVolumeLib OCHS — OcHashServicesLib OCI4 — OcAppleImg4Lib OCIC — OcImageConversionLib OCII — OcInputLib OCJS — OcApfsLib OCKM — OcAppleKeyMapLib OCL — OcLogAggregatorLib OCM — OcMiscLib OCMCO — OcMachoLib OCME — OcHeciLib OCMM — OcMemoryLib OCPE — OcPeCoffLib, OcPeCoffExtLib OCPI — OcFileLib, partition info OCPNG — OcPngLib OCRAM — OcAppleRamDiskLib OCRTC — OcRtcLib OCSB — OcAppleSecureBootLib OCSMB — OcSmbiosLib OCSMC — OcSmcLib OCST — OcStorageLib OCS — OcSerializedLib OCTPL — OcTemplateLib OCUC — OcUnicodeCollationLib OCUT — OcAppleUserInterfaceThemeLib OCVAR — OcVariableLib OCXML — OcXmlLib 8.5 Security 属性1. AllowSetDefaultType: plist booleanFailsafe: falseDescription: 允许使用 CTRL+Enter 和 CTRL+[数字] 设置默认启动项。 注 1：当启用 PollAppleHotKeys 时，可与 Shift+Enter 或 Shift+[数字] 结合使用。 注 2：为了支持在预启动期间对修饰键无响应的系统（这包括 V1 和 V2 KeySupport 模式），OpenCore 还允许按住 =/+ 键，以触发 set default 模式。 译者注：按住 =/+ 键，也可以设置默认启动项。 2. ApECIDType: plist integer, 64 bitFailsafe: 0Description: Apple Enclave 标识符。 将此值设置为任何非零的 64 位整数，将允许使用个性化的 Apple 安全启动标识符。如果你想使用此设置，请确保使用加密的随机数生成器生成一个 64 位的随机数。还有一种方法是将 SystemUUID 的前 8 个字节用于 ApECID，没有 T2 芯片的 Mac 的 macOS 11 就是这样做的。 如果这个值设置妥当，并且 SecureBootModel 值有效且不是 Disabled，那么就可以实现 Apple 安全启动的 完整安全性。 要使用个性化的 Apple 安全启动，必须重新安装操作系统，或对其进行个性化定制。在操作系统被个性化定制之前，只能加载 macOS DMG 恢复镜像。DMG 恢复镜像可以随时用 macrecovery 实用工具下载，然后放到 com.apple.recovery.boot 里，如 技巧和窍门 部分所述。请记住，DmgLoading 需要设置为 Signed 才能通过 Apple 安全启动来加载 DMG。 如果要对现有的操作系统进行个性化定制，请在加载 macOS DMG 恢复镜像之后使用 bless 命令。确保已挂载到系统卷分区，并执行以下命令： macOS 11 为没有 T2 芯片的 Mac 引入了专用的 x86legacy 机型，对于 macOS 11.0 之前的版本，这个机型的 Apple 安全启动可能无法达到预期效果。如果要使用个性化的 Apple 安全启动重新安装操作系统，请记住，当前版本的 macOS 安装器（测试版本 10.15.6）通常会把 /var/tmp 分区的可用内存耗尽，因此在 macOS 安装器镜像下载后不久，就会出现 Unable to verify macOS 的错误信息。为了解决这个问题，需要在开始安装前，在 macOS Recovery 终端输入如下命令，为 macOS 个性化分配一个 2MB 的专用 RAM 磁盘： 3. AuthRestartType: plist booleanFailsafe: falseDescription: 启用与 VirtualSMC 兼容的 authenticated restart。 authenticated restart 可以在重启 FileVault2 分区时不用再次输入密码。你可以使用下述指令执行一次：sudo fdesetup authrestart。macOS 在安装系统更新使用的也是 authenticated restart。 VirtualSMC 通过将磁盘加密密钥拆分保存在 NVRAM 和 RTC 中来执行 authenticated restart。虽然 OpenCore 在启动系统后立刻删除密钥，但是这仍然可能被视为安全隐患。因此这个选项是可选的。 4. BlacklistAppleUpdateType: plist booleanFailsafe: falseDescription: 忽略某些用于更新 Apple 外围固件的启动项（例如：MultiUpdater.efi）。 注：由于某些操作系统（如 macOS Big Sur）无法利用 NVRAM 变量 run-efi-updater 禁用固件更新。 5. DmgLoadingType: plist stringFailsafe: SignedDescription: 定义用于 macOS Recovery 的磁盘映像（Disk Image, DMG）加载策略。 有效值如下： Disabled — 加载 DMG 磁盘映像的行为将会失败。大多数情况下 Disabled 策略仍会允许加载 macOS Recovery，因为通常会有 boot.efi 文件，它与 Apple 安全启动兼容。但是，手动下载存储在 com.apple.recovery.boot 目录中的 DMG 磁盘映像将无法被加载。 Signed — 仅加载 Apple 签名的 DMG 磁盘映像。由于 Apple 安全启动的设计，不管 Apple 安全启动是什么状态，Signed 策略都会允许加载任何 Apple 签名的 macOS Recovery，这可能并不总是令人满意。虽然使用已签名的 DMG 磁盘映像更可取，但验证磁盘映像签名可能会稍微减慢启动时间（最多1秒）。 Any — 任何 DMG 磁盘映像都会作为普通文件系统挂载。强烈不建议使用 Any 策略，当激活了 Apple 安全启动时会导致启动失败。 6. EnablePasswordType: plist booleanFailsafe: falseDescription: 为敏感操作启用密码保护。 启动非默认操作系统（例如：macOS Recovery 或工具）、启动到非默认模式（例如：详细模式或安全模式）或重置 NVRAM 等，以上这些行为属于敏感操作，密码保护可以很好地保证这些操作都是由本人或授权人操作。目前，密码和盐（Salt）用 5000000 次 SHA-512 迭代来进行哈希运算。 注：此功能尚在开发阶段，不推荐日常使用。 7. ExposeSensitiveDataType: plist integerFailsafe: 0x6Description: 用于向操作系统暴露敏感数据的位掩码（总和）。 0x01 — 将可打印的引导器路径作为 UEFI 变量暴露出来 0x02 — 将 OpenCore 版本作为 UEFI 变量暴露出来 0x04 — 将 OpenCore 版本暴露在启动选择菜单的标题位置 0x08 — 将 OEM 信息作为一组 UEFI 变量暴露出来 根据加载顺序，暴露的启动器路径指向 OpenCore.efi 或其引导器。如要获得引导器路径，请在 macOS 中使用以下命令： 如要使用启动器路径加载启动器卷宗，请在 macOS 中使用以下命令： 如果要获取 OpenCore 版本信息，请在 macOS 中使用以下命令： 如果 OpenCore 的版本没有公布，该变量将包含 UNK-000-0000-00-00 序列。 如要获取 OEM 信息，请在 macOS 中使用以下命令： 8. HaltLevelType: plist integer, 64 bitFailsafe: 0x80000000 (DEBUG_ERROR)Description: EDK II 调试级别的位掩码（总和），使 CPU 在获得 HaltLevel 消息后中止（停止执行）。可能的值与 DisplayLevel 值相匹配。 注 1：只有当 Misc-&gt;Debug 部分下的 Target 的 bit 0（即启用日志）被设置时，才会发生停顿。 注 2：只有在加载配置和配置了日志后才会发生停顿。如果有任何日志信息发生在早期日志的指定停顿级别（即在这之前），一旦配置好，它们被刷入日志时将会引起停顿。 9. PasswordHashType: plist data 64 bytesFailsafe: all zeroDescription: 密码使用的哈希值（Hash）。 10. PasswordSaltType: plist dataFailsafe: emptyDescription: 密码使用的盐值（Salt）。 11. VaultType: plist stringFailsafe: SecureDescription: 启用 OpenCore 的 Vault 机制。 有效值： Optional — 无要求，不设置 Vault，不安全。 Basic — 需要有 vault.plist 文件存放在 OC 目录下。这个值提供了基本的文件系统完整性验证，可以防止无意中的文件系统损坏。 Secure — 需要有 vault.sig 签名的 vault.plist 文件存放在 OC 目录下。这个值包括了 Basic 完整性检查，但也会尝试建立一个可信的引导链。 vault.plist 文件应该包含 OpenCore 使用的所有文件的 SHA-256 哈希值。强烈建议使用这个文件，以确保无意中的文件修改（包括文件系统损坏）不会被忽视。要自动创建这个文件，请使用 create_vault.sh 脚本。无论底层的文件系统如何，路径名和大小写必须在 config.plist 和 vault.plist 之间相匹配。 vault.sig 文件应该包含一个来自 vault.plist 的 SHA-256 哈希值的原始的 256 字节 RSA-2048 签名。这个签名是根据嵌入到 OpenCore.efi 中的公钥来验证的。 如要嵌入公钥，以下任一步骤均可： 在 OpenCore.efi 编译过程中，在 OpenCoreVault.c 文件中提供公钥。 用二进制补丁的方式将 OpenCore.efi 中 =BEGIN OC VAULT= 和 ==END OC VAULT== ASCII 码之间的 0 替换为公钥。 RSA 公钥的 520 字节格式可参阅 Chromium OS 文档。如要从 X.509 证书或 PEM 文件中转换公钥，请使用 RsaTool。 以下操作的完整指令： 创建 vault.plist 创建一个新的 RSA 密钥（总是要这样做，以避免加载旧配置） 将 RSA 密钥嵌入到 OpenCore.efi 创建 vault.sig 可以参照如下指令： 注 1：必须使用外部方法来验证 OpenCore.efi 和 BOOTx64.efi 的安全启动路径，尽管它们看似显而易见。为此，建议你至少使用自定义证书来启用 UEFI 的 SecureBoot，并使用自定义的密钥来签名 OpenCore.efi 和 BOOTx64.efi 。关于在现代固件上定制安全启动的更多细节，请参见 Taming UEFI SecureBoot（俄文）。 注 2：当 vault.plist 存在，或者当公钥嵌入到 OpenCore.efi 中的时候，无论这个选项是什么，vault.plist 和 vault.sig 都会被使用。在这两种情况下，出现错误将中止启动过程。设置这个选项可以让 OpenCore 在配置不符合要求时警告用户，以达到预期的更高安全级别。 12. ScanPolicyType: plist integer，32 bitFailsafe: 0xF0103Description: 定义操作系统检测策略。 通过设置该值来根据所选 flag 的位掩码（总和）防止从非信任源扫描（和启动）。由于不可能可靠地检测到每一个文件类型或设备类型，因此在开放环境中不能完全依赖此功能，需要采取额外的措施。 第三方驱动程序可能会根据提供的扫描策略引入额外的安全（和性能）措施。扫描策略暴露在 4D1FDA02-38C7-4A6A-9CC6-4BCCA8B30102 GUID的 scan-policy 变量中，仅适用于 UEFI 启动服务。 0x00000001 (bit 0) — OC_SCAN_FILE_SYSTEM_LOCK，将扫描限制于仅扫描此策略定义的已知文件系统。文件系统驱动可能感知不到这个策略，为了避免挂载不必要的文件系统，最好不要加载它的驱动程序。此 bit 不影响 dmg 挂载，因为它可能有各种文件系统。已知文件系统的前缀为 OC_SCAN_ALLOW_FS_。 0x00000002 (bit 1) — OC_SCAN_DEVICE_LOCK，将扫描限制于仅扫描此策略定义的已知设备类型。由于协议隧道并不一定能被检测到，因此请注意，在某些系统上可能会出现 USB 硬盘被识别成 SATA 等情况。如有类似情况，请务必报告。已知设备类型的前缀为 OC_SCAN_ALLOW_DEVICE_。 0x00000100 (bit 8) — OC_SCAN_ALLOW_FS_APFS，允许扫描 APFS 文件系统。 0x00000200 (bit 9) — OC_SCAN_ALLOW_FS_HFS，允许扫描 HFS 文件系统。 0x00000400 (bit 10) — OC_SCAN_ALLOW_FS_ESP，允许扫描 EFI 系统分区文件系统。 0x00000800 (bit 11) — OC_SCAN_ALLOW_FS_NTFS，允许扫描 NTFS（MSFT Basic Data）文件系统。 0x00001000 (bit 12) — OC_SCAN_ALLOW_FS_EXT，允许扫描 EXT（Linux Root）文件系统。 0x00002000 (bit 13) — OC_SCAN_ALLOW_FS_LINUX_DATA，允许扫描 Linux 数据文件系统。 0x00004000 (bit 14) — OC_SCAN_ALLOW_FS_XBOOTLDR，允许扫描由 Boot Loader Specification 定义的扩展 Boot Loader 分区。 0x00010000 (bit 16) — OC_SCAN_ALLOW_DEVICE_SATA，允许扫描 SATA 设备。 0x00020000 (bit 17) — OC_SCAN_ALLOW_DEVICE_SASEX，允许扫描 SAS 和 Mac NVMe 设备。 0x00040000 (bit 18) — OC_SCAN_ALLOW_DEVICE_SCSI，允许扫描 SCSI 设备。 0x00080000 (bit 19) — OC_SCAN_ALLOW_DEVICE_NVME，允许扫描 NVMe 设备。 0x00100000 (bit 20) — OC_SCAN_ALLOW_DEVICE_ATAPI，允许扫描 CD/DVD 和旧的 SATA 设备。 0x00200000 (bit 21) — OC_SCAN_ALLOW_DEVICE_USB，允许扫描 USB 设备。 0x00400000 (bit 22) — OC_SCAN_ALLOW_DEVICE_FIREWIRE，允许扫描 FireWire 设备。 0x00800000 (bit 23) — OC_SCAN_ALLOW_DEVICE_SDCARD，允许扫描读卡器设备。 0x01000000 (bit 24) — OC_SCAN_ALLOW_DEVICE_PCI，允许扫描直接连接到 PCI 总线的设备(例如 VIRTIO)。 注：举例：根据以上描述，0xF0103 值允许扫描带有 APFS 文件系统的 SATA、SAS、SCSI 和 NVMe 设备，不扫描 USB、CD 和 FireWire 设备上的 APFS 文件系统，也不扫描任何带有 HFS 或 FAT32 文件系统的设备。该值表示如下组合： OC_SCAN_FILE_SYSTEM_LOCK OC_SCAN_DEVICE_LOCK OC_SCAN_ALLOW_FS_APFS OC_SCAN_ALLOW_DEVICE_SATA OC_SCAN_ALLOW_DEVICE_SASEX OC_SCAN_ALLOW_DEVICE_SCSI OC_SCAN_ALLOW_DEVICE_NVME 13. SecureBootModelType: plist stringFailsafe: DefaultDescription: Apple 安全启动的机型。 定义 Apple 安全启动的机型和策略。指定此值能够定义哪些操作系统可以启动。早于指定机型发布时间的操作系统将无法启动。有效值如下： Default — 最近的可用型号，目前设置为 j137 Disabled — 无机型，禁用 Apple 安全启动 j137 — iMacPro1,1 (December 2017). Minimum macOS 10.13.2 (17C2111) j680 — MacBookPro15,1 (July 2018). Minimum macOS 10.13.6 (17G2112) j132 — MacBookPro15,2 (July 2018). Minimum macOS 10.13.6 (17G2112) j174 — Macmini8,1 (October 2018). Minimum macOS 10.14 (18A2063) j140k — MacBookAir8,1 (October 2018). Minimum macOS 10.14.1 (18B2084) j780 — MacBookPro15,3 (May 2019). Minimum macOS 10.14.5 (18F132) j213 — MacBookPro15,4 (July 2019). Minimum macOS 10.14.5 (18F2058) j140a — MacBookAir8,2 (July 2019). Minimum macOS 10.14.5 (18F2058) j152f — MacBookPro16,1 (November 2019). Minimum macOS 10.15.1 (19B2093) j160 — MacPro7,1 (December 2019). Minimum macOS 10.15.1 (19B88) j230k — MacBookAir9,1 (March 2020). Minimum macOS 10.15.3 (19D2064) j214k — MacBookPro16,2 (May 2020). Minimum macOS 10.15.4 (19E2269) j223 — MacBookPro16,3 (May 2020). Minimum macOS 10.15.4 (19E2265) j215 — MacBookPro16,4 (June 2020). Minimum macOS 10.15.5 (19F96) j185 — iMac20,1 (August 2020). Minimum macOS 10.15.6 (19G2005) j185f — iMac20,2 (August 2020). Minimum macOS 10.15.6 (19G2005) x86legacy — Macs and VMs without T2 chip. Minimum macOS 11.0.1 (20B29) 警告并非所有的苹果安全启动模式都支持所有的硬件配置。 Apple 安全启动最初出现于搭载 T2 芯片的机型上的 macOS 10.13。在macOS 12之前，PlatformInfo 和 SecureBootModel 是独立的，因此可以在有或没有 T2 的 SMBIOS 上启用 Apple 安全启动。从 macOS 12 开始， SecureBootModel 必须与 SMBIOS 的 Mac 模型匹配。默认模型是根据 SMBIOS 的板卡标识符得出的，可以通过通用部分自动设置，也可以通过 SMBIOS 部分手动设置。如果没有板卡标识符的覆盖，模型将从 OEM SMBIOS 启发式地导出。 将 SecureBootModel 设置为除 Disabled 以外的任意有效值，相当于实现了 Apple 安全启动的 中等安全性。如要实现「完整安全性」，还需要指定 ApECID 值。在虚拟机上使用 Apple 安全启动时，请检查 ForceSecureBootScheme。 启用 Apple 安全启动的要求很多，任何不正确的配置、错误的 macOS 安装或者不支持的安装设置都可能会增加启用难度，记住以下几点： 和配备 Apple T2 安全芯片的 Mac 电脑一样，你将无法安装任何未签名的内核驱动程序。还有一些内核驱动程序尽管已签名，但也无法安装，包括但不限于 NVIDIA Web Drivers。 驱动程序缓存的列表可能不同，因此需要改变 Add 或 Force 内核驱动程序列表。比如，在这种情况下 IO80211Family 不能被注入。 某些系统（例如 macOS 11）是封装保护的，更改受保护的系统卷可能会导致操作系统无法启动。除非禁用了 Apple 安全启动，否则不要禁用系统卷加密。 如果你的平台需要某些特定设置，但由于之前调试时没有触发明显问题而没有被启用，那么可能会导致启动失败。要格外小心 IgnoreInvalidFlexRatio 或 HashServices。 在 Apple 推出安全启动功能之前发布的操作系统（如 macOS 10.12 或更早的版本）在启用 UEFI 安全启动之前，仍然会启动。之所以如此，是因为从 Apple 安全启动的角度来看，它们都是不兼容的系统，会被认为应该由 BIOS 来处理，就像微软的 Windows 一样。 在较旧的 CPU 上（如 Sandy Bridge 之前），启用 Apple 安全启动可能会使加载速度略微变慢，最长可达 1 秒。 由于 Default 的值会随着时间的推移而变化，以支持最新的 macOS 主版本，因此不建议同时使用 ApECID 和 Default 值。 启用 Apple 安全启动时，HFS+ 文件系统的卷宗无法作为目标卷宗安装 macOS。没有其他备用 APFS 硬盘的情况下，HFS+ 文件系统的硬盘也同样无法安装。 有时，已安装的系统 Preboot 分区上的 Apple 安全启动清单是过时的，从而导致启动失败。如果你看到 OCB: Apple Secure Boot prohibits this boot entry, enforcing! 这样的信息，很可能就是出现了上述这种情况。想要解决这个问题，要么重新安装操作系统，要么把 /usr/standalone/i386 中的清单（扩展名为 .im4m 的文件，如 boot.efi.j137.im4m）复制到 /Volumes/Preboot/&lt;UUID&gt;/System/Library/CoreServices（&lt;UUID&gt; 为系统卷的标识符）。HFS+ 文件系统则须复制到系统卷上的 /System/Library/CoreServices 目录。 关于如何结合 UEFI 安全启动来配置 Apple 安全启动的细节，请参考本文档 UEFI 安全启动 部分。 8.6 Serial 属性1. CustomType: plist dictDescription: 更新 BaseSerialPortLib16550 中的串行端口属性。 本节列出了 BaseSerialPortLib16550 使用的 PCD 值。当选项 Override 被设置为 false 时，这个选项是可选的。 2. InitType: plist booleanDescription: 执行串口初始化。 该选项将在启用（任何）调试记录之前，在OpenCore内执行串行端口初始化。详情请参考调试部分。 3. OverrideType: plist booleanDescription: 覆盖串行端口属性。如果此选项设置为 false，则不会覆盖来自自定义的任何串行端口属性。 这个选项将覆盖下面串行自定义属性部分中列出的串行端口属性。 8.6.1 Serial Custom 属性1. BaudRateType: plist integerFailsafe: 115200Description: 设置串口的波特率。 这个选项将覆盖 MdeModulePkg.dec 中定义的 gEfiMdeModulePkgTokenSpaceGuid.PcdSerialBaudRate 的值。 2. ClockRateType: plist integerFailsafe: 1843200Description: 设置串口的时钟速率。 这个选项将覆盖 MdeModulePkg.dec 中定义的 gEfiMdeModulePkgTokenSpaceGuid.PcdSerialClockRate 的值。 3. DetectCableType: plist booleanFailsafe: falseDescription: 启用串行端口电缆检测。 这个选项将覆盖 MdeModulePkg.dec 中定义的 gEfiMdeModulePkgTokenSpaceGuid.PcdSerialDetectCable 的值。 4. ExtendedTxFifoSizeType: plist integerFailsafe: 64Description: 设置串口的扩展发送 FIFO 大小。 这个选项将覆盖 MdeModulePkg.dec 中定义的 gEfiMdeModulePkgTokenSpaceGuid.PcdSerialExtendedTxFifoSize 的值。 5. FifoControlType: plist integerFailsafe: 0x07Description: 配置串口 FIFO 控制设置。 这个选项将覆盖 MdeModulePkg.dec 中定义的 gEfiMdeModulePkgTokenSpaceGuid.PcdSerialFifoControl 的值。 6. LineControlType: plist integerFailsafe: 0x07Description: 配置串口线路控制设置。 这个选项将覆盖 MdeModulePkg.dec 中定义的 gEfiMdeModulePkgTokenSpaceGuid.PcdSerialLineControl 的值。 7. PciDeviceInfoType: plist dataFailsafe: 0xFFDescription: 设置 PCI 串行设备信息。 这个选项将覆盖 MdeModulePkg.dec 中定义的 gEfiMdeModulePkgTokenSpaceGuid.PcdSerialPciDeviceInfo 的值。 注 1：这个选项的最大允许大小是 41 字节。更多详细信息请参考 acidanthera/bugtracker#1954。 注 2：这个选项可以通过运行 FindSerialPort 工具来设置。 8. RegisterAccessWidthType: plist integerFailsafe: 8Description: 设置串口寄存器存取宽度。 这个选项将覆盖 MdeModulePkg.dec 中定义的 gEfiMdeModulePkgTokenSpaceGuid.PcdSerialRegisterAccessWidth 的值。 9. RegisterBaseType: plist integerFailsafe: 0x03F8Description: 设置串口寄存器的基地址。 这个选项将覆盖 MdeModulePkg.dec 中定义的 gEfiMdeModulePkgTokenSpaceGuid.PcdSerialRegisterBase 的值。 10. RegisterBaseType: plist integerFailsafe: 1Description: 设置串口寄存器的步进，单位为字节。 这个选项将覆盖 MdeModulePkg.dec 中定义的 gEfiMdeModulePkgTokenSpaceGuid.PcdSerialRegisterStride 的值。 11. UseHardwareFlowControlType: plist booleanFailsafe: falseDescription: 启用串口硬件流量控制。 这个选项将覆盖 MdeModulePkg.dec 中定义的 gEfiMdeModulePkgTokenSpaceGuid.PcdSerialUseHardwareFlowControl 的值。 12. UseMmioType: plist booleanFailsafe: falseDescription: 指示串行端口寄存器是否在 MMIO 空间中。 这个选项将覆盖 MdeModulePkg.dec 中定义的 gEfiMdeModulePkgTokenSpaceGuid.PcdSerialUseMmio 的值。 8.7 Entry 属性1. ArgumentsType: plist stringFailsafe: Empty stringDescription: 任意的ASCII字符串，用作该引导条目的启动参数（加载选项）。 2. AuxiliaryType: plist booleanFailsafe: falseDescription: 设置为 true 时，当 HideAuxiliary 设置为 true，则该引导条目将不会显示在开机引导菜单中。按空格键进入 扩展模式 之后，才会显示隐藏的引导条目。 译者注：简单来说就是设置此启动项是否是辅助条目。 3. CommentType: plist stringFailsafe: Empty stringDescription: 用于为条目提供人类可读参考的任意 ASCII 字符串（译者注：即注释）。 4. EnabledType: plist booleanFailsafe: falseDescription: 设置为 true，该引导条目显示在开机引导菜单中。 5. FlavourType: plist stringFailsafe: AutoDescription: 为该启动项指定 flavour，详情请参阅文档中的 OC_ATTR_USE_FLAVOUR_ICON 标识。 6. FullNvramAccessType: plist booleanFailsafe: falseDescription: 在使用 Tools 的过程中禁用 OpenRuntime NVRAM 保护。 在 Tools 使用期间，这将禁用 OpenRuntime.efi 提供的所有 NVRAM 保护措施。通常情况下，应该避免这样做，但是如果一个 Tools 需要直接访问 NVRAM 而不需要 RequestBootVarRouting 的重定向，则可能需要这样做。 注：此选项仅对 Tools 有效，对于 Entries 该属性始终为 false。 7. NameType: plist stringFailsafe: EmptyDescription: 引导条目在开机引导菜单中显示的名字。 8. PathType: plist stringFailsafe: EmptyDescription: 引导入口。 Entries 用于指定外部启动选项，因此会在 Path 中取设备路径。这些值不会被检查，所以要非常小心。例如：PciRoot(0x0)/Pci(0x1,0x1)/.../\\EFI\\COOL.EFI。 Tools 用于指定内部引导选项，这些选项隶属于 bootloader vault，因此会取相对于 OC/Tools 目录的文件路径。例如：OpenShell.efi。 9. RealPathType: plist booleanFailsafe: falseDescription: 启动时将完整的路径传递给工具。 这通常应该禁用，因为传递目录可能会使工具在没有检查文件完整性的情况下就意外地访问了文件，降低了安全性。需要启用该项的情况可能是工具需要外部文件来正常工作或者工具需要外部文件来更好地实现某些功能（例如 memtest86 的记录和配置功能，Shell 自动执行脚本的功能）。 注：此选项仅对 Tools 有效。对于 Entries 该属性始终为 true。 10. TextModeType: plist booleanFailsafe: falseDescription: 以文本模式而非图形模式运行条目。 某些需要文本输出的旧工具需要用到此项。默认情况下所有工具都以图形模式启动。更多关于文本模式的内容，请参阅 Output 属性 部分。"},{"title":"11. UEFI","url":"/11-uefi.html","content":"11.1 简介UEFI（统一可扩展固件接口）是一种规范，它定义了操作系统和平台固件之间的软件接口。本部分允许加载其他 UEFI 模块，以及对板载固件进行修改。为了检查固件的内容，应用修改和执行升级，可以使用 UEFITool 和其他实用工具。 11.2 驱动列表根据固件不同、可能需要不同的驱动程序。加载不兼容的驱动程序可能会导致无法启动系统，甚至导致固件永久性损坏。OpenCore 目前对以下 UEFI 驱动提供支持。 AudioDxe* — UEFI 固件中的 HDA 音频驱动程序，适用于大多数 Intel 和其他一些模拟音频控制器。参考 acidanthera/bugtracker#740 来了解 AudioDxe 的已知问题。 btrfs_x64 — 开源 BTRFS 文件系统驱动程序，需要从一个文件系统启动 OpenLinuxBoot，该文件系统在 Linux 非常常用。 BiosVideo* — 基于 VESA 和传统 BIOS 接口实现图形输出协议的 CSM 视频驱动程序。用于支持脆弱 GOP 的 UEFI 固件（例如，低分辨率）。需要重新连接图形连接。包含在 OpenDuet 中，开箱即用。 CrScreenshotDxe* — 截图驱动。启用后，按下 F10 将能够截图并保存在 EFI 分区根目录下。接受可选的驱动参数 --enable-mouse-click，以便在鼠标点击时额外地进行截图。(建议只在按键会阻止特定的屏幕截图时启用该选项，并在使用后再次禁用它)。该驱动基于 Nikolaj Schlej 修改的 LongSoft 开发的 CrScreenshotDxe。 EnableGop&#123;Direct&#125;* — 早期测试版的固件嵌入驱动程序在 MacPro5,1 上提供预开放核心非原生 GPU 支持。安装说明可在 OpenCore 发布的压缩文件的 Utilities/EnableGop目录中找到–请谨慎操作。 ext4_x64 — 开源 EXT4 文件系统驱动程序，需要用 OpenLinuxBoot 从 Linux 最常用的文件系统启动。 HfsPlus — Apple 固件中常见的具有 Bless 支持的专有 HFS 文件系统驱动程序。对于 Sandy Bridge 和更早的 CPU，由于这些 CPU 缺少 RDRAND 指令支持，应使用 HfsPlusLegacy 驱动程序。 HiiDatabase* — 来自 MdeModulePkg 的 HII 服务驱动。Ivy Bridge 及其以后的大多数固件中都已内置此驱动程序。某些带有 GUI 的应用程序（例如 UEFI Shell）可能需要此驱动程序才能正常工作。 EnhancedFatDxe — 来自 FatPkg 的 FAT 文件系统驱动程序。这个驱动程序已经被嵌入到所有 UEFI 固件中，无法为 OpenCore 使用。众所周知，许多固件的 FAT 支持实现都有错误，导致在尝试写操作时损坏文件系统。如果在引导过程中需要写入 EFI 分区，则可能需要将此驱动程序嵌入固件中。 NvmExpressDxe* — 来自MdeModulePkg 的 NVMe 驱动程序。从 Broadwell 开始的大多数固件都包含此驱动程序。对于 Haswell 以及更早的固件，如果安装了 NVMe SSD 驱动器，则将其嵌入固件中可能会更理想。 OpenCanopy* — OpenCore 插件之一，用于实现图形引导界面。 OpenRuntime* — 实现 OC_FIRMWARE_RUNTIME 协议的 OpenCore 插件。 OpenLinuxBoot* — 实现 OC_BOOT_ENTRY_PROTOCOL 的 OpenCore 插件，允许直接检测和从 OpenCore 启动 Linux 发行版，无需通过 GRUB 进行链式加载。 OpenNtfsDxe* — New Technologies File System (NTFS) read-only 驱动程序。NTFS 是基于 Windows NT 的 Microsoft Windows 版本的主要文件系统。 OpenUsbKbDxe* — USB 键盘驱动，在自定义 USB 键盘驱动程序的基础上新增了对 AppleKeyMapAggregator 协议的支持。这是内置的 KeySupport 的等效替代方案。根据固件不同，效果可能会更好或者更糟。 OpenPartitionDxe* — 支持 Apple 分区方案的分区管理驱动程序。此驱动程序可用于支持加载较旧的 DMG 恢复，例如使用 Apple 分区方案的 macOS 10.9，或用于加载使用 Apple 分区方案创建的其他 macOS 安装程序（使用 GPT 创建 macOS 安装程序可以避免这样做）。OpenDuet 已经包含了这个驱动程序。 OpenVariableRuntimeDxe* — OpenCore 插件（11.9 节的 OpenVariableRuntimeDxe）提供模拟 NVRAM 支持。OpenDuet 已经包含了这个驱动程序。 Ps2KeyboardDxe* — 从 MdeModulePkg 提取出来的 PS/2 键盘驱动。OpenDuetPkg 和一些固件可能不包括这个驱动，但对于 PS/2 键盘来说该驱动是必须的。注意，和 OpenUsbKbDxe 不同，该驱动不提供对 AppleKeyMapAggregator 的支持、因此需要启用 KeySupport 这个 Quirk。 Ps2MouseDxe* — 从 MdeModulePkg 提取出来的 PS/2 鼠标驱动。一些非常老旧的笔记本的固件中可能不包含该驱动，但是这些笔记本需要依赖该驱动才能在引导界面使用触控板。 OpenHfsPlus* — 支持 Bles s的 HFS 文件系统驱动。这个驱动是闭源的 HfsPlus 驱动的替代品，该驱动通常在苹果固件中发现。虽然功能完善，但是启动速度比 HFSPlus 慢三倍，并且尚未经过安全审核。 ResetNvramEntry* — 实现 OC_BOOT_ENTRY_PROTOCOL 的 OpenCore 插件，在启动选择器中添加了一个可配置的 Reset NVRAM 项。 ToggleSipEntry* — 实现 OC_BOOT_ENTRY_PROTOCOL 的 OpenCore 插件，在启动选择器菜单中添加了一个可配置的 Toggle SIP 项目到启动选择器菜单中。(译者注：这个插件用于关闭SIP) UsbMouseDxe* — 从 MdeModulePkg 提取出来的 USB 鼠标驱动。一般只有虚拟机（如 OVMF）的固件中可能不包含该驱动，这些虚拟机需要依赖该驱动才能在引导界面使用鼠标。 XhciDxe* — 来自 MdeModulePkg 的 XHCI USB controller 驱动程序。从 Sandy Bridge 开始的大多数固件中都包含此驱动程序。在较早的固件或旧系统可以用于支持外部 USB 3.0 PCI 卡。 标有 * 的驱动程序是 OpenCore 附带的。如果要从 UDK（EDK II）编译驱动程序，请使用编译 OpenCore 的相同命令，但要注意选择相应的软件包： 11.3 工具与应用程序一些不依赖 OpenCore 的工具可以帮助调试固件和硬件。下面列出了一些已知的工具。虽然有些工具可以从 OpenCore 启动，但大部分工具都应该直接或从 OpenCoreShell 中单独运行。 要启动到 OpenShell 或任何其他工具，直接将 OpenShell.efi 保存在 FAT32 分区中的 EFI/BOOT/BOOTX64.EFI 下。此时分区方案是 GPT 还是 MBR 并不重要。 这种方法在 Mac 和其他计算机上都可以使用。还有一种只能在 Mac 上的 HFS+ 或 APFS 分区上使用的方法： Listing 3: Bless 工具 注 1：你可能需要将 /System/Library/CoreServices/BridgeVersion.bin 拷贝到 /Volumes/VOLNAME/DIR。 注 2：为了能够使用 bless，你可能需要 禁用系统完整性保护。 注 3：为了能够正常启动，你可能需要 禁用 Apple 安全启动（如果有的话）。 一些已知的 UEFI 工具（内置工具已用 * 标出）： BootKicker* — 进入 Apple 的 BootPicker 菜单（仅 Mac 同款显卡才可以使用）。 ChipTune* — 测试 BeepGen 协议，生成不同频率和长度的音频信号。 CleanNvram* — 重置 NVRAM，以一个单独的工具呈现。 CsrUtil* — 简单实现 Apple csrutil 的 SIP-related 相关功能。 CsrUtil* — 渲染内置渲染器提供的控制台字体页面。 FontTester* — 用一个 简单的场景 测试 GraphicOutput 协议。 KeyTester* — 在 SimpleText 模式下测试键盘输入。 MemTest86 — 内存测试工具。 OpenControl* — 解锁和锁定 NVRAM 保护，以便其他工具在从 OpenCore 启动时能够获得完整的 NVRAM 访问权。 OpenCore Shell* — 由 OpenCore 配置的 UEFI Shell，与绝大部分固件兼容。 PavpProvision — 执行 EPID 配置（需要配置证书数据）。 ResetSystem* — 用于执行系统重置的实用程序。以重置类型作为参数：ColdReset, Firmware, WarmReset, Shutdown。默认为 ColdReset。 RtcRw* — 读取和写入 RTC (CMOS) 存储器的使用程序。 ControlMsrE2* — 检查 CFG Lock（MSR 0xE2 写保护）在所有 CPU 核心之间的一致性，并在选定的平台上改变此类隐藏选项。 TpmInfo* — 检查平台上的 Intel PTT（Platform Trust Technology）能力，如果启用，允许使用 fTPM 2.0。该工具不检查 fTPM 2.0 是否真的被启用。 11.4 OpenCanopyOpenCanopy 是一个 OpenCore 的图形化界面接口，基于 OpenCorePkg OcBootManagementLib 实现，提供与现有的文字模式类似的功能。当 PickerMode 设置为 External 时启用。 OpenCanopy 所需的图象资源位于 Resources 目录下，一些简单的资源（字体和图标）可以在 OcBinaryData 仓库 中获取。可以在网络上找到自定义图标（例如： 这里 和 这里）。 OpenCanopy 为 PickerAttributes 提供了全面的支持，并提供了一套可配置的内置图标集。默认选择的图标由 DefaultBackgroundColor 变量决定，当该变量的值定义为浅灰时，则使用 Old 前缀的图标，定义为其他颜色时则使用没有前缀名的图标。 预定义的图标放在 \\EFI\\OC\\Resources\\Image 目录下。下面提供了所支持的图标的完整列表（.icns 格式）。可选图标如未提供，将使用最接近的可用的图标。外置设备的条目将使用 Ext 前缀的图标（如 OldExtHardDrive.icns）。 注：以下标注的所有尺寸均为 1x 缩放级别的标准尺寸，其他缩放级别的尺寸须作相应调整。 Cursor — 鼠标光标（必需，最大尺寸 144x144）。 Selected — 选定的项目（必需，144x144）。 Selector — 选择项目（必需，最大尺寸 144x40）。 Left — 向左滚动（必需，最大尺寸 40x40）。 Right — 向右滚动（必需，最大尺寸 40x40）。 HardDrive — 通用的 OS（必需，128x128）。 Background — 居中的背景图片。 Apple — Apple OS (128x128)。 AppleRecv — Apple Recovery OS (128x128)。 AppleTM — Apple Time Machine (128x128)。 Windows — Windows (128x128)。 Other — 自定义条目（见 Entries，128x128）。 ResetNVRAM — 重置 NVRAM 工具或系统动作（128x128）。 Shell — 具有 UEFI Shell 名称的条目（如 OpenShell，128x128）。 Tool — 其他工具（128x128）。 预定义的标签放在 \\EFI\\OC\\Resources\\Label 目录下。每个标签都有 .lbl 或 .l2x 的后缀，以代表缩放级别。完整的标签列表如下所示。所有标签都是必需的。 EFIBoot — 通用的 OS。 Apple — Apple OS。 AppleRecv — Apple Recovery OS。 AppleTM — Apple Time Machine。 Windows — Windows。 Other — 自定义条目（见 Entries）。 ResetNVRAM — 重置 NVRAM 工具或系统动作。 SIPDisabled — 切换 SIP 工具，禁用 SIP。 SIPEnabled — 切换 SIP 工具，启用 SIP。 Shell — 具有 UEFI Shell 名称的条目（如 OpenShell）。 Tool — 其他工具。 注：所有标签的高度必须为 12px，宽度不限。 可以通过附带的实用程序来生成标签和图标：disklabel 和 icnspack。字体为 12pt 的 Helvetica 乘以比例因子。 字体格式对应于 AngelCode binary BMF。虽然有很多工具可以生成字体文件，但目前还是建议使用 dpFontBaker 来生成位图字体（用 CoreText 达到最佳效果），并使用 fonverter 将其导出为二进制格式。 11.5 OpenRuntimeOpenRuntime 是一个 OpenCore 的插件，提供了对 OC_FIRMWARE_RUNTIME 协议的实现。该协议对 OpenCore 的部分功能提供了支持，而这部分功能由于需要 Runtime（如操作系统）中运行、因此无法内置在 OpenCore 中。该协议提供了包括但不限于如下功能： NVRAM 命名空间，允许隔离操作系统对所选变量的访问（如 RequestBootVarRouting 或 ProtectSecureBoot）。 只读和只写的 NVRAM 变量，增强了 OpenCore、Lilu 以及 Lilu 插件的安全性，比如 VirtualSMC，实现了 AuthRestart 支持。 NVRAM 隔离，能够保护所有变量避免被不信任的操作系统写入（如 DisableVariableWrite）。 UEFI Runtime Services 内存保护管理，以避开只读映射的问题（如 EnableWriteUnprotector）。 11.6 OpenLinuxBootOpenLinuxBoot 是一个实现 OC_BOOT_ENTRY_PROTOCOL 的 OpenCore 插件。它的目的是自动检测和启动大多数 Linux 发行版，而不需要额外的配置。 使用方法如下： 将 OpenLinuxBoot.efi 和典型的（见下文）ext4_x64.efi 添加到 config.plist 的 Drivers 部分。 确保 RequestBootVarRouting 和 LauncherOption 在 config.plist 中被启用；同时建议启用 HideAuxiliary，以隐藏旧的 Linux 内核，除非需要（它们被添加为辅助项，因此可以通过在 OpenCore 启动菜单按下空格键来显示）。 如果之前没有安装 Linux，则按正常程序安装，OpenLinuxBoot 不参与这一阶段。 重新启动到 OpenCore：已安装的 Linux 发行版应该会出现，并在选择时直接从 OpenCore 启动，它无需通过 GRUB 进行链式加载。 如果 OpenCore 已经手动设置为引导 Linux，例如通过 BlessOverride 或 Entries，则可以删除这些设置，以解决 Linux 发行版在引导菜单中显示两次。 我们建议用默认的引导程序来安装 Linux，尽管在通过 OpenLinuxBoot 启动的时候不会主动使用它。这是因为 OpenLinuxBoot 必须检测要使用的正确的内核选项，并通过查找默认引导程序留下的文件来实现。如果没有安装引导程序（或者找不到这些选项），启动仍然是可能的，但在 OpenLinuxBoot 试图启动发行版之前，必须手动指定正确的引导选项。 OpenLinuxBoot 通常需要固件中没有的文件系统驱动，比如 EXT4 和 BTRFS 驱动。这些驱动可以从外部来源获得。在基本情况下测试的驱动程序可以从 OcBinaryData 下载。请注意，这些驱动没有经过所有场景的可靠性测试，也没有经过防篡改测试，因此它们可能存在潜在的安全或数据丢失风险。 大多数 Linux 发行版需要 ext4_x64 驱动，少数可能需要 btrfs_x64 驱动，少数可能不需要额外的文件系统驱动：这取决于所安装的发行版启动分区的文件系统，以及系统的固件已经支持哪些文件系统。目前不支持 LVM，这是因为人们认为目前没有独立的 UEFI LVM 文件系统驱动。 请注意 SyncRuntimePermissions Quirk，由于 2017 年后发布的一些固件的错误，可能需要设置它以避免 Linux 内核的早期启动失败（通常以黑屏停止）。当存在并且没有被这个 Quirk 缓解时，这将影响通过 OpenCore 的启动，无论是否有 OpenLinuxBoot。 安装 OpenLinuxBoot 后，建议将启动（或尝试启动）特定发行版时 OpenCore 调试日志中显示的选项与使用 shell 命令 cat /proc/cmdline 启动同一发行版时看到的选项进行比较。一般来说（为了运行中的发行版的安全）这些选项应该匹配，如果不匹配，建议使用下面的驱动参数（特别是 LINUX_BOOT_ADD_RO，LINUX_BOOT_ADD_RW，autoopts:&#123;PARTUUID&#125; 和 autoopts）来修改所需的选项。但是请注意，以下差异是正常的，不需要修复。 如果默认的引导程序是 GRUB，那么 OpenLinuxBoot 生成的选项将不包含 BOOT_IMAGE=...，而 GRUB 的选项则不包含 initrd=...。 OpenLinuxBoot 使用 PARTUUID 而不是文件系统的 UUID 来识别 initrd 的位置，这是设计上的问题，因为 UEFI 文件系统驱动不提供 Linux 文件系统的 UUID 值。 不太重要的图形交接选项（比如下面 autoopts 中讨论的 Ubuntu 例子）不会完全匹配，这并不重要，只要发行版能够成功启动。 如果使用具有安全启动功能的 OpenLinuxBoot，用户可能希望使用 OpenCore 实用程序中包含的 shim-to-cert.tool，它可以用来提取直接启动发行版内核所需的公钥，就像使用 OpenCore 与 OpenLinuxBoot 时那样，而不是通过 GRUB shim。对于非 GRUB 发行版，所需的公钥必须通过用户研究找到。 11.6.1 Configuration在大多数情况下，默认的参数值应该可以很好地工作，但如果需要，可以在 UEFI/Drivers/Arguments 中为驱动指定以下选项： flags - Default：所有的标志都被设置了，除了以下情况： LINUX_BOOT_ADD_RW LINUX_BOOT_LOG_VERBOSE LINUX_BOOT_ADD_DEBUG_INFO 可用的 flags 有： 0x00000001 (bit 0) — LINUX_BOOT_SCAN_ESP，允许扫描EFI系统分区的条目。 0x00000002 (bit 1) — LINUX_BOOT_SCAN_XBOOTLDR，允许扫描扩展启动加载器分区的条目。 0x00000004 (bit 2) — LINUX_BOOT_SCAN_LINUX_ROOT，允许扫描Linux根文件系统的条目。 0x00000008 (bit 3) — LINUX_BOOT_SCAN_LINUX_DATA，允许扫描Linux数据文件系统的条目。 0x00000080 (bit 7) — LINUX_BOOT_SCAN_OTHER，允许扫描没有被上述任何一个匹配的文件系统上的条目。 以下说明适用于上述所有选项。 注 1：苹果文件系统 APFS 和 HFS 从不被扫描。 注 2：无论上述标志如何，在它被 OpenLinuxBoot 或任何其他 OC_BOOT_ENTRY_PROTOCOL 驱动程序看到之前。文件系统必须首先被 Misc/Security/ScanPolicy 所允许。 注 3：建议在 OpenLinuxBoot flags 和 Misc/Security/ScanPolicy 中启用扫描 LINUX_ROOT 和 LINUX_DATA，以确保检测到所有有效的 Linux 安装，因为 Linux 启动文件系统往往被标记为 LINUX_DATA。 0x00000100 (bit 8) - LINUX_BOOT_ALLOW_AUTODETECT, 如果设置允许在没有找到加载器/条目文件时，自动检测和链接 vmlinuz* 和 init* ramdisk 文件。 0x00000200 (bit 9) - LINUX_BOOT_USE_LATEST，当 OpenLinuxBoot 生成的 Linux 条目被设为 OpenCore 的默认启动条目时，在安装新版本时自动切换到最新内核。 设置此选项后，内部菜单条目 id 将在同一 Linux 安装的内核版本之间共享。Linux 启动选项总是按最高的内核版本排序，所以这意味着在设置了这个选项后，同一安装的最新内核 版本总是显示为默认版本。 注：推荐在所有系统上使用该选项。 0x00000400 (bit 10) - LINUX_BOOT_ADD_RO，这个选项只适用于自动检测的 Linux（即不适用 BLSpec 或 Fedora 风格的发行版，它们有 /loader/entries/*.conf 文件）。一些发行版在加载时运行文件系统检查，要求根文件系统最初通过 ro kernel选项被挂载为只读， 这就要求在自动检测的选项中加入这个选项。在自动检测的发行版上设置这个选项； 在不需要这个选项的发行版上， 应该是无害的，但会稍微减慢启动时间（由于要求重新挂载为读写）。当有多个发行版，并且只需要为特定的发行版指定这个选项时，使用 autoopts:&#123;PARTUUID&#125;+=ro 来手动添加需要的选项，而不是使用这个标志。 0x00000800 (bit 11) - LINUX_BOOT_ADD_RW，和 LINUX_BOOT_ADD_RO 一样， 这个选项只适用于自动检测的Linux。大多数发行版不需要这个选项（它们通常要求在检测到的启动选项中加入ro 或 nothing），但在一些Arch-derived 发行版上需要，例如：EndeavourOS。 当有多个发行版，并且只需要为特定的发行版指定这个选项时，使用 autoopts:&#123;PARTUUID&#125;+=rw 在需要的地方手动添加这个选项，而不是使用这个标志。如果这个选项和 LINUX_BOOT_ADD_RO 都被指定，那么只有这个选项被应用， LINUX_BOOT_ADD_RO 被忽略。 0x00002000 (bit 13) - LINUX_BOOT_ALLOW_CONF_AUTO_ROOT，在某些 BootLoaderSpecByDefault 与 ostree 相结合的情况下， /loader/entries/*.conf 文件没有指定所需的 root=...kernel 选项（它是由 GRUB 加入的）。如果这个位被设置，并且检测到这种情况，那么就自动添加这个选项。 (例如：Endless OS)。 0x00004000 (bit 14) - LINUX_BOOT_LOG_VERBOSE，添加额外的调试日志信息，关于扫描 Linux 启动项时遇到的文件和添加的自动检测选项。 0x00008000 (bit 15) - LINUX_BOOT_ADD_DEBUG_INFO，在每个生成的条目名称中添加一个人类可读的文件系统类型，然后是分区的唯一分区 uuid 的前八个字符。当一个系统上有多个 Linux 安装时，可以帮助调试由驱动生成的条目的来源。 Flag 值可以用以 0x 开头的十六进制或十进制来指定，例如 flags=0x80 或 flags=128。也可以指定添加或删除的 flag，使用 flags+=0xC000 来添加所有调试选项或 flags-=0x400 来删除 LINUX_BOOT_ADD_RO 选项。 autoopts:{PARTUUID}[+]=”{options}” - Default: 未设置。 允许手动指定内核选项，仅在自动检测模式下用于给定的分区。将 &#123;PARTUUID&#125; 替换为内核所在的特定分区 UUID（在正常布局中，包含 /boot 的分区），例如： autoopts:11223344-5566-7788-99aabbccddeeff00+=&quot;vt.handoff=7&quot;。如果用 += 指定，那么这些选项是在任何自动检测的选项之外使用的，如果用 = 指定，则用它们代替。仅用于自动检测的 Linux（这里指定的值永远不会用于从 /loader/entries/*.conf 文件）。 注： 这里要指定的 PARTUUID 值通常与 Linux 内核启动选项中 root=PARTUUID=... 的 PARTUUID 相同（使用 cat/proc/cmdline 查看）。另外，对于更高级的情况，可以使用 Linux mount 命令检查发行版的分区是如何挂载的，然后通过检查 ls -l /dev/disk/by-partuuid 的输出来找出相关挂载分区的 partuuid。 autoopts[+]=”{options}” - Default: 没有指定。 允许手动指定在自动检测模式下使用的内核选项。另一种格式 autoopts:&#123;PARTUUID&#125; 更适用于有多个发行版的情况，但不需要 PARTUUID 的 autoopts 可能对只有一个发行版更方便。如果用 += 指定，那么这些选项将在自动检测的选项之外使用，如果用 = 指定，它们将被替代使用。只用于自动检测的 Linux（这里指定的值永远不会用于从 /loader/entries/*.conf 文件创建的条目）。作为使用范例，可以在 Ubuntu 和相关发行版上使用 += 格式添加 vt.handoff 选项，比如 autoopts+=&quot;vt.handoff=7&quot; 或 autoopts+=&quot;vt.handoff=3&quot;（通过发行版的默认引导程序启动时检查 cat /proc/cmdline ），以便在自动检测的 GRUB 默认值中添加 vt.handoff 选项，并避免在发行版闪屏前显示闪光的文本。 11.6.2 其他信息OpenLinuxBoot 可以检测到根据 Boot Loader Specification 或密切相关的 systemd BootLoaderSpecByDefault 创建的 loader/entries/*.conf 文件。 前者是针对 systemd-boot 的，被 Arch Linux 使用，后者适用于大多数与 Fedora 相关的发行版，包括 Fedora 本身、 RHEL 和衍生版。 如果上述文件不存在，OpenLinuxBoot 可以自动检测并直接启动 &#123;boot&#125;/vmlinuz* 内核文件。它自动将这些文件（基于文件名中的内核版本）链接到它们相关的 &#123;boot&#125;/init*ramdisk 文件。 这适用于大多数与 Debian 有关的发行版，包括 Debian 本身，Ubuntu 和衍生版。 当在 /boot 作为根文件系统的一部分进行自动检测时， OpenLinuxBoot会在 /etc/default/grub 中寻找内核启动选项，在 /etc/os-release 中寻找发行版的名称。当在一个独立的启动分区中自动检测时（即当 /boot 有自己的挂载点）， OpenLinuxBoot 不能自动检测内核参数，除了 initrd=...， 所有的内核参数都必须用 autoopts=... 或 autoopts:&#123;partuuid&#125;=... 指定（这些选项的 += 变体不能工作，因为它们只是增加了额外的参数）。 BootLoaderSpecByDefault（但不是纯粹的 Boot Loader Specification）可以扩展 *.conf 文件中的 GRUB 变量，这在某些发行版中被实际使用 ，如 CentOS。 为了正确处理这种情况 ，当检测到这种情况时，OpenLinuxBoot 会从 &#123;boot&#125;/grub2/grubenv 中提取所有变量，以及从 &#123;boot&#125;/grub2/grub.cfg 中提取任何无条件设置的变量，然后在 *.conf 文件条目中展开这些变量。 目前唯一支持的启动 Linux 内核的方法是依靠它们被 EFISTUB 编译。 这几乎适用于所有现代发行版，尤其是那些使用systemd 的发行版。 请注意，大多数现代发行版都使用 systemd 作为其系统管理器，尽管大多数都不使用 systemd-boot 作为其引导程序。 systemd-boot 用户（可能几乎全是 Arch Linux 用户） 应该注意， OpenLinuxBoot 不支持 systemd-boot 特有的 Boot Loader Interface；因此必须使用 efibootmgr 而不是 bootctl 来与启动菜单进行任何低级的 Linux 命令行交互。 11.7 其他引导进入协议驱动程序除了 OpenLinuxBoot 插件外， 还提供了以下 OC_BOOT_ENTRY_PROTOCOL 插件，以在 OpenCore 启动选择器中添加可选的、可配置的启动项。 11.7.1 ResetNvramEntry增加了一个菜单项，可以重置 NVRAM 并立即重新启动。另外还增加了对热键 CMD+OPT+P+R 的支持，以执行同样的操作。请注意，在某些固件和驱动程序的组合中，必须配置 TakeoffDelay 选项，以便可靠地检测这个和其他内置热键。 注 1：众所周知，一些联想笔记本电脑有一个固件错误，这使得它们在执行 NVRAM 重置后无法启动。详情请参考 acidanthera/bugtracker#995。 注 2：如果 LauncherOption 被设置为 Full 或 Short，那么 OpenCore 的启动项将受到保护。重置 NVRAM 通常会清除任何未通过 BlessOverride 指定的其他启动选项，例如将 Linux 安装到自定义位置且不使用 OpenLinuxBoot 驱动程序，或用户指定的 UEFI 启动菜单条目。为了获得不删除其他启动选项的重置 NVRAM 功能，可以使用 --preserve-boot 选项（不过请看指定的警告）。 以下配置选项可以在该驱动程序的 Arguments 属性指定： --preserve-boot，Boolean flag，如果存在则启用。如果启用，在 NVRAM 重置期间，BIOS 启动项不会被清除。 这个选项应该谨慎使用，因为一些启动问题可以通过清除这些条目来解决。 --apple ，Boolean flag，如果存在则启用。仅在苹果固件上， 这将执行一个系统 NVRAM 重置。这可能会导致额外的、理想的操作，如 NVRAM 垃圾收集。这可以通过设置 ResetNVRam NVRAM 变量来实现。在可用的情况下，这与在本机启动时按 CMD+OPT+P+R 的效果相同，不过要注意的是，如果从菜单项中访问，将只听到一个启动鸣叫。 注 1：由于使用系统 NVRAM 重置， 该选项与 --preserve-boot 选项不兼容，将覆盖它，因此所有的 BIOS 启动项将被删除。 注 2：由于使用系统 NVRAM 重置，OpenCore 启动选项无法保留，必须在本地启动选择器中重新选择 OpenCore 或重新注入。 注 3：在非苹果硬件上，该选项仍将设置该变量，但该变量将不会被固件识别，也不会发生 NVRAM 重置。 11.7.2 ToggleSipEntry在 OpenCore 启动选取器中提供一个启动条目，用于启用和禁用系统完整性保护（SIP）。 当 macOS 运行时，SIP 涉及多个配置的软件保护系统，然而所有关于启用这些保护系统的信息都存储在单一的 Apple NVRAM 变量 csr-active-config 中。只要这个变量在 macOS 启动前被设置，SIP 就会被完全配置好，所以使用这个启动选项（或以任何其他方式，在 macOS 启动前）设置这个变量，其最终结果与在 macOS Recovery 中使用 csrutil 命令配置 SIP 完全相同。 csr-active-config 将在 0 和用户指定的或默认的禁用值之间切换。 驱动程序的选项应该在 Driver entry 的 Arguments 部分指定为纯文本值，用空格隔开。可用的选项有： --show-csr — Boolean flag，如果存在则启用。 如果启用，在启动项名称中显示当前 csr-active-config 的十六进制值。当与 PickerAttributes 中的 OC_ATTR_USE_GENERIC_LABEL_IMAGE 结合使用时，这个选项在 OpenCanopy 中不起作用。 数值 —默认值为 0x27F。 指定用于禁用 SIP 的 csr-active-config 值。可以指定为十六进制，以 0x 开头，也可以指定为十进制。更多信息参见下面的 注 2。 注 1：建议不要在禁用 SIP 的情况下运行 macOS。使用这个启动选项可以在真正需要的时候更容易快速禁用 SIP 保护，之后应该重新启用。注 2：用这个启动项禁用 SIP 的默认值是 0x27F。作为比较，csrutil disable 在 macOS Big Sur 和 Monterey 上没有其他参数，它设置了 0x7F，在 Catalina 上设置了 0x77。 OpenCore 的默认值 0x27F 是 Big Sur 和 Monterey 值的一个变体， 选择方法如下： CSR_ALLOW_UNAPPROVED_KEXTS（0x200） 被包含在默认值中，因为在你需要禁用 SIP 的情况下，它通常是有用的，能够在系统偏好中安装无符号的 kexts 而无需手动批准。 CSR_ALLOW_UNAUTHENTICATED_ROOT（0x800） 不包括在默认值中，因为使用它时很容易无意中破坏操作系统的密封性，阻止增量的 OTA 更新。 如果在 csr-active-config 中指定了后来的操作系统不支持的位（例如在 Catalina 上指定 0x7F），那么 csrutil status 将报告 SIP 有一个非标准的值，然而保护功能将是一样的。（译者注：就是 SIP 没有被关闭） 11.8 AudioDxeUEFI固件中的高清晰度音频（HDA）支持驱动程序，适用于大多数英特尔和其他一些模拟音频控制器。注意： AudioDxe 是一个阶段性的驱动程序，参考acidanthera/bugtracker#740了解已知问题。 11.8.1 Configuration大多数 UEFI 音频配置是通过 UEFI 音频属性部分处理的，但此外可能需要以下一些配置选项，以允许 AudioDxe 正确驱动某些设备。在 UEFI/Drivers 部分的驱动程序的 Arguments 属性中，所有的选项都被指定为文本字符串，如果需要一个以上的选项，则用空格分隔。 --codec-setup-delay，整数值，默认为 0。等待所有组件完全打开的时间，以毫秒为单位，在驱动连接阶段应用于每个编解码器。在大多数系统中，这应该是不需要的，如果需要任何音频设置延迟，使用 Audio 部分的 SetupDelay 可以实现更快的启动。如果需要，可能需要一秒钟的值。 --force-codec，整数值，没有默认值。强制使用一个音频编解码器，这个值应该等于音频部分的 AudioCodec。可以导致更快的启动，特别是与 --force-device 一起使用时。 --force-device，字符串值，无默认值。当这个选项存在并且有一个值（例如：--force-device=PciRoot(0x0)/Pci(0x1f,0x3)），它强制 AudioDxe 连接到指定的 PCI 设备，即使该设备不报告自己是一个 HDA 音频控制器。在驱动连接过程中，AudioDxe 自动提供所有可用的 HDA 控制器的所有支持的编解码器的音频服务。然而，如果相关的控制器错误地报告了它的身份（通常，它将报告自己是一个传统的音频设备，而不是一个 HDA 控制器），那么可能需要这个参数。如果音频设备可以在 macOS 中工作，但没有显示出被 AudioDxe 检测到的迹象（例如，当在 DisplayLevel 中包含 DEBUG_INFO 并使用 AudioDxe 的 DEBUG 构建时，在 OpenCore 日志的 Connecting drivers… 阶段没有显示控制器和编解码器布局信息）。 --gpio-setup，如果没有提供参数，默认值为 0（禁用 GPIO 设置）或者默认值为 7（启用所有 GPIO 设置阶段）。 可用的值如下，可以通过添加来组合： 0x00000001 (bit 0) - GPIO_SETUP_STAGE_DATA，在指定的引脚上设置 GPIO 引脚数据高电平。例如在 MacBookPro10,2 和 MacPro5,1 上需要。 0x00000002 (bit 1) - GPIO_SETUP_STAGE_DIRECTION，设置 GPIO 数据方向为指定引脚上的输出。例如在 MacPro5,1 上需要。 0x00000004 (bit 2) - GPIO_SETUP_STAGE_ENABLE，启用指定的 GPIO 引脚。例如在 MacPro5,1 上需要。 如果音频似乎在正确的编解码器上 “播放”，例如根据调试日志，但在任何通道上都听不到声音，建议在 AudioDxe 驱动参数中使用 --gpio-setup（不包含值）。如果没有指定值，所有的阶段都将被启用（相当于指定 7）。如果这能产生声音，就有可能尝试更少的 bit，例如 --gpio-setup=1，--gpio-setup=3，以发现哪些阶段是实际需要的。 注意： 这个选项的值 7（启用所有标志），例如 MacPro5,1 所要求的那样，与大多数系统兼容，但已知在少数其他系统上会引起声音问题（在新的声音开始之前不允许完成以前的声音），因此这个选项默认不启用。 --gpio-pins，默认：0，自动检测。指定哪些 GPIO 引脚应该由 --gpio-setup 来操作。 这是一个位掩码，可能的值从 0x0 到 0xFF。可用的最大值取决于正在使用的编解码器的音频输出功能组上的可用引脚数量，例如，如果有两个 GPIO 引脚，它就是 0x3（最低的两个位），如果有三个引脚，就是 0x7 ，等等。 当 --gpio-setup 被启用时（即非零），那么 0 是 --gpio-pins 的特殊值，意味着引脚掩码将根据指定编解码器上报告的 GPIO 引脚数量自动生成（参见 AudioCodec）。例如，如果编解码器的音频输出功能组报告了 4 个 GPIO 引脚，将使用 0xF 的掩码。 使用中的值可以在调试日志中看到，比如一行：HDA: GPIO setup on pins 0x0F - Success。 驱动程序参数的值可以用以 0x 开头的十六进制或十进制来指定，例如 --gpio-pins=0x12 或 --gpio-pins=18。 --restore-nosnoop，布尔值，如果存在则启用。AudioDxe 清除了 Intel HDA No Snoop Enable（NSNPEN）bit。在某些系统上，这个改变必须在退出时被逆转，以避免在Windows 或 Linux 中破坏声音。如果是这样， 这个标志应该被添加到 AudioDxe 驱动参数中。 默认情况下不启用，因为恢复这个 flag 会使声音在其他一些系统的 macOS 中无法工作。 --use-conn-none，布尔值，如果存在就启用。在一些声卡上，启用这个选项将启用额外的可用音频通道（例如，一对扬声器的低音或高音，在没有它的情况下只能找到一个）。 注：启用这个选项可能会增加可用的通道，在这种情况下，AudioOutMask 的任何自定义设置可能需要改变以匹配新的通道列表。 11.9 OpenVariableRuntimeDxe提供内存中模拟的 NVRAM 实现。这对于脆弱的设备（例如：MacPro5,1，请参阅此论坛帖子中链接的讨论）或不存在兼容的 NVRAM 实现时非常有用。此驱动程序默认包含在 OpenDuet 中。 除了安装模拟 NVRAM 之外，此驱动程序还安装了 OpenCore compatible 协议，可实现以下功能： NVRAM 的值在启动时从 NVRAM/nvram.plist （或者从 NVRAM/nvram.fallback（如果它存在并且 NVRAM/nvram.plist 缺失））加载。 ResetNvramEntry 驱动程序添加的 Reset NVRAM 选项会删除上述文件，而不影响底层 NVRAM。 CTRL+Enter 在 OpenCore bootpicker 更新或创建 NVRAM/nvram.plist。 此驱动程序的推荐设置： 使用 LoadEarly=true 加载的 OpenVariableRuntimeDxe.efi。OpenDuet 用户不应该加载这个驱动程序，因为它已经包含在 OpenDuet 中。 在 OpenVariableRuntimeDxe.efi 之后指定的 OpenRuntime.efi （如果适用），也使用 LoadEarly=true 加载以正确操作 RequestBootVarRouting。 模拟 NVRAM 时无需 RequestBootVarRouting。但是如果你需要在真实和模拟的 NVRAM 之间切换，保留它可能会很方便。 在 OpenDuet 系统上无需 RequestBootVarRouting，因为没有 BIOS 管理的启动项需要保护，因此在 OpenDuet 上推荐的设置是 OpenRuntime.efi 的 LoadEarly=false 和 RequestBootVarRouting=false。 已填充 LegacySchema。 对于更简单的测试（允许任意测试变量），以及为了防止 macOS 更新所要求的变量发生变化，请使用 * 设置，如下面的注释所述。 为了提高安全性，如 OpenCore 的 sample .plist 文件所示，只用已知的必要键来填充部分。 ExposeSensitiveData 至少设置为 0x1 位，以使包含 OpenCore EFI 分区 UUID 的引导路径变量可用于 Launchd.command 脚本。 变量加载发生在 NVRAM 删除（和添加）阶段之前。除非启用 LegacyOverwrite ，否则它不会覆盖任何现有变量。必须在 LegacySchema 中指定允许使用 CTRL+Enter 加载和保存的变量。 为了允许在 macOS 中捕获和保存对 NVRAM 的更改，必须安装一个附加脚本。可以在 Utilities/LogoutHook/Launchd.command 中找到此类脚本的示例。 注 1：此驱动程序需要固件中的 FAT 写入支持，以及 OpenCore EFI 分区上有足够的可用空间，最多可保存三个 NVRAM 文件。 注 2：nvram.plist （和 nvram.fallback ，如果存在）文件必须具有 root plist dictionary 类型并包含两个字段： Version — plist integer，文件版本，必须设置为 1。 Add — plist dictionary，相当于 Add from config.plist。 注 3*：在设置 legacy NVRAM 时，可以方便地将 `设置为LegacySchema` 中以下三个 GUID 键的值： 36C28AB5-6566-4C50-9EBD-CBB920F83843 7C436110-AB2A-4BBB-A880-FE41995C9F82 8BE4DF61-93CA-11D2-AA0D-00E098032B8C 这使得 Launchd.command 保存的所有变量都可以保存到 nvram.plist，因此它允许保存所有任意用户测试变量（例如，由 sudo nvram foo=bar 设置）。使用此许可策略还可以防止未来需要从 macOS 更新设置传递到 macOS 安装程序阶段以使其成功的变量的任何更改。然而，一旦设置了模拟 NVRAM，只允许已知的严格要求的变量（例如 OpenCore 的示例 .plist 文件中所示）会更加安全。另请参阅以下有关从非保管文件加载 NVRAM 变量的整体安全性的警告。 警告从磁盘上的文件加载 NVRAM 可能很危险，因为它将未受保护的数据传递给固件变量服务。仅在固件未提供硬件 NVRAM 实现或固件中可用的 NVRAM 实现不兼容或危险脆弱（例如，在过度使用可能导致硬件变砖的状态下）时使用。 11.9.1 使用模拟 NVRAM 时管理 macOS 更新OpenCore 与 OpenVariableRuntimeDxe 相结合，如果该文件被用于启动 macOS Installer 启动项，则只使用一次已保存的 nvram.plist 文件。之后，已使用的设置将被移至 nvram.used，而来自 nvram.fallback 的 fallback 设置（如果有的话）将被使用。Launchd.command 总是将之前的 NVRAM 设置复制到 fallback 中，每次它都会保存新的设置。 此策略用于解决 Launchd.command 脚本未运行的限制，因此无法在 macOS 安装程序的第二次和后续重新启动期间保存 NVRAM 更改（特别是默认启动条目更改）。 简而言之，这种回退策略允许从现有 macOS（安装了 Launchd.command 脚本）中启动的最新 macOS 的完整或增量 OTA 更新，无需人工干预即可继续进行。 但是，对于完全安装，可以有不止一次完全重新启动回到 macOS 安装程序条目。在这种情况下，后备策略将从第二次重新启动开始失去对正确启动项（即 macOS 安装程序）的跟踪。同样，如果安装到当前默认引导分区以外的驱动器，安装程序完成后将不会自动选择它，就像使用非模拟 NVRAM 时一样。（这种行为仍然比没有回退策略更可取，在这种情况下，macOS 安装程序条目将在选择器菜单中不断重新创建，即使它不再存在）。 在上述两种情况下，建议使用以下设置，以便在安装程序过程中轻松手动控制选择哪个引导项： 设置 ShowPicker=true。 设置 Timeout=0。 设置 DisableWatchdog=true。 如果可能，请从启动菜单中没有其他挂起的 macOS 安装程序条目的情况开始（以避免可能混淆哪些是相关的）。 第一次重新启动应正确选择 macOS 安装程序。对于第二次和后续重新启动，如果 macOS 安装程序条目仍然存在，则应手动选择它（仅使用 Enter，而不是 CTRL+Enter）。一旦不再存在 macOS 安装程序条目，如果它是以前的引导默认值，则仍将自动选择新操作系统的条目。如果没有，则应手动选择它（此时，CTRL+Enter 是一个好主意，因为任何最终剩余的安装重新启动都将指向该条目）。 注意：当使用模拟 NVRAM 但不是从现有已安装的 macOS 中安装时（即从 macOS 恢复中或从安装 USB 安装时），请参阅此论坛 帖子（俄语）以获取其他选项。 11.10 属性列表1. APFSType: plist dictDescription: 配置 APFS 分区驱动，具体配置内容参见下文 APFS 属性部分。 2. AppleInputType: plist dictDescription: 配置 Apple 事件协议的重新实现，在下面的 AppleInput 属性部分中描述。 3. AudioType: plist dictDescription: 配置音频后端支持，具体配置如下文所述。 除非另有说明（例如 ResetTrafficClass），否则本节中的设置仅用于 UEFI 音频支持（例如 OpenCore 生成的引导蜂鸣音和音频辅助），与操作系统音频支持所需的任何配置（例如 AppleALC ）无关。 音频支持为上游协议提供了一种与所选硬件和音频资源交互的方式。所有音频资源应该保存在 \\EFI\\OC\\Resources\\Audio 目录。目前支持的音频文件格式为 MP3 和 WAVE PCM。虽然支持哪种音频流格式取决于驱动程序，但大多数常见的音频卡都支持 4410 或 48000H 的 16 位立体声。 音频文件的路径是由音频的类型、本地化语言和路径决定的。每个文件名看起来都类似于：[audio type]_[audio localisation]_[audio path].[audio ext]。对于没有本地化的文件，其文件名不包含语言代码，看起来类似于：[audio type]_[audio path].[audio ext]。其中音频扩展名为 mp3 或 wav。 OpenCore 音频文件的音频类型可以是 OCEFIAudio，macOS 引导程序的音频文件的音频类型可以是 AXEFIAudio。 音频本地化语言由两个字母的语言代码表示（如 en），中文、西班牙语和葡萄牙语除外。具体请看 APPLE_VOICE_OVER_LANGUAGE_CODE 的定义来了解所有支持的本地化列表。 音频路径是对应于文件标识符的基本文件名。macOS 引导程序的音频路径参考 APPLE_VOICE_OVER_AUDIO_FILE 的定义。OpenCore 的音频路径参考 OC_VOICE_OVER_AUDIO_FILE 的定义。唯一例外的是 OpenCore 启动提示音文件：OCEFIAudio_VoiceOver_Boot.mp3。 macOS 引导程序和 OpenCore 的音频本地化是分开的。macOS 引导程序是在 systemLanguage.utf8 文件中的 preferences.efires 归档中设置，并由操作系统控制。OpenCore 则是使用 prev-lang:kbd 变量的值来控制。当某一特定文件的音频本地化缺失时，将会使用英语（en）来代替。示例音频文件可以在 OcBinaryData 仓库 中找到。 4. ConnectDriversType: plist booleanFailsafe: falseDescription: 驱动程序加载后执行 UEFI 控制器连接操作。 此选项对于加载某些遵循 UEFI 驱动模型的 驱动程序（如文件系统驱动、音频输出驱动）很有用，因为这些驱动可能无法自行启动。此选项对会自动连接的驱动程序来说是不必要的，并且可能会稍微减慢启动速度。 注：某些固件（特别是 Apple 的）仅连接包含操作系统的驱动器以加快启动过程。启用此选项可以在拥有多个驱动器时查看所有引导选项。 5. DriversType: plist arrayFailsafe: EmptyDescription: 从 OC/Drivers 目录下加载选择的驱动。设计为填充 UEFI 驱动程序加载的文件名。 要用 plist dict 值来填充，描述每个驱动程序。请参阅下面的 Drivers Properties 部分。 6. InputType: plist dictDescription: 从下面的 Input 属性部分，应用为输入（键盘和鼠标）而设计的个性化设置。 7. OutputType: plist dictDescription: 从下面的 Output 属性部分，应用为输出（文本和图形）而设计的个性化设置。 8. ProtocolOverridesType: plist dictDescription: 强制执行从下面的 ProtocolOverrides 属性部分所选协议的内置版本。 注：所有协议实例的安装都优先于驱动程序的加载。 9. QuirksType: plist dictDescription: 从下面的 Quirks 属性部分，应用个性化的固件 Quirks。 10. ReservedMemoryType: plist arrayDescription: 设计为用 plist dict 值填充，用于描述对特定固件和硬件功能要求很高的内存区域，这些区域不应该被操作系统使用。比如被 Intel HD 3000 破坏的第二个 256MB 区域，或是一个有错误的 RAM 的区域。详情请参考下面的 ReservedMemory Properties 部分。 11.11 APFS 属性1. EnableJumpstartType: plist booleanFailsafe: FalseDescription: 从一个 APFS 容器中加载 APFS 驱动。 APFS 的 EFI 驱动内置在所有可以作为系统启动盘的 APFS 容器之中。这一选项将会根据基于 ScanPolicy 找到的 APFS 容器，从中加载 APFS 驱动。更多详情请查看 苹果 APFS 文件系统参考手册 中的 EFI Jummpstart 部分。 2. GlobalConnectType: plist booleanFailsafe: falseDescription: 在 APFS 加载期间执行完整的设备连接。 代替通常情况下用于 APFS 驱动程序加载的分区句柄连接，每一个句柄都是递归连接的。这可能会比平时花费更多的时间，但是是某些固件访问 APFS 分区的唯一方法，比如在旧的惠普笔记本电脑上的 APFS 分区。 3. HideVerboseType: plist booleanFailsafe: FalseDescription: 是否隐藏 APFS 驱动的 verbose 信息。 APFS 驱动的 verbose 信息有助于 debug。 4. JumpstartHotPlugType: plist booleanFailsafe: FalseDescription: 允许从进入 OpenCore 引导菜单后插入的可移除硬盘上的 APFS 容器中加载 APFS 驱动。 这一选项不仅提供了进入 OpenCore 以后再插入 U 盘的支持，而且还允许了在 OpenCore 引导菜单下 APFS U 盘的热插拔。如果不需要则禁用。 5. MinDateType: plist integerFailsafe: 0Description: 允许加载的最老 APFS 驱动的发布日期。 APFS 驱动日期将 APFS 驱动与发布日期联系起来。苹果公司最终会放弃对旧的 macOS 版本的支持，这些版本的 APFS 驱动程序可能含有漏洞，如果在支持结束后使用这些驱动程序，就会被用来破坏计算机。这个选项允许将 APFS 驱动程序限制在当前的macOS版本。 0 — 需要 OpenCore 中 APFS 的默认支持发布日期。默认的发布日期会随着时间的推移而增加，因此建议采用这种设置。目前设置为 2021/01/01。 -1 — 允许加载任何发布日期（强烈不推荐）。 其他数值 — 使用自定义的最小 APFS 发布日期，例如：2020/04/01的20200401。你可以从 OpenCore 的启动日志和 OcApfsLib 中找到 APFS 发布日期。 6. MinVersionType: plist integerFailsafe: 0Description: 允许加载的最老 APFS 驱动的版本号。 APFS 驱动版本将 APFS 驱动与 macOS 版本联系起来。苹果公司最终会放弃对旧的 macOS 版本的支持，而这些版本的 APFS 驱动可能含有漏洞，如果在支持结束后使用这些驱动，就会被用来破坏计算机。 这个选项允许将 APFS 驱动程序限制在当前的 macOS 版本。 0 — 需要 OpenCore 中 APFS 的默认支持版本。默认版本会随着时间的推移而增加，因此推荐使用这一设置。目前设置为允许 macOS Big Sur 和更新的版本（1600000000000000）。 -1 — 允许加载任何版本（强烈不推荐）。 其他数值 — 使用自定义的最小APFS版本，例如：macOS Catalina 10.15.4 的 1412101001000000。你可以从 OpenCore 的启动日志和 OcApfsLib 中找到 APFS 驱动的版本号。 11.12 AppleInput 属性1. AppleEventType: plist stringFailsafe: AutoDescription: 确定是使用 OpenCore 内置协议还是 OEM Apple Event 协议。 该选项决定是否使用 OEM Apple Event 协议（如有），或者是否使用 OpenCore 的反向工程和更新的重新实现。一般来说，OpenCore 的重新实现应该是首选，因为它包含了一些更新，如明显改善的精细鼠标光标移动和可配置的按键的间隔时间。 Auto — 如果有可用的、已连接的和最近的，则使用 OEM Apple Event 实现，否则使用 OpenCore 的重新实现。在非苹果硬件上，这将使用 OpenCore 的内置实现。在某些 Mac 上，如经典的 Mac Pro，这将倾向于使用苹果的实现，但在比这更老和更新的 Mac 机型上，该选项通常会使用 OpenCore 的重新实现。在较老的 Mac 上，这是因为可用的实现太老了，无法使用，而在较新的 Mac 上，这是因为苹果公司增加了优化功能，除非需要，否则不会连接 Apple Event 协议，例如，除了明确启动苹果启动选择器的时候。由于其结果有些不可预测，通常不推荐使用这个选项。 Builtin — 始终使用 OpenCore 对 Apple Event 协议的最新重新实现。由于 OpenCore 对协议的重新实现进行了改进（更好的精细鼠标控制、可配置的按键延迟），因此即使在苹果硬件上也建议使用此设置。 OEM — 假设苹果的协议在驱动程序连接时可用。在所有苹果硬件上，如果有足够新的苹果 OEM 版本的协议可用，无论是否由苹果的固件自动连接，这个选项将可靠地访问苹果的实现。在所有其他系统上，这个选项将导致没有键盘或鼠标支持。由于上述原因，在大多数情况下，建议优先使用内置选项。 2. CustomDelaysType: plist booleanFailsafe: falseDescription: 在使用 Apple Event 协议的 OpenCore 重新实现时，启用自定义的按键间隔时间。在使用 OEM 苹果实现时没有影响（见 AppleEvent 设置）。 true — 使用 KeyInitialDelay 和 KeySubsequentDelay 的值。 false — 使用 Apple 的默认值 500ms(50) 和 50ms(5)。 3. KeyInitialDelayType: plist integerFailsafe: 50 (第一个键重复前 500ms)Description: 在 OpenCore 对 Apple Event 协议的重新实现中，配置键盘按键重复之前的初始延迟，单位为 10ms。 苹果 OEM 的默认值是 50（500ms）。 注 1：在不使用 KeySupport 的系统上，此设置可自由用于配置按键重复行为。 注 2：在使用 KeySupport 的系统上，但不显示 two long delays 行为（见注 3）或总是显示一个坚实的 set default 指标（见 KeyForgetThreshold），那么这个设置也可以自由地用于配置按键的重复初始延迟行为，只是它永远不应该被设置为小于 KeyForgetThreshold，以避免不受控制的按键重复。 注 3：在一些使用 KeySupport 的系统上，你可能会发现在正常速度键重复开始之前，在正常速度的按键响应之前，你会看到一个额外的慢速响应。如果是这样，你可能希望根据 KeySubsequentDelay 的注 3来配置 KeyInitialDelay 和 KeySubsequentDelay。 译者注：两次按键之间必然会有间隔时间，不稳定的间隔时间，会导致按键错误，所以 KeySubsequentDelay 用于配置按键重复间隔。为了准确的计算间隔时间，需要一个延迟来保证按键已经结束，而不是按键时间稍长则被认为按了两次。KeyInitialDelay 就是用于此。 4. KeySubsequentDelayType: plist integerFailsafe: 5 (随后的按键重复间隔 50ms)Description: 在 OpenCore 对 Apple Event 协议的重新实现中，配置键盘按键重复之间的间隔，单位为 10ms。 Apple OEM 的默认值是 5（50ms）。0 是这个选项的无效值（将发出调试日志警告，使用 1 代替）。 注 1：在不使用 KeySupport 的系统上，此设置可自由用于配置按键重复行为。 注 2： 在使用 KeySupport 的系统上，但不显示 two long delays 行为（见 *注 3*）或总是显示一个坚实的 set default 指标（见 KeyForgetThreshold）（这应该适用于大多数使用 AMI KeySupport 模式的系统），那么这个设置可以自由地用于配置按键重复的后续延迟行为，但它永远不应该被设置为小于 KeyForgetThreshold，以避免不受控制的按键重复。 注 3：在一些使用 KeySupport 的系统上，特别是在非 AMI 模式下的 KeySupport，你可能会发现，在配置了 KeyForgetThreshold 后，当按住一个按键时，在开始正常速度的按键响应之前，你会得到一个额外的慢速按键响应。在出现这种情况的系统上， 这是使用 KeySupport 来模拟原始键盘数据的一个不可避免的缺陷， UEFI 没有提供这种数据。 虽然这个 two long delays 的问题对整体可用性的影响很小，但你可能希望解决这个问题，可以通过以下方法来解决： 将 CustomDelays 设置为 true。 将按键初始延迟设置为 0。 将 KeySubsequentDelay 设置为至少是你的 KeyForgetThreshold 设置的值。 上述程序的工作原理如下。 将 KeyInitialDelay 设置为 0 会取消 Apple Event 的初始重复延迟（当使用 OpenCore 内置的 Apple Event 实现并启用 CustomDelays 时），因此你将看到的唯一长延迟是由这些机器上的 BIOS 按键支持引入的不可配置的、不可避免的初始长延迟。 按键平滑参数 KeyForgetThreshold 有效地充当了一个按键可以被保持的最短时间，因此一个小于这个参数的按键间隔将保证每一次按键都有至少一次额外的时间间隔，无论按键在物理上被敲击的速度如何。 如果你在设置 KeySubsequentDelay 等于你的系统的 KeyForgetThreshold 值后，仍然经常或偶尔得到双键响应，那么再增加一到两倍 KeySubsequentDelay，直到这种影响消失。 5. GraphicsInputMirroringType: plist booleanFailsafe: falseDescription: Apple的 Apple Event 阻止图形应用程序中的键盘输入出现在基本控制台输入流中。 由于默认设置为 false， OpenCore 的 Apple Event 内置实现复制了这一行为。 在非苹果硬件上， 这可能会阻止键盘输入在图形的应用程序中工作，如使用非苹果按键输入方法的 Windows BitLocker。 所有硬件上的推荐设置是 true 的。 注： Apple Event 的默认行为是为了防止在退出基于图形的 UEFI 应用程序后出现不需要的排队按键。这个问题已经在 OpenCore 中单独处理。 true — 允许键盘输入到达不使用 Apple 输入协议的图形模式应用程序。 false — 在图形模式下，防止按键输入映射到非 Apple 协议。 6. PointerPollMinType: plist integerFailsafe: 0Description: 配置最小指针轮询周期，单位为 ms。 这是 OpenCore 内置的 Apple Event 驱动程序轮询指针设备（如鼠标、触控板）的运动事件的最短时间。默认为 10 毫秒。设置为 0 将使这一默认值保持不变。 注： OEM Apple 的实现使用 2ms 的轮询率。 7. PointerPollMaxType: plist integerFailsafe: 0Description: 配置最大指针轮询周期，单位为 ms。 这是 OpenCore 内置的 Apple Event 驱动程序轮询指针设备（如鼠标、触控板）的运动事件的最长时间。只要设备没有及时响应，该周期就会增加到这个值。目前的默认值为 80ms。 设置为 0 将使这一默认值保持不变。 戴尔笔记本电脑中经常发现的某些触控板驱动程序在没有物理运动发生时，反应可能非常缓慢。 这可能会影响 OpenCanopy 和 FileVault 2 用户界面的响应能力和加载时间。增加轮询周期可以减少影响。 注： OEM Apple 的实现使用 2ms 的轮询率。 8. PointerPollMaskType: plist integer，32 bitFailsafe: -1Description: 配置轮询指针的索引。 选择要轮询 Apple Event 运动事件的指针设备。 -1 意味着所有设备。一个比特之和用于确定特定的设备。例如，要启用设备 0、2、3，其值将是 1+4+8（相应的 2 的幂）。 总共支持 32 个可配置的设备。 即使没有相应的物理设备，某些指针设备也可以存在于固件中。 这些设备通常是占位符、聚合设备或代理。从这些设备中收集信息可能导致用户界面中的运动活动不准确，甚至导致性能问题。 对于有这种问题的笔记本电脑设置，建议禁用这种指针设备。 系统中可用的指针设备的数量可以在日志中找到。更多细节请参考日志的 Found N pointer devices 部分。 注意：在使用 OEM Apple 实现时没有效果（见 Apple Event 设置）。 9. PointerSpeedDivType: plist integerFailsafe: 1Description: 在 Apple Event 协议的 OpenCore 重新实现中配置指针速度除数。在使用 OEM Apple 实现时没有影响（见 Apple Event 设置）。 配置指针移动的除数。 OEM Apple 的默认值是 1，0 是这个选项的无效值。 注：这个选项的推荐值是 1， 这个选项的推荐值是 1。这个值可以根据用户的偏好，结合 PointerSpeedMul 进行修改，以实现自定义的鼠标移动比例。 10. PointerSpeedMulType: plist integerFailsafe: 1Description: 在 Apple Event 协议的 OpenCore 重新实现中配置指针速度乘数。在使用 OEM Apple 实现时没有影响（见 Apple Event 设置）。 配置指针移动的乘数。 OEM Apple 的默认值是 1。 注：这个选项的推荐值是 1， 这个选项的推荐值是 1。这个值可以根据用户的偏好，结合 PointerSpeedDiv 进行修改，以实现自定义的鼠标移动比例。 11. PointerDwellClickTimeoutType: plist integerFailsafe: 0Description: 在 OpenCore 对 Apple Event 协议的重新实现中，以毫秒为单位配置指针停留点击单一左键的超时时间。在使用 OEM Apple 实现时没有影响（见 AppleEvent 设置）。 当超时过后，在当前位置发出一次左键点击。0 表示超时被禁用。 12. PointerDwellDoubleClickTimeoutType: plist integerFailsafe: 0Description: 在 OpenCore 对 Apple Event 协议的重新实现中，以毫秒为单位配置指针停留点击单左双击的超时。在使用 OEM Apple 实现时没有影响（见 AppleEvent 设置）。 当超时过后，在当前位置发出一次左键双击。0 表示超时被禁用。 13. PointerDwellRadiusType: plist integerFailsafe: 0Description: 在 OpenCore 对 Apple Event 协议的重新实现中，以像素为单位配置指针停留点击的容忍半径。在使用 OEM Apple实现时没有影响（见 AppleEvent 设置）。 半径由 UIScale 进行缩放。当指针离开这个半径时，PointerDwellClickTimeout 和 PointerDwellDoubleClickTimeout 的超时被重置，新的位置是新的停留点击公差半径的中心。 11.13 Audio 属性1. AudioCodecType: plist integerFailsafe: 0Description: 特定音频控制器上的编解码器地址，用于音频支持。 一般来说，这里包含了内置模拟音频控制器（HDEF）上的第一个音频编解码器地址。音频编解码器地址（例如：2）可以在调试日志中找到（已用粗斜体标出）： OCAU: 1/3 PciRoot(0x0)/Pci(0x1,0x0)/Pci(0x0,0x1)/VenMsg(&lt;redacted&gt;,00000000) (4 outputs)OCAU: 2/3 PciRoot(0x0)/Pci(0x3,0x0)/VenMsg(&lt;redacted&gt;,00000000) (1 outputs)OCAU: 3/3 PciRoot(0x0)/Pci(0x1B,0x0)/VenMsg(&lt;redacted&gt;,02000000) (7 outputs) 除此之外，该值还可以在 I/O 注册表的 IOHDACodecDevice class 中获得，包含在 IOHDACodecAddress 字段中。 2. AudioDeviceType: plist stringFailsafe: emptyDescription: 特定音频控制器的设备路径，用于音频支持。 一般来说，这里包含了内置模拟音频控制器（HDEF）的设备路径，例如：PciRoot(0x0)/Pci(0x1b,0x0)。认可的音频控制器列表可以在调试日志中找到（已用粗斜体标出）： OCAU: 1/3 PciRoot(0x0)/Pci(0x1,0x0)/Pci(0x0,0x1)/VenMsg(&lt;redacted&gt;,00000000) (4 outputs)OCAU: 2/3 PciRoot(0x0)/Pci(0x3,0x0)/VenMsg(&lt;redacted&gt;,00000000) (1 outputs)OCAU: 3/3 PciRoot(0x0)/Pci(0x1B,0x0)/VenMsg(&lt;redacted&gt;,02000000) (7 outputs) 如果使用 AudioDxe，可用的控制器设备路径也会以这样的格式输出： HDA: Connecting controller - PciRoot(0x0)/Pci(0x1B,0x0) 除此之外，该值还可以在 macOS 中通过 gfxutil -f HDEF 命令来获取。 指定一个空的设备路径会导致使用第一个可用的编解码器和音频控制器。在这种情况下，AudioCodec 的值被忽略。这可能是一个方便的初始选项，以尝试让 UEFI 音频工作。当这个默认值不起作用时，就需要进行上述的手动设置。 3. AudioOutMaskType: plist integerFailsafe: -1Description:位字段，指示用于 UEFI 声音的输出通道。 音频掩码为 1 &lt; 音频输出（等同于 2^ 音频输出）。例如，对于音频输出 0，比特掩码是 1，对于输出 3 是 8，对于输出 0 和 3 是 9。 每个 HDA 编解码器的可用输出节点的数量（N）显示在调试日志中（如下），音频输出 0 到 N-1 可以选择。 OCAU: 1/3 PciRoot(0x0)/Pci(0x1,0x0)/Pci(0x0,0x1)/VenMsg(&lt;redacted&gt;,00000000) (4 outputs)OCAU: 2/3 PciRoot(0x0)/Pci(0x3,0x0)/VenMsg(&lt;redacted&gt;,00000000) (1 outputs)OCAU: 3/3 PciRoot(0x0)/Pci(0x1B,0x0)/VenMsg(&lt;redacted&gt;,02000000) (7 outputs) 当使用 AudioDxe 时，每个输出通道的额外信息会在驱动程序绑定时被记录下来， 包括每个输出的比特掩码。所需输出的比特掩码值应该加在一起，以获得 AudioOutMas 值： HDA: | Port widget @ 0x9 is an output (pin defaults 0x2B4020) (bitmask 1)HDA: | Port widget @ 0xA is an output (pin defaults 0x90100112) (bitmask 2)HDA: | Port widget @ 0xB is an output (pin defaults 0x90100110) (bitmask 4)HDA: | Port widget @ 0x10 is an output (pin defaults 0x4BE030) (bitmask 8) 关于可用输出通道的进一步信息可以通过使用命令从 Linux 编解码器转储中找到： cat /proc/asound/card&#123;n&#125;/codec#&#123;m&#125; 使用 AudioOutMask，可以向多个的通道播放声音（例如，主扬声器加低音扬声器； 耳机加扬声器），只要所有选择的输出都支持正在使用的声音文件格式；如果任何一个不支持，那么就不会有声音播放，并且会有警告记录。 当编解码器上所有可用的输出通道都支持可用的声音文件格式时，-1 的值将同时向所有通道播放声音。如果这不起作用，通常最快的方法是逐一尝试每个可用的输出通道，将 AudioOutMask 设置为 1、 2、 4 等，直到 2ˆN-1，以便找出哪个通道能产生声音。 4. AudioSupportType: plist booleanFailsafe: falseDescription: 通过连接到固件音频驱动程序以激活音频支持。 启用此设置可将音频播放从内置协议路由到音频控制器（AudioDevice）上指定编解码器（AudioCodec）的专用音频端口（AudioOut）。 5. DisconnectHdaType: plist booleanFailsafe: falseDescription: 在加载驱动程序之前，断开 HDA 控制器的连接。 在某些系统上可能需要（例如苹果硬件、 VMware Fusion guest），以允许 UEFI 声音驱动（例如：AudioDxe）控制音频硬件。 注：除了这个选项外，大多数苹果硬件还需要 --gpio-setup 驱动参数， 这在 AudioDxe 部分有涉及。 6. MaximumGainType: plist integerFailsafe: -15Description: 用于 UEFI 音频的最大增益，以分贝（dB）为单位，相对于放大器的参考电平 0dB（见注 1）。 当从 SystemAudioVolumeDB NVRAM 变量中读取的系统放大器增益高于此值时，所有的 UEFI 音频将使用此增益设置。 这是为了避免在系统音量设置得很高，或者 SystemAudioVolumeDB NVRAM 的值被错误地配置时，UEFI 音频过于响亮。 注 1：分贝（dB）是指与某个参考水平相比的增益（正值；音量增加）或衰减（负值；音量减少）。例如，当你听到喷气式飞机的声级表示为 120 分贝时，参考水平是普通人可以听到的声级。然而，在声学和计算机音频中，任何参考电平都可以被指定。英特尔 HDA 和 macOS 原生使用分贝来指定音量级别。在大多数英特尔 HDA 硬件上，0 分贝的参考电平是硬件的最大声量，因此所有更低的音量是负数。在典型的声音硬件上，最安静的音量大约是 -55dB 到 -60dB。 注 2：与 macOS 处理分贝值的方式一致， 该值被转换为有符号的字节；因此，不允许使用 -128 dB 到 +127 dB 以外的值（这些值远远超出物理上合理的音量水平）。 注 3： 数字音频输出，在操作系统中没有音量滑块，忽略这个和所有其他增益设置，只有静音设置是相关的。 7. MinimumAssistGainType: plist integerFailsafe: -30Description: 用于选择器音频辅助的最小增益（dB）， 单位为分贝（dB）。 如果从 SystemAudioVolumeDB NVRAM 变量中读取的系统放大器增益低于此值，屏幕阅读器将使用此放大器增益。 注 1：除了这个设置外，由于音频辅助必须能听到才能发挥其功能，所以即使操作系统的声音被静音或 StartupMute NVRAM 变量被设置，音频辅助也不会被静音。 注 2：关于分贝音量级别的解释，请参见 MaximumGain 部分。 8. MinimumAudibleGainType: plist integerFailsafe: -128Description: 尝试播放任何声音的最小增益，单位是分贝（dB）。 如果 SystemAudioVolumeDB NVRAM 变量中的系统放大器增益水平低于此值，则不会播放开机提示音。 注 1： 这个设置是为了节省由于在听不见的音量水平上进行音频设置而造成的不必要的停顿，因为无论如何都不会听到声音。是否有听不见的音量水平取决于硬件。在一些硬件上（包括 Apple），音频值与硬件匹配得很好，最低的音量水平是非常安静但可以听到的，而在其他一些硬件组合上，音量范围的最低部分可能根本听不到。 注 2：关于分贝音量级别的解释，请参见 MaximumGain。 9. PlayChimeType: plist stringFailsafe: AutoDescription: 开机时播放 Mac 特有的风铃的声音。 启用此设置可通过内置的音频支持来播放开机时播放的声音。音量大小由 MinimumVolume 和 VolumeAmplifier 的设置，以及 SystemAudioVolume NVRAM 变量来决定。可用的值有： Auto — 当 StartupMute NVRAM 变量不存在或设置为 00 时，启用开机声音。 Enabled — 无条件启用开机声音。 Disabled — 无条件禁用开机声音。 注 1：Enable 是可以与 StartupMute NVRAM 变量分开使用的，以此来避免在固件能够播放启动铃声时发生冲突。 注 2：无论如何设置，如果系统音频被静音，即 SystemAudioVolume NVRAM 变量设置了 0x80 位，则不会播放启动铃声。 10. ResetTrafficClassType: plist booleanFailsafe: 0Description: 将 HDA Traffic Class Select 寄存器设置为 TC0。 只有当 TCSEL 寄存器配置为 use TC0 traffic class 时，AppleHDA.kext 才能正常工作。有关此寄存器的更多详细信息，请参阅 Intel I/O Controller Hub 9（ICH9）Family Datasheet（或任何其他 ICH Datasheet）。 注：此选项独立于 AudioSupport。如果使用 AppleALC，则首选使用 AppleALC alctcsel 属性。 11. SetupDelayType: plist integerFailsafe: 0Description: 音频编解码器重新配置的延迟，以毫秒为单位。 某些编解码器在重新配置后需要特定延迟（由供应商提供，例如音量设置），此选项可对其进行配置。一般来说，必要的延迟时间可能长达 0.5 秒。 11.14 Drivers 属性1. CommentType: plist stringFailsafe: EmptyDescription: 用于为条目提供人类可读参考的任意 ASCII 字符串（译者注：即注释）。 2. EnabledType: plist booleanFailsafe: falseDescription: 如果设置为 false 的，这个驱动条目将被忽略（译者注：即不启用这个驱动）。 3. PathType: plist stringFailsafe: EmptyDescription: 从 OC/Drivers 目录中作为 UEFI 驱动加载的文件的路径。 4. LoadEarlyType: plist booleanFailsafe: falseDescription: 在 OpenCore 启动过程的早期加载驱动程序，在 NVRAM 设置之前。 注：请勿启用此选项，除非针对给定的驱动程序和目的特别推荐这样做。 5. ArgumentsType: plist integerFailsafe: EmptyDescription: 一些OpenCore插件接受可选的额外参数，可以在这里指定为一个字符串（译者注：即驱动参数）。 11.15 Input 属性1. KeyFilteringType: plist booleanFailsafe: falseDescription: 启用键盘输入的合理性检查。 显然，有些主板，如 GA Z77P-D3，可能会在 EFI_INPUT_KEY 中返回所有输入协议的未初始化数据。这个选项会舍弃那些既不是 ASCII 码，也不是 UEFI 规范中定义的键（见版本 2.8 的表 107 和 108）。 2. KeyForgetThresholdType: plist integerFailsafe: 0Description: 两次按键之间的间隔时间，单位为 10ms。如果两次按键的时间间隔，小于这个值，那么视为保持长按。只适用于使用 KeySupport 的系统。 AppleKeyMapAggregator 协议应该包含当前按下的键的固定长度的缓冲。但是大部分驱动程序仅将按键按下报告为中断、并且按住按键会导致在一定的时间间隔后再提交按下行为。一旦超时到期，我们就是用超时从缓冲区中删除一次按下的键，并且没有新提交。 此选项允许根据你的平台设置此超时。在大多数平台上有效的推荐值为 5 毫秒。作为参考，在 VMWare 上按住一个键大约每 2 毫秒就会重复一次，而在 APTIO V 上是 3-4 毫秒。因此，可以在较快的平台上设置稍低的值、在较慢的平台设置稍高的值，以提高响应速度。 在同一平台上，一个接一个地按下按键会导致至少 60 和 100 毫秒的延迟。理想情况下，KeyForgetThreshold 应该保持低于这个值，以避免合并真正的按键。 调整 KeyForgetThreshold 的值对于在启用了 KeySupport 的系统上实现准确和灵敏的键盘输入是必要的，建议按照下面的说明为你的系统正确地调整它。 注 1：要调整 KeyForgetThreshold，你可以使用 OpenCanopy 或内置启动选择器中的 set default 指示符。如果KeyForgetThreshold 太低，那么当按住 CTRL 或 =/+ 时， set default 指示符将继续闪烁。你应该配置能避免这种闪烁的最低值。在一些系统上（例如 Aptio IV 和可能使用 AMI KeySupport 模式的其他系统），你可以找到一个最小的KeyForgetThreshold 值，在这个值上， set default 指示符会亮起并保持不变，而且没有闪烁，如果是这样，就使用这个值。在大多数其他使用 KeySupport 的系统上，你会发现，当第一次按住 CTRL 或 =/+ 键时， set default 指示符会闪烁一次，然后再经过一个非常短暂的间隔，就会亮起并保持亮起。在这样的系统上，你应该选择最低的 KeyForgetThreshold 值，在这个值上，你只看到最初的一次闪烁，然后就没有后续的闪烁了。(在这种情况下，这是使用 KeySupport 模拟原始键盘数据的系统上不可避免的缺陷，UEFI 不提供这种数据）。 注 2：KeyForgetThreshold 最多不需要超过 9 或 10。如果它被设置为一个远高于此的值，将导致明显的键盘输入无反应。因此，为了整体的按键响应，强烈建议配置一个相对较低的值，在这个值上， set default 指示符会闪烁一次，然后不再闪烁，而不是使用一个高得多的值（即明显大于 10），你可能能找到但不应该使用这个值，在这个值上， set default 指示符根本不闪烁。 3. KeySupportType: plist booleanFailsafe: falseDescription: 启用内部键盘输入转换为 AppleKeyMapAggregator 协议。 这一选项基于 AppleGenericInput（AptioInputFix），激活内部键盘拦截器驱动程序以填充 AppleKeyMapAggregator 数据库以实现输入功能。如果使用了单独的驱动程序（例如：AppleUsbKbDxe），则永远不要开启这一选项。此外，这个选项不是必需的，也不应该在 Apple 固件中启用。 4. KeySupportModeType: plist stringFailsafe: AutoDescription: 将内部键盘的输入转换设置为 AppleKeyMapAggregator 协议模式。 Auto — 从下述选项中自动选择 V1 — UEFI 传统输入协议 EFI_SIMPLE_TEXT_INPUT_PROTOCOL. V2 — UEFI 现代标准输入协议 EFI_SIMPLE_TEXT_INPUT_EX_PROTOCOL. AMI — APTIO 输入协议 AMI_EFIKEYCODE_PROTOCOL. 注：目前 V1、V2 和 AMI 区别于 Auto，只对特定的协议进行过滤。这种情况在未来的版本中可能会改变。 5. KeySwapType: plist booleanFailsafe: falseDescription: 启用后将交换 Command 和 Option。 此选项对于 Option 键位于 Command 右侧的键盘来说会很有用。 6. PointerSupportType: plist booleanFailsafe: falseDescription: 启用内部指针驱动器。 该选项通过选择 OEM 协议实现标准 UEFI 指针协议 EFI_SIMPLE_POINTER_PROTOCOL。该选项在 Z87 华硕主板可能有用（该主板的 EFI_SIMPLE_POINTER_PROTOCOL 存在问题）。 7. PointerSupportModeType: plist stringFailsafe: emptyDescription: 设置用于内部指针驱动程序的 OEM 协议。 目前只支持 ASUS 值，使用的是 Z87 和 Z97 主板上的特殊协议。更多详情请参考 LongSoft/UefiTool#116。如果启用了 PointerSupport，此处值不能为空。 8. TimerResolutionType: plist integerFailsafe: 0Description: 固件始终刷新的频率（单位 100 纳秒） 这个选项允许用 100 纳秒为单位的指定值来更新固件架构的定时器周期。设置一个较低的值通常可以提高接口和输入处理的性能和响应性。 建议值为 50000（即 5 毫秒）或稍高一些。选择 ASUS Z87 主板时，请使用 60000，苹果主板请使用 100000。你也可以将此值设置为 0，不改变固件始终刷新的频率。 11.16 Output 属性1. InitialModeType: plist stringFailsafe: AutoDescription: 选择 internal ConsoleControl 模式，TextRenderer 将在该模式下运行。 可用值为 Auto、Text 和 Graphics。 Text 和 Graphics 指定了命名模式。 Auto 使用系统 ConsoleControl 协议的当前模式（如果存在），否则默认为 Text 模式。 UEFI 固件通常支持具有两种渲染模式（Graphics 和 Text）的 ConsoleControl。 某些类型的固件不提供本机的 ConsoleControl 和渲染模式。 OpenCore 和 macOS 期望文本仅在文本模式下显示，但图形可以在任何模式下绘制，这就是 OpenCore 内置渲染器的行为方式。 由于 UEFI 规范不要求这样做，因此系统 ConsoleControl 协议的行为（如果存在）可能会有所不同。 2. TextRendererType: plist stringFailsafe: BuiltinGraphicsDescription: 选择通过标准控制台输出的渲染器。 目前支持两种渲染器：Builtin 和 System。System 渲染器使用固件服务进行文本渲染，但是提供了额外的选项来清理输出。Builtin 渲染器则绕过固件服务，自行渲染文本。不同的渲染器支持的选项也不同。建议使用 Builtin 渲染器，因为它支持 HiDPI 模式，并能够使用全屏分辨率。 每个渲染器都提供自己的 ConsoleControl 协议（在系统通用的情况下，如果存在系统 ConsoleControl 协议，则会将某些操作传递给它）。 此选项的有效值是要使用的渲染器和在启动前设置在底层系统 ConsoleControl 协议上的 ConsoleControl 模式的组合。要控制启动后所提供的 ConsoleControl 协议的初始模式，请使用 InitialMode 选项。 有效值为文本渲染器和渲染模式的组合： BuiltinGraphics — 切换到 Graphics 模式，然后使用 Builtin 渲染器和自定义 ConsoleControl。 BuiltinText — 切换到 Text 模式，然后使用 Builtin 渲染器和自定义 ConsoleControl。 SystemGraphics — 切换到 Graphics 模式，然后使用 System 渲染器和自定义 ConsoleControl。 SystemText — 切换到 Text 模式，然后使用 System 渲染器和自定义 ConsoleControl。 SystemGeneric — 使用 System 渲染器和自定义 ConsoleControl 协议，该协议在存在系统 ConsoleControl 时将其模式设置和获取操作传递给系统 ConsoleControl。 BuiltinGraphics 的使用很简单。对于大多数平台，需要启用 ProvideConsoleGop，将 Resolution 设置为 Max。某些非常老旧且问题很多的笔记本只能在 Text 模式下绘图，对它们来说，BuiltinText 是 BuiltinGraphics 的替代选择。 System 协议的用法比较复杂。一般来说，首选设置 SystemGraphics 或 SystemText。需要启用 ProvideConsoleGop，将 Resolution 设置为 Max，启用 ReplaceTabWithSpace 几乎在所有平台上都很有用。SanitiseClearScreen、IgnoreTextInGraphics 和 ClearScreenOnModeSwitch 比较特殊，它们的用法取决于固件。 注：某些 Mac，例如 MacPro5,1，在使用较新的 GPU 时，可能会出现控制台不兼容输出的情况（例如：中断），因此可能只有 BuiltinGraphics 对它们有效。NVIDIA GPU可能需要额外的固件升级。 2. ConsoleFontType: plist stringFailsafe: Empty （使用 OpenCore 内置的控制台字体）Description: 指定用于OpenCore内置文本渲染器的控制台字体。 字体文件必须位于 EFI/OC/Resources/Font/&#123;font-name&#125;.hex 中，并且必须是 8x16 分辨率。各种控制台字体可以在网上找到 .bdf 或 hex 格式。bdf可以用 gbdfed（可用于 Linux 或 macOS）转换为 .hex 格式。 通常不需要改变控制台字体，主要用途是为那些相对罕见的支持多语言的 EFI 应用程序（例如 memtest86）提供一个扩展字符集。 OcBinaryData 资源库包括： Terminus ：一种具有广泛的字符支持的字体，适用于诸如上述的应用程序。 TerminusCoreTerminus ：字体的轻微修改版本，使一些字形（@KMRSTVWimrsw）与 XNU 和 OpenCore 中使用的免费 ISO 拉丁字体更加相似。 Terminus和TerminusCore是根据《SIL O)pen字体许可证》1.1版提供的。可以在这里找到EPTO字体库中的一些额外的GPL许可字体，这些字体被转换为所需的.hex格式。 注 1：在许多较新的系统上，系统文本渲染器已经提供了一整套国际字符，在这种情况下，可以不需要使用内置渲染器和自定义字体。 注 2：这个选项只影响到内置文本渲染器，并且只从内置渲染器被配置的那一刻起生效。当控制台输出在这之前可见时，它使用的是系统控制台字体。 3. ConsoleModeType: plist stringFailsafe: Empty （保持当前的控制台模式）Description: 按照 WxH（例如：80x24）格式的字符串所指定的方式设置控制台的输出模式。 设置为 Max 则会尝试最大的可用控制台模式。 注：在大多数固件上，这个字段最好留空。 4. ResolutionType: plist stringFailsafe: Empty （保持当前屏幕分辨率）Description: 设置控制台的屏幕分辨率。 设置为 WxH@Bpp（如 1920x1080@32）或 WxH（例如：1920x1080）格式的字符串，向 GOP 请求自定义分辨率（如果有的话）。 设置为 Max，尝试使用最大的可用屏幕分辨率。 在 HiDPI 屏幕上，APPLE_VENDOR_VARIABLE_GUID UIScale NVRAM 变量可能需要设置为 02，以便在 Builtin 文本渲染器、FileVault 2 UEFI 密码界面和启动界面 logo 启用 HiDPI 缩放。更多细节请参考 建议变量 部分。 注：当控制台句柄没有 GOP 协议时，这些设置会失败。当固件不再提供时，可以将 ProvideConsoleGop 设置为 true 添加 GOP 协议。 5. ForceResolutionType: plist booleanFailsafe: falseDescription: 当默认情况下无法获得所需分辨率时，强制设置 Resolution 中所填写的分辨率，多用于老的 Intel GMA 和第一代 Intel HD Graphics (Ironlake/Arrandale)。将 Resolution 设置为 Max 时，将尝试从所连接的显示器的 EDID 中提取最大的可用分辨率。 注：该选项依赖 OC_FORCE_RESOLUTION_PROTOCOL 协议。目前只有 OpenDuetPkg 支持该协议，而 OpenDuetPkg 的实现目前仅支持 Intel iGPU。 6. ClearScreenOnModeSwitchType: plist booleanFailsafe: falseDescription: 有些固件在从图形模式切换到文本模式时，只会清除部分屏幕、而会留下一部分之前绘制的图像。启用这一选项后，在切换到文本模式之前会用黑色填充整个图形屏幕。 注：这一选项只会在 System 渲染器上生效。 7. DirectGopRenderingType: plist booleanFailsafe: falseDescription: 为控制台使用内置的图形输出协议渲染器。 在某些固件上，这样做可能会提供更优的性能，甚至修复渲染问题，例如：MacPro5,1。但是，除非有明显的好处，否则还是建议不要使用这个选项，因为可能会导致滚动速度变慢。 这个渲染器完全支持 AppleEg2Info 协议，将为所有 EFI 应用程序提供屏幕旋转。为了提供与 EfiBoot 的无缝旋转兼容性，还应该使用内置的 AppleFramebufferInfo，也就是说，在 Mac EFI 上可能需要覆盖它。 8. GopBurstModeType: plist booleanFailsafe: falseDescription: 如果系统固件尚未启用 write-combining (WC) caching for GOP memory，则启用 write-combining (WC) caching for GOP memory。 一些较旧的固件（例如 EFI 时代的 Mac）无法设置 write-combining (WC) caching for GOP memory（也称为 burst 模式），尽管 CPU 支持该功能。 设置这个可以大大加快 GOP 操作的速度，特别是在需要 DirectGopRendering 的系统上。 注 1：无论是否设置了 DirectGopRendering，此 Quirk 都会生效，并且在某些情况下，即使 DirectGopRendering 未启用，也可能会明显加快 GOP 操作的速度。 注 2：大约是在 2013 年以后的大多数系统上，write-combining (WC) caching 已由固件应用于 GOP 内存，在这种情况下 GopBurstMode 是不必要的。 在此类系统上启用此 Quirk 通常应该是无害的，它会生成一个 OCC: 调试日志条目，表明 burst 模式已经启动。 注 3：启用此 Quirk 时应谨慎，因为已观察到它会导致一些系统挂起。 由于已添加额外的防护措施以试图防止这种情况发生，如果发现此类系统，请记录错误跟踪器问题。 9. GopPassThroughType: plist stringFailsafe: DisabledDescription: 在 UGA 协议实例的基础上提供 GOP 协议实例。 该选项通过一个基于 UGA 的代理为没有实现 GOP 协议的固件提供 GOP 协议。 该选项的支持值如下： Enabled — 为所有 UGA 协议提供 GOP。 Apple — 为支持 AppleFramebufferInfo 的协议提供 GOP。 Disabled — 不提供 GOP。 注：该选项需要启用 ProvideConsoleGop。 10. IgnoreTextInGraphicsType: plist booleanFailsafe: falseDescription: 某些类型的固件在图形和文本模式下都在屏幕上输出文本。这通常是意料之外的，因为随机文本可能会出现在图形图像上并导致 UI 损坏。将此选项设置为 true 时，将会在控制台未处于与 Text 模式时，舍弃所有文本输出。 注：这一选项只会在 System 渲染器上生效。 11. ReplaceTabWithSpaceType: plist booleanFailsafe: falseDescription: 有些固件不会打印 tab 符号，甚至不打印 tab 后面的所有内容，导致很难或根本无法用 UEFI Shell 内置的文本编辑器来编辑属性列表和其他文档。这个选项会使控制台输出空格来替代 tab。 注：这一选项只会在 System 渲染器上生效。 12. ProvideConsoleGopType: plist booleanFailsafe: falseDescription: 确保控制台句柄上有 GOP (Graphics Output Protocol)。 macOS bootloader 要求控制台句柄上必须有 GOP 或 UGA（适用于 10.4 EfiBoot），但 UEFI 规范并未涵盖图形协议的确切位置。此选项会确保 GOP 和 UGA（如果存在）在控制台句柄上可用。 注：这个选项也会替换掉控制台句柄上损坏的 GOP 协议，在使用较新的 GPU 的 MacPro5,1 时可能会出现这种情况。 13. ReconnectGraphicsOnConnectType: plist booleanFailsafe: falseDescription: 在驱动连接过程中重新连接所有的图形驱动。 在某些固件上，可能希望使用一个替代的图形驱动程序，例如 BiosVideo.efi。在传统机器上提供更好的屏幕分辨率选项，或者使用支持 ForceResolution 的驱动程序。这个选项试图在连接新加载的驱动程序之前断开所有当前连接的图形驱动程序。 注：这个选项需要启用 ConnectDrivers。 14. ReconnectOnResChangeType: plist booleanFailsafe: falseDescription: 改变屏幕分辨率后重新连接控制台控制器。 当通过 GOP 改变屏幕分辨率时，某些固件需要重新连接产生控制台协议（简单的文本输出）的控制器，否则它们不会根据新的分辨率生成文本。 注：当 OpenCore 从 Shell 启动时，这个逻辑可能会导致某些主板黑屏，因此这个选项是非必须的。在 0.5.2 之前的版本中，这个选项是强制性的，不可配置。除非需要，否则请不要使用该选项。 15. SanitiseClearScreenType: plist booleanFailsafe: falseDescription: 有些固件在使用较大的显示器（例如：2K 或 4K）时，清除屏幕内容会导致屏幕分辨率重置为 failsafe 值（例如：1024x768）。这个选项为这种情况提供了一个变通方法。 注：这一选项只会在 System 渲染器上生效。在所有已知的受影响的系统中，ConsoleMode 必须设置为空字符串才能正常工作。 16. UIScaleType: plist integer，8 bitFailsafe: -1Description: 用户界面的缩放系数。 对应于4D1EDE05-38C7-4A6A-9CC6-4BCCA8B38C14：UIScale 变量。 1 — 1倍缩放，对应于普通显示器。 2 — 2x缩放，对应于 HiDPI 显示器。 -1 — 保持当前变量不变。 0 – 根据当前分辨率自动选择缩放比例。 注 1：自动比例系数检测是在总像素面积的基础上进行的，在小型 HiDPI 显示器上可能会失败，在这种情况下，可以使用 NVRAM 部分手动管理该值。 注 2：当从手动指定的 NVRAM 变量切换到该首选项时，可能需要对 NVRAM 进行重置。 17. UgaPassThroughType: plist booleanFailsafe: falseDescription: 在 GOP 协议实例的基础上提供 UGA 协议实例。 有些固件不会去实现老旧的 UGA 协议，但是有些更老的 EFI 应用程序（ 例如 10.4 的 EfiBoot）可能需要用它来进行屏幕输出。 11.17 ProtocolOverrides 属性1. AppleAudioType: plist booleanFailsafe: falseDescription: 用内置的版本替换 Apple 音频协议。 Apple 音频协议允许 macOS bootloader 和 OpenCore 播放声音和信号，用于屏幕阅读或声音错误报告。支持的协议有生成「哔」声和 VoiceOver。VoiceOver 协议是带有 T2 芯片的机器特有的，不支持 macOS High Sierra (10.13) 之前的版本。旧版 macOS 版本使用的是 AppleHDA 协议，目前还没有实现。 每次只能有一组音频协议可用，所以如果为了在 Mac 系统上的 OpenCore 用户界面实现其中一些协议的音频播放，这一设置应该启用。 注：后端音频驱动需要在 UEFI Audio 部分进行配置，以便这些协议能够流式传输音频。 2. AppleBootPolicyType: plist booleanFailsafe: falseDescription: 用内置的版本替换 Apple Boot Policy 协议，可用于确保 VM 或旧版 Mac 设备上的 APFS 兼容性。 注：某些 Mac 设备（例如：MacPro5,1）虽然兼容 APFS，但是其 Apple Boot Policy 协议包含了恢复分区检测问题，因此也建议启用这一选项。 3. AppleDebugLogType: plist booleanFailsafe: falseDescription: 用内置的版本替换 Apple 调试日志输出协议。 4. AppleEg2InfoType: plist booleanFailsafe: falseDescription: 用内置的版本替换 Apple EFI Graphics 2 协议。 注 1：该协议允许更新的 EfiBoot 版本（至少 10.15）向 macOS 公开屏幕旋转。有关如何设置屏幕旋转角度，请参阅 ForceDisplayRotationInfo 变量说明。 注 2：在没有 ForceDisplayRotationInEFI 原生支持的系统上，必须设置 DirectGopRendering=true。 5. AppleFramebufferInfoType: plist booleanFailsafe: falseDescription: 重新安装内置的 Apple Framebuffer Info 协议。这样可以覆盖虚拟机或者旧款 Mac 上的缓冲帧信息，从而提高与旧版 EfiBoot（例如 macOS 10.4 中的 EfiBoot）的兼容性。 注：这个属性的当前实现导致它只有在 GOP 可用时才是有效的（否则它总是相当于false）。 6. AppleImageConversionType: plist booleanFailsafe: falseDescription: 用内置的版本替换 Apple Image Conservation 协议。 7. AppleImg4VerificationType: plist booleanFailsafe: falseDescription: 用内置的版本替换 Apple IMG4 验证协议。该协议用于验证 Apple 安全启动所使用的 im4m 清单文件。 8. AppleKeyMapType: plist booleanFailsafe: falseDescription: 用内置的版本替换 Apple Key Map 协议。 9. AppleRtcRamType: plist booleanFailsafe: falseDescription: 用内置的版本替换 Apple RTC RAM 协议。 注：内置的 Apple RTC RAM 协议可能会过滤掉 RTC 内存地址的潜在 I/O。地址列表可以在 4D1FDA02-38C7-4A6A-9CC6-4BCCA8B30102:rtc-blacklist 中以数组的方式指定。 10. AppleSecureBootType: plist booleanFailsafe: falseDescription: 用内置的版本替换 Apple 安全启动协议。 11. AppleSmcIoType: plist booleanFailsafe: falseDescription: 用内置的版本替换 SMC I/O 协议。 这一协议代替了传统的 VirtualSmc.efi，并与所有 SMC Kext 驱动兼容。如果你在用 FakeSMC，可能需要手动往 NVRAM 中添加键值对。 12. AppleUserInterfaceThemeType: plist booleanFailsafe: falseDescription: 用内置的版本替换 Apple User Interface Theme 协议。 13. DataHubType: plist booleanFailsafe: falseDescription: 用内置的版本替换 Data Hub 协议。如果已经安装了协议，这将删除所有先前的属性。 注：如果协议已经安装，这将丢弃之前的所有条目，因此必须在配置文件中指定系统安全运行所需的所有属性。 14. DevicePropertiesType: plist booleanFailsafe: falseDescription: 用内置的版本替换 Device Property 协议。 这一选项可用于确保在 VM 或旧版 Mac 设备上的兼容性。 注：如果协议已经安装，这将丢弃之前的所有条目，因此必须在配置文件中指定系统安全运行所需的所有属性。 15. FirmwareVolumeType: plist booleanFailsafe: falseDescription: 强制包装固件卷协议或安装新版本以支持 FileVault 2 的自定义光标图像。建议启用这一选项以确保 FileVault 2 在除 VM 和传统 Mac 设备之外的兼容性。 注：包括 VMWare 在内的多个虚拟机在 HiDPI 模式下光标会损坏，因此建议为所有虚拟机启用这一选项。 16. HashServicesType: plist booleanFailsafe: falseDescription: 用内置版本替换 Hash Services 协议。为了在 SHA-1 哈希协议不完整的固件上确保 FileVault 2 的兼容性，这一 Quirk 应设置为 true。对于大多数固件来说，你可以通过将 UIScale 设置为 02 查看是否会出现禁行图标，来诊断你的固件是否需要这一 Quirk。一般来说，APTIO V（Haswell 和更早的平台）之前的平台都会受到影响。 17. OSInfoType: plist booleanFailsafe: falseDescription: 用内置版本替换 OS Info 协议。该协议通常用于通过固件或其他应用程序从 macOS 引导加载程序接收通知。 18. PciloType: plist booleanFailsafe: falseDescription: 用 64 位 MMIO 兼容的函数替换 Cpulo 和 PciRootBridgelo 中的函数，以修复使用 4G 解码时的无效参数。这影响到 UEFI 驱动，如访问 64 位 MMIO 设备的 AudioDxe。早于 APTIO V 的平台（Haswell 和更早）通常受到影响。 19. UnicodeCollationType: plist booleanFailsafe: falseDescription: 用内置版本替换 Unicode Collation 服务。建议启用这一选项以确保 UEFI Shell 的兼容性。一些较旧的固件破坏了 Unicode 排序规则，启用后可以修复这些系统上 UEFI Shell 的兼容性 (通常为用于 IvyBridge 或更旧的设备) 11.18 Quirks 属性1. ActivateHpetSupportType: plist booleanFailsafe: falseDescription: 激活 HPET 支持。 像 ICH6 这样的旧板子在固件首选项中可能并不总是有 HPET 设置，这个选项试图强制启用它。 2. EnableVectorAccelerationType: plist booleanFailsafe: falseDescription: 启用 SHA-512 和 SHA-384 哈希算法的 AVX 矢量加速。 注：这个选项可能会在某些笔记本电脑的固件上引起问题，包括联想。 3. EnableVmxType: plist booleanFailsafe: falseDescription: 启用英特尔虚拟机扩展。 注：需要在某些 Mac 硬件上允许 Windows 中进行虚拟化。在大多数固件上 OpenCore 启动之前，VMX 被 BIOS 启用或禁用并锁定。在可能的情况下，使用 BIOS 来启用虚拟化。 4. DisableSecurityPolicyType: plist booleanFailsafe: falseDescription: 禁用平台安全策略。 注：此设置可禁用固件的各种安全功能，因此也会同时破坏安全启动策略。如果打算使用 UEFI 安全启动，请勿启用此项。 5. ExitBootServicesDelayType: plist integerFailsafe: 0Description: 在 EXIT_BOOT_SERVICES 事件后添加延迟，单位为毫秒。 这是一个非常粗略的解决办法，可以规避某些 APTIO IV 固件（ASUS Z87-Pro）上的 Still waiting for root device 提示信息。特别是在使用 FileVault 2 时。似乎因为某种原因，FileVault 与 EXIT_BOOT_SERVICES 同时执行、导致 macOS 无法访问 SATA 控制器。需要一个更好的方法，Acidanthera 愿意接受建议。如果需要启用这一选项，设置 3-5 秒的延时就可以了。 6. ForceOcWriteFlashType: plist integerFailsafe: 0Description: 启用所有 OpenCore 管理的 NVRAM 系统变量向闪存的写入。 注：这个值在大多数的固件上应该是禁用的，但是为了考虑到可能有易失性变量存储溢出或类似问题的固件，所以留下了可配置的值。没有启用这个 Quirk 时，在联想 Thinkpad T430 和 T530 上可以观察到跨多个操作系统的启动问题。出于安全原因，与安全启动和休眠有关的 Apple 变量不在此列。此外，一些 OpenCore 变量由于不同的原因被豁免，例如由于一个可用的用户选项，启动日志，以及由于时间问题，TSC 频率。在切换该选项时，可能需要对 NVRAM 进行重置，以确保完整的功能。 7. ForgeUefiSupportType: plist booleanFailsafe: falseDescription: 在 EFI 1.x 固件上提供部分 UEFI 2.x 支持。 注：此设置允许在带有旧版 EFI 1.x 固件（例如：MacPro5,1）的硬件上运行为 UEFI 2.x 固件（例如：NVIDIA GOP Option ROM）编写的一些软件。 8. IgnoreInvalidFlexRatioType: plist booleanFailsafe: falseDescription: 某些类型的固件（例如：APTIO IV）可能在 MSR_FLEX_RATIO（0x194）MSR 寄存器中包含无效的值。这些值可能导致英特尔平台上的 macOS 启动失败。 注意：虽然该选项预计不会损害未受影响的固件，但只有在特别需要时才建议使用该选项。 9. ReleaseUsbOwnershipType: plist booleanFailsafe: falseDescription: 尝试从固件驱动程序中分离 USB 控制器所有权。尽管大多数固件都设法正确执行了该操作或者提供有一个选项，但某些固件没有，从而导致操作系统可能会在启动时冻结。除非需要，否则不建议启用这一选项。 10. ReloadOptionRomsType: plist booleanFailsafe: falseDescription: 查询 PCI 设备并重新加载其可选 ROM（如果可用）。 例如，该选项允许在通过 ForgeUefiSupport 升级固件版本后，在旧版 Mac 上重新加载 NVIDIA GOP Option ROM。 11. RequestBootVarRoutingType: plist booleanFailsafe: falseDescription: 请求将所有带有 Boot 前缀的变量从 EFI_GLOBAL_VARIABLE_GUID 重定向到 OC_VENDOR_VARIABLE_GUID。 启用这个 Quirk 需要用到在 OpenRuntime.efi 中实现的 OC_FIRMWARE_RUNTIME 协议。当固件删除不兼容的启动条目时，这一 Quirk 可以让默认的启动条目保存在引导菜单中。简单地说就是，如果你想使用「系统偏好设置」中的「启动磁盘」，就必须启用这一 Quirk。 借助 RequestBootVarRouting 将 Boot 前缀变量重定向至单独的 GUID 命名空间，可实现以下效果： 囚禁操作系统，使其只受 OpenCore 引导环境的控制，从而提高了安全性。 如遇到中途需要通过 OpenCore 来重启的情况，操作系统不会搞乱 OpenCore 的引导优先级，保证了系统更新和休眠唤醒的流畅性。 macOS 等潜在的不兼容的启动项，现在不会被意外删除或损坏了。 12. ResizeUsePciRbIoType: plist booleanFailsafe: falseDescription: 使用 PciRootBridgeIo 来调整 GpuBars 和 ResizeAppleGpuBar。 这个 Quirk 使得 ResizeGpuBars 和 ResizeAppleGpuBars 使用 PciRootBridgeIo 而不是 PciIo。 这在具有错误的 PciIo 实现的系统上是必须的，在这些系统上尝试配置 Resizable BAR 会导致 Capability I/O 错误。通常在已使用 ReBarUEFI 修改的旧系统上是必需的。 13. ResizeGpuBarsType: plist integerFailsafe: -1Description: 配置 GPU PCI BAR 的大小。 这个 Quirk 按照规定设置 GPU PCI BAR 的大小，或者选择低于 ResizeGpuBars 值的最大可用值。指定的值遵循 PCI Resizable BAR 的规则。使用 0 代表 1MB，1 代表 2M，2 代表 4MB，以此类推，直到 19 代表 512GB。 Resizable BAR 技术允许通过将可配置的内存区域 BAR 映射到 CPU 地址空间（例如，将 VRAM 映射到 RAM），而不是固定的内存区域，来简化 PCI 设备的编程。这项技术是必要的，因为人们不能在默认情况下映射最大的内存区域，原因是要向后兼容不支持 64 位 BAR 的旧硬件。因此，过去十年的设备默认使用 256MB 的 BAR（剩下的 4 位被其他数据使用），但通常允许将它们的大小调整为更小和更大的 2 次方（例如，从 1MB 到 VRAM 大小）。 针对 x86 平台的操作系统通常不控制 PCI 地址空间，让 UEFI 固件决定 BAR 地址和大小。这种非法的做法导致 Resizable BAR 技术直到 2020 年都没有被使用，尽管它在 2008 年被标准化，并在不久后被广泛用于硬件。 现代 UEFI 固件允许使用 Resizable BAR 技术，但通常将可配置的选项限制为故障安全默认值（OFF）和最大可用值（ON）。这个 Quirk 允许为测试和开发目的微调这个值。 考虑一个有 2 个 BAR 的 GPU。 BAR0 支持从 256MB 到 8GB 的大小。它的值是 4GB。 BAR1 支持从 2MB 到 256MB 的大小。它的值是 256MB。 例 1：将 ResizeGpuBars 设置为 1GB 将改变 BAR0 为 1GB，BAR1 保持不变。 例 2：将 ResizeGpuBars 设置为 1MB 将改变 BAR0 为 256MB，BAR0 为 2MB。 例 3：将 ResizeGpuBars 设置为 16GB 将改变 BAR0 为 8GB，BAR1 保持不变。 注 1：这个 Quirk 不应该被用来解决 macOS 对超过 1GB 的 BAR 的限制。应该使用 ResizeAppleGpuBars 来代替。 注 2：虽然这个 Quirk 可以增加 GPU PCI BAR 的大小，但这在大多数固件上是行不通的，因为这个 Quirk 不会重新定位内存中的 BAR，而且它们可能会重叠。在大多数情况下，最好将固件更新到最新版本或使用专门的驱动程序对其进行自定义，例如 ReBarUEFI。 14. TscSyncTimeoutType: plist integerFailsafe: 0Description: 尝试用指定的 Timeout 执行 TSC 同步。 这个 Quirk 的主要目的是在运行 XNU 调试内核时，在一些服务器和笔记本型号上实现早期引导 TSC 同步。对于调试内核，在任何 Kext 可能导致其他解决方案出现问题之前，TSC 需要在各个内核之间保持同步。Timeout 以微秒为单位，取决于平台上存在的核心数量，推荐的起始值是 500000。 这是一个实验性的 Quirk，只能被用于上述问题。在其他情况下，这个 Quirk 可能会导致操作系统不稳定，所以并不推荐使用。在其他情况下，推荐的解决办法是安装一个内核驱动，如 VoodooTSCSync、TSCAdjustReset 或 CpuTscSync（是 VoodooTSCSync 的一个更有针对性的变种，适用于较新的笔记本电脑）。 注：这个 Quirk 不能取代内核驱动的原因是它不能在 ACPI S3 模式（睡眠唤醒）下运行，而且 UEFI 固件提供的多核心支持非常有限，无法精确地更新 MSR 寄存器。 15. UnblockFsConnectType: plist booleanFailsafe: falseDescription: 某些固件通过「按驱动程序」模式下来阻止引导项加载，导致文件系统协议无法安装。 注：如果惠普笔记本在 OpenCore 界面没有看到引导项，启用这一选项。 11.19 ReservedMemory 属性1. AddressType: plist integerFailsafe: 0Description: 保留内存区域的起始地址，该区域应被分配为保留区，有效地将此类型的内存标记标记为操作系统不可访问。 这里写的地址必须是内存映射的一部分，具有 EfiConventionalMemory 类型，并且按页对齐（4KBs）。 注：禁用 CSM 后，某些固件可能不会为 S3（睡眠）和 S4（休眠）分配内存区域，因此导致唤醒失败。你可以分别比较禁用和启用 CSM 的内存映射，从低层内存中找到这些区域，并保留该区域来修复这个问题。详见 Sample.plist。 2. CommentType: plist stringFailsafe: Empty stringDescription: 用于为条目提供人类可读参考的任意 ASCII 字符串（译者注：即注释）。 3. SizeType: plist integerFailsafe: 0Description: 保留的内存区域的大小，必须按页对齐（4KB）。 4. TypeType: plist stringFailsafe: ReservedDescription: 内存区域类型，与 UEFI 规范的内存描述符类型的匹配映射如下： Reserved — EfiReservedMemoryType LoaderCode — EfiLoaderCode LoaderData — EfiLoaderData BootServiceCode — EfiBootServicesCode BootServiceData — EfiBootServicesData RuntimeCode — EfiRuntimeServicesCode RuntimeData — EfiRuntimeServicesData Available — EfiConventionalMemory Persistent — EfiPersistentMemory UnusableMemory — EfiUnusableMemory ACPIReclaimMemory — EfiACPIReclaimMemory ACPIMemoryNVS — EfiACPIMemoryNVS MemoryMappedIO — EfiMemoryMappedIO MemoryMappedIOPortSpace — EfiMemoryMappedIOPortSpace PalCode — EfiPalCode 5. EnabledType: plist booleanFailsafe: falseDescription: 除非设置为 true，否则该区域不会被保留。"}]